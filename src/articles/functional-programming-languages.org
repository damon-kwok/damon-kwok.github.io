#+DATE:      2017-09-01
#+INCLUDE: "./template"

#+BEGIN_CENTER
*函数编程语言对比*
#+END_CENTER

* 环境部署

** Elixir
   #+BEGIN_SRC shell
pacman -S elixir
iex
   #+END_SRC

** Erlang
   #+BEGIN_SRC shell
pacman -S erlang #erlang-nox
erl
   #+END_SRC

** Clojure
   #+BEGIN_SRC shell
pacman -S leiningen
lein repl
   #+END_SRC

** Elisp
   #+BEGIN_SRC shell
pacman -S emacs ;;emacs-nox
   #+END_SRC

** Haskell
   #+BEGIN_SRC shell
pacman -S stack
stack repl
   #+END_SRC

** Rust
   #+BEGIN_SRC shell
pacman -S rust
   #+END_SRC

   -----
* 注释
** Elixir
   #+BEGIN_SRC elixir
# 这是一个注释
   #+END_SRC

** Erlang
   #+BEGIN_SRC elixir
% 这是一个注释
%% 函数一般这样注释
%%% 模块一般这样注释
   #+END_SRC

** Clojure
   #+BEGIN_SRC clojure
;; 这是一个注释
   #+END_SRC

** Elisp
   #+BEGIN_SRC elisp
;; 这是一个注释
   #+END_SRC

** Haskell
   #+BEGIN_SRC haskell2
-- 这是一个注释
{- 这是多行注释 -}
   #+END_SRC

** Rust
   #+BEGIN_SRC rust
// 这是单行注释
/* ...这是多行注释 */
   #+END_SRC

   -----
* Last Eval

** Elixir
   #+BEGIN_SRC elixir

   #+END_SRC

** Erlang
   #+BEGIN_SRC elixir
v(1).
v(2).
   #+END_SRC


** Clojure
   #+BEGIN_SRC clojure
*1
*2
   #+END_SRC

** Haskell
   #+BEGIN_SRC haskell2

   #+END_SRC

** Rust
   #+BEGIN_SRC rust

   #+END_SRC

   -----
* 基本数据类型
** Elixir
   整型（integer），浮点（float），布尔（boolean），原子（atom，又称symbol符号），
   字符串（string），列表（list）和元组（tuple）等。

** Clojure

** Haskell

   -----
* 基本运算符

** Elixir
   +，-，*，/ div rem

** Clojure

** Haskell

   -----
* 匹配模式

  -----
* 字符串

** Elixir
   #+BEGIN_SRC elixir
str="hello,world!"
   #+END_SRC

** Clojure
   #+BEGIN_SRC clojure
"hello,world"
   #+END_SRC

** Haskell
   #+BEGIN_SRC haskell2
str="hello,world"
   #+END_SRC

** Rust
   #+BEGIN_SRC rust

   #+END_SRC

   -----
* 流程控制

  -----
* 匿名函数

** Elixir
   #+BEGIN_SRC elixir
func1 = fn(a,b)-> a + b end
func1.(1 2)

func = &(&1 + &2)
func.(1,2)
   #+END_SRC

** Erlang
   #+BEGIN_SRC elixir
Z=fun(X,Y) -> X+Y end.
func(1,2).
   #+END_SRC

** Clojure
   #+BEGIN_SRC clojure
(fn [a b] (+ a b))
(let [func (fn [a b] (+ a b))] 
  (func 1 2)) ;;3

#(+ %1 %2)
   #+END_SRC

** Elisp
   #+BEGIN_SRC elisp
(lambda(a b) (+ a b))
((lambda(a b) (+ a b)) 1 2) ;;3
   #+END_SRC

** Haskell
   #+BEGIN_SRC haskell2
(\a b-> a + b) 1 2 --3
func = (\a b -> x + b)
func 1 2 --3
   #+END_SRC

** Rust
   #+BEGIN_SRC rust
let func = |a,b| a + b; //3
func(1,2); //3
   #+END_SRC

** OCaml
   #+BEGIN_SRC sml
let add = fun a b -> (a +. b);;
List.map (fun i -> i*2) [1;2;3];;
   #+END_SRC
