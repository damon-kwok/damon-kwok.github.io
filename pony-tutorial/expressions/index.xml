<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>概述（Overview） on Pony 教程</title>
    <link>https://damon-kwok.github.io/pony-tutorial/expressions.html</link>
    <description>Recent content in 概述（Overview） on Pony 教程</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://damon-kwok.github.io/pony-tutorial/expressions/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>object关键字（Object Literals）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/object-literals.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/object-literals.html</guid>
      <description>Sometimes it&amp;rsquo;s really convenient to be able to write a whole object inline. In Pony, this is called an object literal, and it does pretty much exactly what an object literal in JavaScript does: it creates an object that you can use immediately.
But Pony is statically typed, so an object literal also creates an anonymous type that the object literal fulfills. This is similar to anonymous classes in Java and C#.</description>
    </item>
    
    <item>
      <title>Partial Application</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/partial-application.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/partial-application.html</guid>
      <description>Partial application lets us supply some of the arguments to a constructor, function, or behaviour, and get back something that lets us supply the rest of the arguments later.
A simple case A simple case is to create a &amp;ldquo;callback&amp;rdquo; function. For example:
class Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =&amp;gt; _f = (_f + add) * mul class Bar fun apply() =&amp;gt; let foo: Foo = Foo let f = foo~addmul(3) f(4) This is a bit of a silly example, but hopefully, the idea is clear.</description>
    </item>
    
    <item>
      <title>变量（Variables）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/variables.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/variables.html</guid>
      <description>Like most other programming languages Pony allows you to store data in variables. There are a few different kinds of variables which have different lifetimes and are used for slightly different purposes.
局部变量 Local variables in Pony work very much as they do in other languages, allowing you to store temporary values while you perform calculations. Local variables live within a chunk of code (they are local to that chunk) and are created every time that code chunk executes and disposed of when it completes.</description>
    </item>
    
    <item>
      <title>字面量（Literals）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/literals.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/literals.html</guid>
      <description>What do we want?
Values!
Where do we want them?
In our Pony programs!
Say no more
Every programming language has literals to encode values of certain types, and so does Pony.
In Pony you can express booleans, numeric types, characters, strings and arrays as literals.
Bool型 There is true, there is false. That&amp;rsquo;s it.
数值型 Numeric literals can be used to encode any signed or unsigned integer or floating point number.</description>
    </item>
    
    <item>
      <title>方法（Methods）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/methods.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/methods.html</guid>
      <description>All Pony code that actually does something, rather than defining types etc, appears in named blocks which are referred to as methods. There are three kinds of methods: functions, constructors, and behaviours. All methods are attached to type definitions (e.g. classes) - there are no global functions.
Behaviours are used for handling asynchronous messages sent to actors, which we&amp;rsquo;ve seen in the &amp;ldquo;Types&amp;rdquo; chapter when we talked about actors.
Can I have some code outside of any methods like I do in Python?</description>
    </item>
    
    <item>
      <title>比较运算（Equality in Pony）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/equality.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/equality.html</guid>
      <description>Pony features two forms of equality: by structure and by identity.
Identity equality Identity equality checks in Pony are done via the is keyword. is verifies that the two items are the same.
if None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(&amp;quot;hi&amp;quot;) let b = Foo(&amp;quot;hi&amp;quot;) if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP!</description>
    </item>
    
    <item>
      <title>流程控制（Control Structures）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/control-structures.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/control-structures.html</guid>
      <description>To do real work in a program you have to be able to make decisions, iterate through collections of items and perform actions repeatedly. For this, you need control structures. Pony has control structures that will be familiar to programmers who have used most languages, such as if, while and for, but in Pony, they work slightly differently.
Conditionals The simplest control structure is the good old if. It allows you to perform some action only when a condition is true.</description>
    </item>
    
    <item>
      <title>算术运算符（Arithmetic）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/arithmetic.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/arithmetic.html</guid>
      <description>Arithmetic is about the stuff you learn to do with numbers in primary school: Addition, Subtraction, Multiplication, Division and so on. Piece of cake. We all know that stuff. We nonetheless want to spend a whole section on this topic, because when it comes to computers the devil is in the details.
As introduced in Primitives numeric types in Pony are represented as a special kind of primitive that maps to machine words.</description>
    </item>
    
    <item>
      <title>语法糖（Sugar）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/sugar.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/sugar.html</guid>
      <description>Pony allows you to omit certain small details from your code and will put them back in for you. This is done to help make your code less cluttered and more readable. Using sugar is entirely optional, you can always write out the full version if you prefer.
Apply Many Pony classes have a function called apply which performs whatever action is most common for that type. Pony allows you to omit the word apply and just attempt to do a call directly on the object.</description>
    </item>
    
    <item>
      <title>运算符（Operators）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/ops.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/ops.html</guid>
      <description>中缀运算符 Infix operators take two operands and are written between those operands. Arithmetic and comparison operators are the most common:
1 + 2 a &amp;lt; b Pony has pretty much the same set of infix operators as other languages.
Operator aliasing Most infix operators in Pony are actually aliases for functions. The left operand is the receiver the function is called on and the right operand is passed as an argument.</description>
    </item>
    
    <item>
      <title>错误（Errors）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/expressions/errors.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/expressions/errors.html</guid>
      <description>Pony doesn&amp;rsquo;t feature exceptions as you might be familiar with them from languages like Python, Java, C++ et al. It does, however, provide a simple partial function mechanism to aid in error handling. Partial functions and the error keyword used to raise them look similar to exceptions in other languages but have some important semantic differences. Let&amp;rsquo;s take a look at how you work with Pony&amp;rsquo;s error and then how it differs from the exceptions you might be used to.</description>
    </item>
    
  </channel>
</rss>