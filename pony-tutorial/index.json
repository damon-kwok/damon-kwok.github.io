[{"content":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.\nLet’s start with a simple one.\nleft side must be something that can be assigned to Suppose you wrote:\nactor Main let x: I64 = 0 new create(env: Env) =\u003e x = 12 The error message would be:\nError: .../a.pony:6:5: can't assign to a let or embed definition more than once x = 12 ^ Error: .../a.pony:6:7: left side must be something that can be assigned to x = 12 ^ What happened is that you declared x as a constant, by writing let x, and then tried to assign a new value to it, 12. To fix the error, replace let with var or reconsider what value you want x to have.\nThat one error resulted in two error messages. The first, pointing to the x, describes the specific problem, that x was defined with let. The second, pointing to the = describes a more general error, that whatever is on the left side of the assignment is not something that can be assigned to. You would get that same error message if you attempted to assign a value to a literal, like 3.\ncannot write to a field in a box function Suppose you create a class with a mutable field and added a method to change the field:\nclass Wombat var color: String = \"brown\" fun dye(new_color: String) =\u003e color = new_color The error message would be:\nError: .../a.pony:4:11: cannot write to a field in a box function. If you are trying to change state in a function use fun ref color = new_color ^ To understand this error message, you have to have some background. The field color is mutable since it is declared with var, but the method dye does not have an explicit receiver reference capability. The default receiver reference capability is box, which allows dye to be called on any mutable or immutable Wombat; the box reference capability says that the method may read from but not write to the receiver. As a result, it is illegal to attempt to modify the receiver in the method.\nTo fix the error, you would need to give the dye method a mutable reference capability, such as ref: fun ref dye(new_color: String) =\u003e ....\nreceiver type is not a subtype of target type Suppose you made a related, but slightly different error:\nclass Rainbow let colors: Array[String] = Array[String] fun add_stripe(color: String) =\u003e colors.push(color) In this example, rather than trying to change the value of a field, the code calls a method which attempts to modify the object referred to by the field.\nThe problem is very similar to that of the last section, but the error message is significantly more complicated:\nError: ../a.pony:4:16: receiver type is not a subtype of target type colors.push(color) ^ Info: .../a.pony:4:5: receiver type: this-\u003eArray[String val] ref colors.push(color) ^ .../ponyc/packages/builtin/array.pony:252:3: target type: Array[String val] ref fun ref push(value: A): Array[A]^ =\u003e ^ .../a.pony:2:15: Array[String val] box is not a subtype of Array[String val] ref: box is not a subtype of ref let colors: Array[String] = Array[String]() ^ Once again, Pony is trying to be helpful. The first few lines describe the error, in general terms that only a programming language maven would like: an incompatibility between the receiver type and the target type. However, Pony provides more information: the lines immediately after “Info:” tell you what it believes the receiver type to be and the next few lines describe what it believes the target type to be. Finally, the last few lines describe in detail what the problem is.\nUnfortunately, this message does not locate the error as clearly as the previous examples.\nBreaking it down, the issue seems to be with the call to push, with the receiver colors. The receiver type is this-\u003eArray[String val] ref; in other words, the view that this method has of a field whose type is Array[String val] ref. In the class Rainbow, the field colors is indeed declared with the type Array[String], and the default reference capability for Strings is val while the default reference capability for Array is ref.\nThe “target type” in this example is the type declaration for the method push of the class Array, with its type variable A replaced by String (again, with a default reference capability of val). The reference capability for the overall array, as required by the receiver reference capability of push, is ref. It seems that the receiver type and the target type should be pretty close.\nBut take another look at the final lines: what Pony thinks is the actual receiver type, Array[String val] box, is significantly different from what it thinks is the actual target type, Array[String val] ref. And a type with a reference capability of box, which is immutable, is indeed not a subtype of a type with a reference capability of ref, which is mutable.\nThe issue must lie with the one difference between the receiver type and the target type, which is the prefix “this-\u003e”. The type this-\u003eArray[String val] ref is a viewpoint adapted type, or arrow type, that describes the Array[String val] ref “as seen by the receiver”. The receiver, in this case, has the receiver reference capability of the method add_stripe, which is the default box. That is why the final type is Array[String val] box.\nThe fundamental error in this example is the same as the last: the default receiver reference capability for a method is box, which is immutable. This method, however, is attempting to modify the receiver, by adding another color stripe. That is not legal at all.\nAs an aside, while trying to figure out what is happening, you may have been misled by the declaration of the colors field, let colors.... That declaration makes the colors binding constant. As a result, you cannot assign a new array to the field. On the other hand, the array itself can be mutable or immutable. In this example, it is mutable, allowing push to be called on the colors field in the add_stripe method.\nA note on compiler versions The error messages shown in this section are from ponyc 0.2.1-1063-g6ae110f [release], the current head of the master branch at the time this is written. The messages from other versions of the compiler may be different, to a greater or lesser degree.\n","summary":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.","title":"A Short Guide to Pony Error Messages","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/error-messages.html"},{"content":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible. This can be applied to types that are related through inheritance, as well as unions and intersections. This is done at runtime, and if it fails then an error is raised.\nLet’s look at an example. The json package provides a type called JsonDoc that can attempt to parse strings as fragments of JSON. The parsed value is stored in the data field of the object, and that field’s type is the union (F64 | I64 | Bool | None | String | JsonArray | JsonObject). So if there is a JsonDoc object referenced by jsonDoc then jsonDoc.parse(\"42\") will store an I64 equal to 42 in jsonDoc.data. If the programmer wants to treat jsonDoc.data as an I64 then they can get an I64 reference to the data by using jsonDoc.data as I64.\nIn the following program, the command line arguments are parsed as Json. A running sum is kept of all of the arguments that can be parsed as I64 numbers, and all other arguments are ignored.\nuse \"json\" actor Main new create(env: Env) =\u003e var jsonSum: I64 = 0 let jd: JsonDoc = JsonDoc for arg in env.args.slice(1).values() do try jd.parse(arg)? jsonSum = jsonSum + (jd.data as I64) end end env.out.print(jsonSum.string()) When run with the arguments 2 and 4 et 7 y 15, the program’s output is 28.\nThe same thing can be done with interfaces, using as to create a reference to a more specific interface or class. Let’s say, for example, that you have a library for doing things with furry, rodent-like creatures. It provides a Critter interface which programmers can then use to create specific types of critters.\ninterface Critter fun wash(): String The programmer uses this library to create a Wombat and a Capybara class. But the Capybara class provides a new method, swim(), that is not part of the Critter class. The programmer wants to store all of the critters in an array, in order to carry out actions on groups of critters. Now assume that when capybaras finish washing they want to go for a swim. The programmer can accomplish that by using as to attempt to use each Critter object in the Array[Critter] as a Capybara. If this fails because the Critter is not a Capybara, then an error is raised; the program can swallow this error and go on to the next item.\ninterface Critter fun wash(): String class Wombat is Critter fun wash(): String =\u003e \"I'm a clean wombat!\" class Capybara is Critter fun wash(): String =\u003e \"I feel squeaky clean!\" fun swim(): String =\u003e \"I'm swimming like a fish!\" actor Main new create(env: Env) =\u003e let critters = Array[Critter].\u003epush(Wombat).\u003epush(Capybara) for critter in critters.values() do env.out.print(critter.wash()) try env.out.print((critter as Capybara).swim()) end end Specify the type of items in an array literal The as operator can be used to tell the compiler what type to use for the items in an array literal. In many cases, the compiler can infer the type, but sometimes it is ambiguous.\nFor example, in the case of the following program, the method foo can take either an Array[U32] ref or an Array[U64] ref as an argument. If a literal array is passed as an argument to the method and no type is specified then the compiler cannot deduce the correct one because there are two equally valid ones.\nactor Main fun foo(xs: (Array[U32] ref | Array[U64] ref)): Bool =\u003e // do something boring here true new create(env: Env) =\u003e foo([as U32: 1; 2; 3]) // the compiler would complain about this: // foo([1; 2; 3]) The requested type must be a valid type for the items in the array. Since these types are checked at compile time they are guaranteed to work, so there is no need for the programmer to handle an error condition.\n","summary":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible.","title":"as操作符（As Operator）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/as.html"},{"content":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony. A Jump Consistent Hash, for example, could be provided in pure Pony as follows:\n// Jump consistent hashing in Pony, with an inline pseudo random generator fun jch(key: U64, buckets: I64): I32 =\u003e var k = key var b = I64(0) var j = I64(0) while j \u003c buckets do b = j k = (k * 2862933555777941757) + 1 j = ((b + 1).f64() * (U32(1 \u003c\u003c 31).f64() / ((key \u003e\u003e 33) + 1).f64())).i64() end b.i32() Let’s say we wish to compare the pure Pony performance to an existing C function with the following header:\n#ifndef __JCH_H_ #define __JCH_H_  extern \"C\" { int32_t jch_chash(uint64_t key, uint32_t num_buckets); } #endif Note the use of extern \"C\". If the library is built as C++ then we need to tell the compiler not to mangle the function name, otherwise, Pony won’t be able to find it. For libraries built as C, this is not needed, of course.\nThe implemented would be something like:\n#include \u003cstdint.h\u003e#include \u003climits.h\u003e#include \"math.h\" // A reasonably fast, good period, low memory use, xorshift64* based prng double lcg_next(uint64_t* x) { *x ^= *x \u003e\u003e 12; *x ^= *x \u003c\u003c 25; *x ^= *x \u003e\u003e 27; return (double)(*x * 2685821657736338717LL) / ULONG_MAX; } // Jump consistent hash int32_t jch_chash(uint64_t key, uint32_t num_buckets) { uint64_t seed = key; int b = -1; int32_t j = 0; do { b = j; double r = lcg_next(\u0026seed); j = floor((b + 1)/r); } while(j \u003c num_buckets); return (int32_t)b; } We need to compile the native code to a shared library. This example is for OSX. The exact details may vary on other platforms.\nclang -fPIC -Wall -Wextra -O3 -g -MM jch.c \u003ejch.d clang -fPIC -Wall -Wextra -O3 -g -c -o jch.o jch.c clang -shared -lm -o libjch.dylib jch.o The Pony code to use this new C library is just like the code we’ve already seen for using C libraries.\n\"\"\" This is an example of Pony integrating with native code via the built-in FFI support \"\"\" use \"lib:jch\" use \"collections\" use \"random\" use @jch_chash[I32](hash: U64, bucket_size: U32) actor Main var _env: Env new create(env: Env) =\u003e _env = env let bucket_size: U32 = 1000000 var random = MT for i in Range[U64](1, 20) do let r: U64 = random.next() let hash = @jch_chash(i, bucket_size) _env.out.print(i.string() + \": \" + hash.string()) end We can now use ponyc to compile a native executable integrating Pony and our C library. And that’s all we need to do.\n","summary":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony.","title":"C ABI","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/c-abi.html"},{"content":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.\nBare functions Classic Pony functions have a receiver, which acts as an implicit argument to the function. Because of this, classic functions can’t be used as callbacks with many C APIs. Instead, you can use bare functions, which are functions with no receiver.\nYou can define a bare function by prefixing the function name with the @ symbol.\nclass C fun @callback() =\u003e ... The function can then be passed as a callback to a C API with the addressof operator.\n@setup_callback(addressof C.callback) Note that it is possible to use an object reference instead of a type as the left-hand side of the method access.\nSince bare methods have no receiver, they cannot reference the this identifier in their body (either explicitly or implicitly through field access), cannot use this viewpoint adapted types, and cannot specify a receiver capability.\nBare lambdas Bare lambdas are special lambdas defining bare functions. A bare lambda or bare lambda type is specified using the same syntax as other lambda types, with the small variation that it is prefixed with the @ symbol. The underlying value of a bare lambda is equivalent to a C function pointer, which means that a bare lambda can be directly passed as a callback to a C function. The partial application of a bare method yields a bare lambda.\nlet callback = @{() =\u003e ... } @setup_callback(callback) Bare lambdas can also be used to define structures containing function pointers. For example:\nstruct S var fun_ptr: @{()} This Pony structure is equivalent to the following C structure:\nstruct S { void(*fun_ptr)(); }; In the same vein as bare functions, bare lambdas cannot specify captures, cannot use this neither as an identifier nor as a type, and cannot specify a receiver capability. In addition, a bare lambda object always has a val capability.\nClassic lambda types and bare lambda types can never be subtypes of each other.\nAn example Consider SQLite, mentioned earlier. When the client code calls sqlite3_exec, an SQL query is executed against a database, and the callback function is called for each row returned by the SQL statement. Here’s the signature for sqlite3_exec:\ntypedef int (*sqlite3_callback)(void*,int,char**, char**); ... SQLITE_API int SQLITE_STDCALL sqlite3_exec( sqlite3 *db, /* The database on which the SQL executes */ const char *zSql, /* The SQL to be executed */ sqlite3_callback xCallback, /* Invoke this callback routine */ void *pArg, /* First argument to xCallback() */ char **pzErrMsg /* Write error messages here */ ) { ... xCallback(pArg, nCol, azVals, azCols) ... } sqlite3_callback is the type of the callback function that will be called by sqlite3_exec for each row returned by the sql statement. The first argument to the callback function is the pointer pArg that was passed to sqlite3_exec, the second argument is the number of columns in the row being processed, the third argument is data for each column, and the fourth argument is the name of each column.\nHere’s the skeleton of some Pony code that uses sqlite3_exec to query an SQLite database, with examples of both the bare method way and the bare lambda way:\nclass SQLiteClient fun client_code() =\u003e ... @sqlite3_exec[I32](db, sql.cstring(), addressof this.method_callback, this, addressof zErrMsg) ... fun @method_callback(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... class SQLiteClient fun client_code() =\u003e ... let lambda_callback = @{(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... } @sqlite3_exec[I32](db, sql.cstring(), lambda_callback, this, addressof zErrMsg) ... Focusing on the callback-related parts, the callback function is passed using addressof this.method_callback (resp. by directly passing the bare lambda) as the third argument to sqlite3_exec. The fourth argument is this, which will end up being the first argument when the callback function is called. The callback function is called in sqlite3_exec by the call to xCallback.\n","summary":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.","title":"Callbacks","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/callbacks.html"},{"content":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call. Any time you see an @ in Pony there’s an FFI going on.\nThe other key difference is that the return type of the function is specified after the function name, in square brackets. This is because the compiler needs to know what type the value returned is (if any), but has no way to determine that, so it needs you to explicitly tell it.\nThere are a few unusual things going on with the arguments to this FFI call as well. For the second argument, for which we’re passing the value 1, we’ve had to specify that this is a U64. Again this is because the compiler needs to know what size argument to use, but has no way to determine this.\nSafely does it It is VERY important that when calling FFI functions you MUST get the parameter and return types right. The compiler has no way to know what the native code expects and will just believe whatever you do. Errors here can cause invalid data to be passed to the FFI function or returned to Pony, which can lead to program crashes.\nTo help avoid bugs here Pony allows you to specify the type signatures of FFI functions in advance. Whilst you must still get the types correct the arguments you provide at each FFI call site are checked against the declared signature. This means that you must get a type wrong, in the same way, in at least 2 places for a bug to exist. This won’t help if the argument types the native code expects are different to what you think they are, but it will protect you against trivial mistakes and simple typos.\nFFI signatures are declared using the use command. Here’s an example from the standard library:\nuse @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32, parg: Pointer[U8] tag) if windows use @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64, parg: Pointer[U8] tag) if not windows class SSLContext val new create() =\u003e // set SSL_OP_NO_SSLv2 @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8]) The @ symbol tells us that the use command is an FFI signature declaration. The types specified here are considered authoritative and any FFI calls that differ are considered to be an error.\nNote that we no longer need to specify the return type at the call site, since the signature declaration has already told us what it is. However, it is perfectly acceptable to specify it again if you want to.\nThe use @ command can take a condition just like other use commands. This is useful in this case, where the Windows version of SSL_CTX_ctrl has a slightly different signature to other platforms.\nC types Many C functions require types that don’t have an exact equivalent in Pony. A variety of features is provided for these.\nFor FFI functions that have no return value (ie they return void in C) the return value specified should be [None].\nIn Pony String is an object with a header and fields, but in C a char* is simply a pointer to character data. The .cstring() function on String provides us with a valid pointer to hand to C. Our fwrite example above makes use of this for the first argument.\nPony classes correspond directly to pointers to the class in C.\nFor C pointers to simple types, such as U64, the Pony Pointer[] polymorphic type should be used, with a tag reference capability. Pointer[U8] tag should be used for void*. This can be seen in our SSL_CTX_ctrl example above.\nTo pass pointers to values to C the addressof operator can be used (previously \u0026), just like taking an address in C. This is done in the standard library to pass the address of a U64 to an FFI function that takes a uint64_t* as an out parameter:\nvar len = U64(0) @pcre2_substring_length_bynumber_8[I32](_match, i.u32(), addressof len) Get and Pass Pointers to FFI To pass and receive pointers to c structs you need to declare pointer to primitives\nprimitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Read Struct Values from FFI A common pattern in C is to pass a struct pointer to a function, and that function will fill in various values in the struct. To do this in Pony, you make a struct and then use a NullablePointer:\nstruct Winsize var height: U16 = 0 var width: U16 = 0 new create() =\u003e None let size = Winsize @ioctl(0, 21523, NullablePointer[Winsize](size)) env.out.print(size.height.string()) FFI functions raising errors FFI functions can raise Pony errors. Functions in existing C libraries are very unlikely to do this, but support libraries specifically written for use with Pony may well do.\nFFI calls to functions that might raise an error must mark it as such by adding a ? after the arguments. For example:\n@os_send[U64](_event, data.cstring(), data.size()) ? // May raise an error If a signature declaration is used then that must be marked as possibly raising an error in the same way. The FFI call site must mark it as well.\nuse @os_send[U64](ev: Event, buf: Pointer[U8] tag, len: U64) ? @os_send(_event, data.cstring(), data.size())? // May raise an error ","summary":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call.","title":"Calling C from Pony","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/calling-c.html"},{"content":"","summary":"","title":"Categories","uri":"https://damon-kwok.github.io/pony-tutorial/categories.html"},{"content":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g. With -l you can generate a C library, lib\u003cdirectory\u003e.\n--debug will skip the LLVM optimizations passes. This should not be mixed up with make config=debug, the default make configuration target. config=debug will create DWARF symbols, and add slower assertions to ponyc, but not to the generated binaries. For those, you can omit DWARF symbols with the --strip or -s option.\n--path or -p take a : separated path list as the argument and adds those to the compile-time library paths for the linker to find source packages and the native libraries, static or dynamic, being linked at compile-time or via the FFI at run-time. The system adds several paths already, e.g. on windows it queries the registry to find the compiler run-time paths, you can also use use \"lib:path\" statements in the source code and as a final possibility, you can add -p paths. But if you want the generated binary to accept such a path to find a dynamic library on your client system, you need to handle that in your source code by yourself. See the options package for this.\n--output or -o takes a directory name where the final binary is created.\n--docs or -g creates a directory of the package with documentation in readthedocs.org format, i.e. markdown with nice navigation.\nLet’s study the documentation of the builtin stdlib:\npip install mkdocs ponyc packages/stdlib --docs \u0026\u0026 cd stdlib-docs \u0026\u0026 mkdocs serve And point your web browser to http://127.0.0.1:8000 serving a live-reloading local version of the docs.\nNote that there is no built-in debugger to interactively step through your program and interpret the results. But ponyc creates proper DWARF symbols and you can step through your programs with a conventional debugger, such as GDB or LLDB.\nRuntime options for Pony programs Besides using the cli package, there are also several built-in options for the generated binary (not for use with ponyc) starting with --pony*, see ponyc --help, to tweak runtime performance. You can override the number of initial threads, tune cycle detection (CD), the garbage collector and even turn off yield, which is not really recommended.\n","summary":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g.","title":"Compiler Arguments","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/compiler-args.html"},{"content":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero. That’s right,\nlet x = I64(1) / I64(0) results in 0 being assigned to x. Baffling right? Well, yes and no. From a mathematical standpoint, it is very much baffling. From a practical standpoint, it is very much not.\nWhile Pony has Partial division:\nlet x = try I64(1) /? I64(0) else // handle division by zero end Defining division as partial leads to code littered with trys attempting to deal with the possibility of division by zero. Even if you had asserted that your denominator was not zero, you’d still need to protect against divide by zero because, at this time, the compiler can’t detect that value dependend typing.\nPony also offers Unsafe Division, which declares division by zero as undefined, as in C:\n// the value of x is undefined let x = I64(1) /~ I64(0) But declaring this case as undefined does not help us out here. As a programmer you’d still need to guard that case in order to not poison your program with undefined values or risking terminating your program with a SIGFPE. So, in order to maintain a practical API and avoid undefined behaviour, normal division on integers in Pony is defined to be 0. To avoid 0s silently creeping through your divisions, use Partial or Checked Division.\nDivide by zero on floating points In conformance with IEEE 754, floating point division by zero results in inf or -inf, depending on the sign of the numerator.\nIf you can assert that your denominator cannot be 0, it is possible to use Unsafe Division to gain some performance:\nlet x = F64(1.5) /~ F64(0.5) ","summary":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero.","title":"Divide by Zero","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/divide-by-zero.html"},{"content":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().values() do end Read struct values from FFI If you have a C struct which returns a struct with data like this\ntypedef struct { uint8_t code; float x; float y; } EGLEvent; EGLEvent getEvent() { EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height}; return e; } the you can destructure it and get the values using a tuple\ntype EGLEvent is (U8, F32, F32) (var code, var x, var y) = @getEvent[EGLEvent]() Get and pass pointers to FFI primitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Pass an Array of values to FFI (TODO) primitive _EGLConfigHandle let a = Array[U16](8) a.push(0x3040) a.push(0x4) a.push(0x3033) a.push(0x4) a.push(0x3022) a.push(0x8) a.push(0x3023) a.push(0x8) a.push(0x3024) let config = Pointer[_EGLConfigHandle] if @eglChooseConfig[U32](e_dpy, a, config, U32(1), Pointer[U32]) == 0 then env.out.print(\"eglChooseConfig failed\") end How to access command line arguments actor Main new create(env: Env) =\u003e // The no of arguments env.out.print(env.args.size().string()) for value in env.args.values() do env.out.print(value) end // Access the arguments the first one will always be the application name try env.out.print(env.args(0)?) end How to use cli to parse command line arguments use \"cli\" actor Main new create(env: Env) =\u003e let command_spec = try CommandSpec.leaf( \"pony-embed\", \"sample program\", [ OptionSpec.string(\"output\", \"output filename\", 'o') ], [ ArgSpec.string(\"input\", \"source of input\" where default' = \"-\") ] )? .\u003e add_help()? else env.exitcode(1) return end let command = match CommandParser(command_spec).parse(env.args, env.vars) | let c: Command =\u003e c | let ch: CommandHelp =\u003e ch.print_help(env.out) env.exitcode(0) return | let se: SyntaxError =\u003e env.err.print(se.string()) env.exitcode(1) return end let input_source = command.arg(\"input\").string() let output_filename = command.option(\"output\").string() env.out.print(\"Loading data from \" + input_source + \". Writing output to \" + output_filename) // ... How to write tests Just create a test.pony file\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAddition) class iso _TestAddition is UnitTest \"\"\" Adding 2 numbers \"\"\" fun name(): String =\u003e \"u32/add\" fun apply(h: TestHelper): TestResult =\u003e h.expect_eq[U32](2 + 2, 4) Some assertions you can make with the TestHelper are\nfun tag log(msg: String, verbose: Bool = false) be fail() =\u003e be assert_failed(msg: String) =\u003e fun tag assert_true(actual: Bool, msg: String = \"\") ? fun tag expect_true(actual: Bool, msg: String = \"\"): Bool fun tag assert_false(actual: Bool, msg: String = \"\") ? fun tag expect_false(actual: Bool, msg: String = \"\"): Bool fun tag assert_error(test: ITest, msg: String = \"\") ? fun tag expect_error(test: ITest box, msg: String = \"\"): Bool fun tag assert_is (expect: Any, actual: Any, msg: String = \"\") ? fun tag expect_is (expect: Any, actual: Any, msg: String = \"\"): Bool fun tag assert_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\") ? fun tag expect_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\"): Bool Operator overloading (easy for copy and paste) fun add(other: A): A fun sub(other: A): A fun mul(other: A): A fun div(other: A): A fun rem(other: A): A fun mod(other: A): A fun eq(other: A): Bool fun ne(other: A): Bool fun lt(other: A): Bool fun le(other: A): Bool fun ge(other: A): Bool fun gt(other: A): Bool fun shl(other: A): A fun shr(other: A): A fun op_and(other:A): A fun op_or(other: A): A fun op_xor(othr: A): A Create empty functions in a class class Test fun alpha() =\u003e \"\"\" \"\"\" fun beta() =\u003e \"\"\" \"\"\" How to create Arrays with values Single values can be separated by semicolon or newline.\nlet dice: Array[U32] = [1; 2; 3 4 5 6 ] How to modify a lexically captured variable in a closure actor Main fun foo(n:U32): {ref(U32): U32} =\u003e var s: Array[U32] = Array[U32].init(n, 1) {ref(i:U32)(s): U32 =\u003e try s(0) = s(0) + i s(0) else 0 end } new create(env:Env) =\u003e var f = foo(5) env.out.print(f(10).string()) env.out.print(f(20).string()) ","summary":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().","title":"Examples","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/examples.html"},{"content":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver. The use of assignment expressions like x = 42 is quite rare so we don’t think many folks will be bitten by this. However, it’s definitely something you want to be aware of. Also remember that if fn were to be called, it would be called with 0 (the result of the assignment expression).\n","summary":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver.","title":"Function Call Side Effects","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/side-effect-ordering-in-function-call-expressions.html"},{"content":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up. This sucks if you want predictable completion of sections of code. Most of the time, your function will finish in less than a millisecond but every now and then, its paused during execution to GC. There are advantages to this approach. Whenever you run low on memory, the GC can attempt to free some memory and get you more. In general, this is how people expect Pony’s garbage collector to work. As you might guess though, it doesn’t work that way.\nGarbage Collection in Pony Garbage collection is never attempted on any actor while it is executing a behavior. This gives you very predictable performance when executing behaviors but also makes it easy to grab way more memory than you intend to. Let’s take a look at how that can happen via the “long-running behavior problem”.\nLong running behaviors and memory Here’s a typical “I’m learning Pony” program:\nactor Main new create(env: Env) for i in Range(1, 2_000_000) do ... something that uses up heap ... end This program will never garbage collect before exiting. create is run as a behavior on actors which means that no garbage collection will occur while it’s running. Long loops in behaviors are a good way to exhaust memory. Don’t do it. If you want to execute something in such a fashion, use a Timer.\n","summary":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up.","title":"Garbage Collection","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/garbage-collection.html"},{"content":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.\nPony-ORCA, yes the killer whale, is based on ideas from ownership and deferred, distributed, weighted reference counting. It adapts messaging systems of actors to keep the reference count consistent. The main challenges in concurrent garbage collection are the detection of cycles of sleeping actors in the actor’s graph, in the presence of the concurrent mutation of this graph. With message passing, you get deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph).\n  Soundness: the technique collects only dead actors.\n  Completeness: the technique collects all dead actors eventually.\n  Concurrency: the technique does not require a stop-the-world step, clocks, time stamps, versioning, thread coordination, actor introspection, shared memory, read/write barriers or cache coherency.\n  The type system ensures at compile time that your program can never have data races. It’s deadlock free… Because Pony has no locks!\nWhen an actor has completed local execution and has no pending messages on its queue, it is blocked. An actor is dead, if it is blocked and all actors that have a reference to it are blocked, transitively. A collection of dead actors depends on being able to collect closed cycles of blocked actors.\nThe Pony type system guarantees race and deadlock free concurrency and soundness by adhering to the following principles:\nPony-ORCA characteristics   An actor may perform garbage collection concurrently with other actors while they are executing any kind of behaviour.\n  An actor may decide whether to garbage collect an object solely based on its own local state, without consultation with or inspecting the state of any other actor.\n  No synchronization between actors is required during garbage collection, other than potential message sends.\n  An actor may garbage collect between its normal behaviours, i.e. it need not wait until its message queue is empty.\n  Pony-ORCA can be applied to several other programming languages, provided that they satisfy the following two requirements:\n  Actor behaviours are atomic.\n  Message delivery is causal. Causal: messages arrive before any messages they may have caused if they have the same destination. So there needs to be some kind of causal ordering guarantee, but fewer requirements than with comparable concurrent, fast garbage collectors.\n    ","summary":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.","title":"Garbage Collection with Pony-ORCA","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/garbage-collection.html"},{"content":"你已经成功的安装了Pony编译器，来试着编写第一个Pony程序：输出\"hello,world!\"。首先，创建一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 目录名称重要吗？ 重要。这将是程序编译后的文件名！默认情况下，编译程序生成的可执行文件将使用源码的目录名，想要的文件名需要在命令行上使用--bin-name或-b选项指。\n代码 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件名重要吗？ 对编译器来说不重要。 Pony只关心源文件的扩展名.pony，不关心文件名。但文件名对你来说很重要！给源文件起个好名字，可以方便以后定位代码。\n在文件中输入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 如果想在Docker中使用Pony，可以这么做：\n$ docker run -v Some_Absolute_Path/helloworld:/src/main ponylang/ponyc 注意，需要将目录路径替换成你自己的。\n你会发现，它在当前目录进行了构建，.，Pony对代码进行了优化，并创建了一些目标文件（如果你不知道那是什么，不用担心） ，然后将其链接到了一个可执行文件中。如果你是C/C++程序员，那对你来说可能是有意义的，否则你可以忽略它。\n构建过程中也进行链接吗？ 没错，Pony不需要额外的构建程序（例如make），自己能处理（包括在链接到C库时处理依赖项的顺序，后面章节会介绍）。\n运行程序 运行程序：\n$ ./helloworld Hello, world! 恭喜你，完成了第一个Pony程序！下节我们讲解代码的含义。\n","summary":"你已经成功的安装了Pony编译器，来试着编写第一个Pony程序：输出\"hello,world!\"。首先，创建一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 目录名称重要吗？ 重要。这将是程序编译后的文件名！默认情况下，编译程序生成的可执行文件将使用源码的目录名，想要的文件名需要在命令行上使用--bin-name或-b选项指。\n代码 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件名重要吗？ 对编译器来说不重要。 Pony只关心源文件的扩展名.pony，不关心文件名。但文件名对你来说很重要！给源文件起个好名字，可以方便以后定位代码。\n在文件中输入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 如果想在Docker中使用Pony，可以这么做：\n$ docker run -v Some_Absolute_Path/helloworld:/src/main ponylang/ponyc 注意，需要将目录路径替换成你自己的。\n你会发现，它在当前目录进行了构建，.，Pony对代码进行了优化，并创建了一些目标文件（如果你不知道那是什么，不用担心） ，然后将其链接到了一个可执行文件中。如果你是C/C++程序员，那对你来说可能是有意义的，否则你可以忽略它。\n构建过程中也进行链接吗？ 没错，Pony不需要额外的构建程序（例如make），自己能处理（包括在链接到C库时处理依赖项的顺序，后面章节会介绍）。\n运行程序 运行程序：\n$ ./helloworld Hello, world! 恭喜你，完成了第一个Pony程序！下节我们讲解代码的含义。","title":"Hello World","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/hello-world.html"},{"content":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.   do loop statement, or after a with statement   else conditional statement in if, for, while, repeat, try (as a catch block), match   elseif conditional statement, also used with ifdef   embed embed a class as a field of another class   end ending of: if then, ifdef, while do, for in, repeat until, try, object, lambda, recover, match   error raises an error   for loop statement   fun define a function, executed synchronously   if (1) conditional statement    (2) to define a guard in a pattern match   ifdef when defining a build flag at compile time: ponyc –D “foo”   in used in a for in - loop statement   interface used in structural subtyping   is (1) used in nominal subtyping    (2) in type aliasing    (3) identity comparison   isnt negative identity comparison   iso reference capability – read and write uniqueness   lambda to make a closure   let declaration of immutable variable: you can’t rebind this name to a new value   match pattern matching   new constructor   not logical negation   object to make an object literal   primitive declares a primitive type   recover removes the reference capability of a variable   ref reference capability – object (on which function is called) is mutable   repeat loop statement   return to return early from a function   tag reference capability – neither readable nor writeable, only object identity   then (1) in if conditional statement    (2) as a (finally) block in try   this the current object   trait used in nominal subtyping: class Foo is TraitName   trn reference capability – write uniqueness, no other actor can write to the object   try error handling   type to declare a type alias   until loop statement   use (1) using a package    (2) using an external library foo: use “lib:foo”    (3) declaration of an FFI signature    (4) add a search path for external libraries: use “path:/usr/local/lib”   var declaration of mutable variable: you can rebind this name to a new value   val reference capability – globally immutable object   where when specifying named arguments   while loop statement   with ensure disposal of an object    ","summary":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.","title":"Keywords","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/keywords.html"},{"content":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.\nCompatible type: Two types are compatible if there can be any single object which is an instance of both types. Note that a suitable type for the single object does not have to have been defined, as long as it could be. For example, any two traits are compatible because a class could be defined that provides both of them, even if such a class has not been defined. Conversely, no two classes can ever be compatible because no object can be an instance of both.\nCompound type: A type combining multiple other types, ie union, intersection, and tuple. Opposite of a single type.\nConcrete type: An actor, class or primitive.\nCurly brackets: { }. Synonymous with braces.\nDeclaration and definition: synonyms for each other, we do not draw the C distinction between forward declarations and full definitions.\nDefault method body: Method body defined in a trait and optionally used by concrete types.\nEntity: Top level definition within a file, ie alias, trait, actor, class, primitive.\nExplicit type: An actor, class or primitive.\nMember: Method or field.\nMethod: Something callable on a concrete type/object. Function, behaviour or constructor.\nOverride: When a concrete type has its own body for a method with a default body provided by a trait.\nParentheses: ( ). Synonymous with round brackets.\nProvide: An entity’s usage of traits and the methods they contain. Equivalent to implements or inherits from.\nRound brackets: ( ). Synonymous with parentheses.\nSingle type: Any type which is not defined as a collection of other types. Actors, classes, primitives, traits and structural types are all single types. Opposite of a compound type.\nSquare brackets: [ ]\nTrait clash: A trait clashes with another type if it contains a method with the same name, but incompatible signature as a method in the other type. A clashing trait is incompatible with the other type. Traits can clash with actors, classes, primitives, intersections, structural types and other traits.\n","summary":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.","title":"Lexicon","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/lexicon.html"},{"content":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified. This is particularly useful when the library has slightly different names on different platforms.\nHere’s a real example from the standard library:\nuse \"path:/usr/local/opt/libressl/lib\" if osx use \"lib:ssl\" if not windows use \"lib:crypto\" if not windows use \"lib:libssl-32\" if windows use \"lib:libcrypto-32\" if windows primitive _SSLInit \"\"\" This initialises SSL when the program begins. \"\"\" fun _init() =\u003e @SSL_load_error_strings[None]() @SSL_library_init[I32]() On Windows, we use the libraries “libssl-32” and “libcrypto-32” and on other platforms we use “ssl” and “crypto”. These contain the FFI functions SSL_library_init and SSL_load_error_strings (amongst others).\nBy default the Pony compiler will look for the libraries to link in the standard places, however, that is defined on the build platform. However, it may be necessary to look in extra places. The use \"path:...\" command allows this. The specified path is added to the library search paths for the remainder of the current file. The example above uses this to add the path “/usr/local/opt/libressl/lib” for OSX. This is required because the library is provided by brew, which installs things outside the standard library search paths.\nIf you are integrating with existing libraries, that is all you need to do.\n","summary":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified.","title":"Linking to C Libraries","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/linking-c.html"},{"content":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory). You can have millions of actors at the same time.  But Caveat Emptor But Pony can be used to create C libraries and Pony can use external C libraries via the FFI which does not have this luxury.\nSo you can use any external C library out there, but the question is if you need to and if you should.\nThe biggest problem is external heap memory, created by an external FFI call, or created to support an external call. But external stack space might also need some thoughts, esp. when being created from actors.\nPony does have finalisers (callbacks which are called by the garbage collector which may be used to free resources allocated by an FFI call); However, the garbage collector is not timely (as with pure reference counting), it is not triggered immediately when some object goes out of scope.\nA blocked actor will keep its memory allocated, only a dead actor will release it eventually.\nAnd, long-running actors Might cause unexpected out of memory errors, since the GC is not yet triggered on an out-of-memory segfault or stack exhaustion.\n…\n","summary":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory).","title":"Memory Allocation at Runtime","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/memory-allocation.html"},{"content":"引用权能使得在参与者之间可以安全地传递可变数据，在参与者之间可以安全地共享不变数据。不仅如此，它们还可以安全地进行操作，不需要复制，不需要锁，实际上，根本不需要运行时开销。\nPassing 对于要可变的对象，我们需要确保没有 other actor可以从该对象读写。三种可变引用权能(iso、trn和ref)都保证了这一点。\n但是如果我们想要将一个可变对象从一个参与者传递给另一个参与者呢?为此，我们需要确保正在_sending_可变对象的actor也_give up_从该对象读写的权能。\n这正是iso所做的。它是读写唯一的，一次只能有一个可用于读写的引用。如果您将一个iso对象发送给另一个参与者，您将放弃从该对象读写的权能。\n那么当我想要在actor之间传递一个可变对象时，我应该使用iso吗?__是的!如果你不需要传递它，你可以使用ref代替。\nSharing 如果你想在参与者之间共享一个对象，那么我们必须做出如下保证:\n no actor可以写对象，在这种情况下_any_ actor可以从对象中读取，或者 只有_one_ actor可以对对象进行写操作，在这种情况下_other_ actor既不能对对象进行读操作，也不能对对象进行写操作。  第一个保证就是val所做的。它是全局的immutable_，所以我们知道_no_actor可以写那个对象。因此，您可以自由地将val对象发送给其他参与者，而不需要放弃从该对象读取数据的权能。\n那么当我想要在参与者之间共享一个不可变的对象时，我应该使用val吗?__是的!如果你不需要共享它，你可以使用ref代替，或box如果你想它是不可变的。\n第二个保证是tag的权能。不是关于只写一个参与者的部分(这是由任何可变引用权能保证的)，而是关于不能读写对象的部分。这意味着您可以自由地将tag对象传递给其他参与者，而不需要放弃从该对象读写的权能。\n如果另一个参与者不能读写字段，那么将tag引用发送给另一个参与者又有什么意义呢?因为tag可以被用来识别目标，有时这就是你所需要的。另外，如果对象是一个参与者，即使您只有一个tag，您也可以对其调用行为。\n那么当我想要在actor之间共享可变对象的身份时，我应该使用tag吗?__是的!或者，实际上，任何东西的恒等式，不管是可变的，不可变的，甚至是一个行动者。\n无法发送的引用权能 你可能已经注意到我们并没有提到trn，ref，或者box作为你可以发送给其他演员的东西。那是因为你做不到。他们不会为了安全而做出我们需要的保证。\n那么什么时候应该使用这些引用权能呢?\n*当你需要能够随着时间改变一个对象时，使用ref。另一方面，如果您的程序在使用不可变类型时不会变得更慢，那么您可能希望使用val。 *当你不关心对象是可变的还是不可变的时候，使用box。换句话说，你想要能够阅读它，但你不需要给它写信或与其他演员分享它。 *当你想要改变一个对象一段时间，但你也想让它 全局不可变（global immutable） 以后使用trn。\n","summary":"引用权能使得在参与者之间可以安全地传递可变数据，在参与者之间可以安全地共享不变数据。不仅如此，它们还可以安全地进行操作，不需要复制，不需要锁，实际上，根本不需要运行时开销。\nPassing 对于要可变的对象，我们需要确保没有 other actor可以从该对象读写。三种可变引用权能(iso、trn和ref)都保证了这一点。\n但是如果我们想要将一个可变对象从一个参与者传递给另一个参与者呢?为此，我们需要确保正在_sending_可变对象的actor也_give up_从该对象读写的权能。\n这正是iso所做的。它是读写唯一的，一次只能有一个可用于读写的引用。如果您将一个iso对象发送给另一个参与者，您将放弃从该对象读写的权能。\n那么当我想要在actor之间传递一个可变对象时，我应该使用iso吗?__是的!如果你不需要传递它，你可以使用ref代替。\nSharing 如果你想在参与者之间共享一个对象，那么我们必须做出如下保证:\n no actor可以写对象，在这种情况下_any_ actor可以从对象中读取，或者 只有_one_ actor可以对对象进行写操作，在这种情况下_other_ actor既不能对对象进行读操作，也不能对对象进行写操作。  第一个保证就是val所做的。它是全局的immutable_，所以我们知道_no_actor可以写那个对象。因此，您可以自由地将val对象发送给其他参与者，而不需要放弃从该对象读取数据的权能。\n那么当我想要在参与者之间共享一个不可变的对象时，我应该使用val吗?__是的!如果你不需要共享它，你可以使用ref代替，或box如果你想它是不可变的。\n第二个保证是tag的权能。不是关于只写一个参与者的部分(这是由任何可变引用权能保证的)，而是关于不能读写对象的部分。这意味着您可以自由地将tag对象传递给其他参与者，而不需要放弃从该对象读写的权能。\n如果另一个参与者不能读写字段，那么将tag引用发送给另一个参与者又有什么意义呢?因为tag可以被用来识别目标，有时这就是你所需要的。另外，如果对象是一个参与者，即使您只有一个tag，您也可以对其调用行为。\n那么当我想要在actor之间共享可变对象的身份时，我应该使用tag吗?__是的!或者，实际上，任何东西的恒等式，不管是可变的，不可变的，甚至是一个行动者。\n无法发送的引用权能 你可能已经注意到我们并没有提到trn，ref，或者box作为你可以发送给其他演员的东西。那是因为你做不到。他们不会为了安全而做出我们需要的保证。\n那么什么时候应该使用这些引用权能呢?\n*当你需要能够随着时间改变一个对象时，使用ref。另一方面，如果您的程序在使用不可变类型时不会变得更慢，那么您可能希望使用val。 *当你不关心对象是可变的还是不可变的时候，使用box。换句话说，你想要能够阅读它，但你不需要给它写信或与其他演员分享它。 *当你想要改变一个对象一段时间，但你也想让它 全局不可变（global immutable） 以后使用trn。","title":"Passing and Sharing References","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html"},{"content":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug\nThey can also use the operators and, or, xor and not. As with other expressions in Pony, parentheses must be used to indicate precedence if more than one of and, or and xor is used.\nAny use command whose condition evaluates to false is ignored.\n","summary":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug","title":"Platform-dependent code","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/platform-dependent-code.html"},{"content":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running). For example, if using bash, add the following to your ~/.bashrc:\nexport PONYPATH=$PONYPATH:$HOME/pony (Then run source ~/.bashrc to add this variable to a running session. New terminal session will automatically source ~/.bashrc.)\nWindows  Create folder at C:\\Users\\\u003cyourusername\u003e\\pony. Right click on “Start” and click on “Control Panel”. Select “System and Security”, then click on “System”. From the menu on the left, select the “Advanced systems settings”. Click the “Environment Variables” button at the bottom. Click “New” from the “User variables” section. Type PONYPATH into the “Variable name” field. Type %PONYPATH%;%USERPROFILE%\\pony into the “Variable value” field. Click OK.  You can also add to PONYPATH from the command prompt via:\nsetx PONYPATH %PONYPATH%;%USERPROFILE%\\pony ","summary":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running).","title":"PONYPATH","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/ponypath.html"},{"content":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:\n actor class struct primitive trait interface new fun be if (only as a condition, not as a guard) ifdef elseif else while repeat until for match | (only as a case in a match expression) recover object { (only as a lambda) with try then (only when part of a try block)  The effect of annotations Annotations are entirely implementation-specific. In other words, the Pony compiler (or any other tool that processes Pony programs) is free to take any action for any annotation that it encounters, including not doing anything at all. Annotations starting with ponyint are reserved by the compiler for internal use and shouldn’t be used by external tools.\nAnnotations in the Pony compiler The following annotations are recognised by the Pony compiler. Note that the Pony compiler will ignore annotations that it doesn’t recognise, as well as the annotations described here if they’re encountered in an unexpected place.\npacked Recognised on a a struct declaration. Removes padding in the associated struct, making it ABI-compatible with a packed C structure with compatible members (declared with the __attribute__((packed)) extension or the #pragma pack preprocessor directive in many C compilers).\nstruct \\packed\\ MyPackedStruct var x: U8 var y: U32 likely and unlikely Recognised on a conditional expression (if, while, until and | (as a pattern matching case)). Gives optimisation hints to the compiler on the likelihood of a given conditional expression.\nif \\likely\\ cond then foo end while \\unlikely\\ cond then bar end repeat baz until \\likely\\ cond end match obj | \\likely\\ expr =\u003e foo | \\unlikely\\ let capt: T =\u003e bar end ","summary":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:","title":"Program Annotations","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/annotations.html"},{"content":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows. Most recursive functions can be easily transformed into tail-recursive function which are less problematic. A tail-recursive function is a function in which the recursive call is the last instruction of the function. Here is an example with a factorial function:\nfun recursive_factorial(x: U32): U32 =\u003e if x == 0 then 1 else x * recursive_factorial(x - 1) end fun tail_recursive_factorial(x: U32, y: U32): U32 =\u003e if x == 0 then y else tail_recursive_factorial(x - 1, x * y) end The compiler can optimise a tail-recursive function to a loop, completely avoiding call stack growth. Note that this is an optimisation which is only performed in release builds (i.e. builds without the -d flag passed to ponyc.) If you need to avoid stack growth in debug builds as well then you have to write your function as a loop manually.\nIf the tail-recursive version of your algorithm isn’t practical to implement, there are other ways to control stack growth depending on your algorithm. For example, you can implement your algorithm using an explicit stack data structure instead of implicitly using the call stack to store data.\nNote that light recursion usually doesn’t cause problems. Unless your amount of recursive calls is in the hundreds, you’re unlikely to encounter this problem.\n","summary":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows.","title":"Recursion","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/recursion.html"},{"content":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time. You do not want to do this. Do not call FFI code that doesn’t return in a reasonable amount of time.\nLong running behaviors Another way to monopolize a scheduler thread is to write a behavior that never exits or takes a really long time to exit.\nbe bad_citizen() =\u003e while true do _env.out.print(\"Never gonna give you up. Really gonna make you cry\") end That is some seriously bad citizen code that will hog a scheduler thread forever. Call that behavior a few times and your program will grind to a halt. If you find yourself writing code with loops that will run for a long time, stop and rethink your design. Take a look at the Timer class from the standard library. Combine that together with a counter in your class and you can execute the same behavior repeatedly while yielding your scheduler thread to other actors.\n","summary":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time.","title":"Scheduling","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/scheduling.html"},{"content":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object. A Serialised object can be created in one of two ways:\n calling the create(...) constructor with the SerialiseAuth authority and the object to serialize calling the input(...) constructor with the DeserialiseAuth authority and an Array[U8] that represents the object to deserialise This intermediate object can then be used to either: generate an Array[U8] that represents the object by calling the output(...) method with the OutputSerialisedAuth authority generate a deserialised object by calling the apply(...) method with the InputSerialisedAuth authority  This program serialises and deserialise an object, and checks that the fields of the original object are the same as the fields of the deserialised object.\nuse \"serialise\" class Foo is Equatable[Foo box] let _s: String let _u: U32 new create(s: String, u: U32) =\u003e _s = s _u = u fun eq(foo: Foo box): Bool =\u003e (_s == foo._s) and (_u == foo._u) actor Main new create(env: Env) =\u003e try let ambient = env.root as AmbientAuth // get serialization authorities let serialise = SerialiseAuth(ambient) let output = OutputSerialisedAuth(ambient) let deserialise = DeserialiseAuth(ambient) let input = InputSerialisedAuth(ambient) let foo1 = Foo(\"abc\", 123) // serialisation let sfoo = Serialised(serialise, foo1)? let bytes_foo: Array[U8] val = sfoo.output(output) env.out.print(\"serialised representation is \" + bytes_foo.size().string() + \" bytes long\") // deserialisation let dfoo = Serialised.input(input, bytes_foo) let foo2 = dfoo(deserialise)? as Foo env.out.print(\"(foo1 == foo2) is \" + (foo1 == foo2).string()) else env.err.print(\"there was an error\") end Caveats There are several things to keep in mind when using Pony’s serialisation system:\n Serialised objects will currently only work when passed between two running instances of the same Pony executable. You cannot pass objects between different Pony programs, nor can you pass them between different versions of the same program. Objects with embed fields will not be properly serialised. Objects with Pointer fields must use the custom serialisation mechanism or else the Pointer fields will be null when the object is deserialised. For information on how to handle these kinds of fields, please see the discussion of custom serialisation and deserialisation below.  Custom Serialisation and Deserialisation Pony objects can have Pointer fields that store pointers to memory that contains things that are opaque to Pony but that may be useful to code that is called via FFI. Because the objects that Pointer fields point to are opaque, Pony cannot serialise and deserialise them by itself. However, Pony’s serialisation system provides a way for the programmer to specify how the objects pointed to by these fields should be serialised and deserialised. This system is called custom serialisation.\nSince Pointer fields are opaque to Pony, it is assumed that the serialisation and deserialisation code will be written in another language that knows how to read the object referenced by the pointers.\nCustom Serialisation In order to serialise an object from a pointer field, Pony needs to know how much space to set aside for that object and how to write a representation of that object into the reserved space. The programmer must provide two methods on the object:\n fun _serialise_space(): USize – This method returns the number of bytes that must be reserved for the object. fun _serialise(bytes: Pointer[U8] tag) – This method receives a pointer to the memory that has been set aside for serialising the object. The programmer must not write more bytes than were returned by the _serialise_space method.  Custom Deserialisation Custom deserialisation is handled by a fun ref _deserialise(bytes: Pointer[U8] tag) method. This method receives a pointer to the character array that stores the serialised representation of the object (or objects) that the Pointer fields should point to. The programmer must copy out any bytes that will be used by the deserialised object.\nThe custom deserialization method is expected to modify the values of the objects Pointer fields, so the fields must be declared var so that they can be modified.\nConsiderations Fixed Versus Variable Object Sizes The programmer must write their custom serialisation and deserialisation code in such a way that it is aware of how many bytes are available in the byte arrays that are passed to the methods. If the objects are always of a fixed size then the functions can read and write than many bytes to the buffer. However, if the objects are of varying sizes (for example, if the object was a string), then the serialized representation must include information that the deserialisation code can use to ensure that it does not read beyond the end of the memory occupied by the object. The custom serialisation system does not provide a mechanism for doing this, so it is up to the program to choose a mechanism and implement it. In the case of a string, the serialisation format could consist of a 4-byte header that encodes the length of the string, followed by a string of the specified length. This additional four bytes must be included in the value returned by _serialise_space(). The deserialisation function would then start by reading the first four bytes of the array to obtain the size of the string and then read only that many bytes from the array.\nClasses With Multiple Pointer Fields If a class has more than one Pointer field then all of those fields must be handled by the custom serialisation and deserialisation methods for that class; there are not methods for each field. For example, if a class has three Pointer fields then the _serialise_space() method must return the total number of bytes required to serialise the objects from all three fields.\nExample Assume we have a Pony class with a field that is a pointer to a C string. We would like to be able to serialise and deserialise this object. In order to do that, the Pony class implements the methods _serialise_space(...), _serialise(...), and _deserialise(...). These methods, in turn, call C functions that calculate the number of bytes needed to serialise the string and serialise and deserialise it. In this example the serialised string is represented by a four-byte big-endian number that represents the length of the string, followed by the string itself without the terminating null. So if the C string is hello world\\0 then the serialised string is \\0x00\\0x00\\0x00\\0x0Bhello world (where the first four bytes of the serialised string are a big-endian representation of the number 0x0000000B, which is 11).\nuse \"serialise\" use \"lib:custser\" class CStringWrapper var _cstr: Pointer[U8] tag new create(cstr: Pointer[U8] tag) =\u003e _cstr = cstr fun _serialise_space(): USize =\u003e @serialise_space[USize](_cstr) fun _serialise(bytes: Pointer[U8] tag) =\u003e @serialise[None](bytes, _cstr) fun ref _deserialise(bytes: Pointer[U8] tag) =\u003e _cstr = @deserialise[Pointer[U8] tag](bytes) fun print() =\u003e @printf[I32](_cstr) actor Main new create(env: Env) =\u003e let csw = CStringWrapper(@get_string[Pointer[U8]]()) csw.print() try let ambient = env.root as AmbientAuth let serialise = SerialiseAuth(ambient) let deserialise = DeserialiseAuth(ambient) let sx = Serialised(serialise, csw)? let y = sx(deserialise)? as CStringWrapper y.print() else env.err.print(\"there was an error\") end // custser.c  #include \u003cstdlib.h\u003e#include \u003cstring.h\u003e extern char *get_string() { return \"hello world\\n\"; } extern size_t serialise_space(char *s) { // space for the size and the string (without the null)  return 4 + strlen(s); } extern void serialise(char *buff, char *s) { size_t sz = strlen(s); unsigned char *ubuff = (unsigned char *) buff; // write the size as a 32-bit big-endian integer  ubuff[0] = (sz \u003e\u003e 24) \u0026 0xFF; ubuff[1] = (sz \u003e\u003e 16) \u0026 0xFF; ubuff[2] = (sz \u003e\u003e 8) \u0026 0xFF; ubuff[3] = sz \u0026 0xFF; // copy the string  strncpy(buff + 4, s, sz); } extern char *deserialise(char *buff) { unsigned char *ubuff = (unsigned char *) buff; size_t sz = (ubuff[0] \u003c\u003c 24) + (ubuff[1] \u003c\u003c 16) + (ubuff[2] \u003c\u003c 8) + ubuff[3]; char *s = malloc(sizeof(char) * sz + 1); memcpy(s, buff + 4, sz); s[sz] = '\\0'; return s; } ","summary":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object.","title":"Serialisation","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/serialisation.html"},{"content":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .\u003e Chaining   ^ Ephemeral   @ FFI   \u0026 Intersection   =\u003e Match arrow   ~ Partial application   ? Partial function   ' Prime   \u003c: Subtype    Here is a more elaborate explanation of Pony’s use of special characters: (a line with (2) or (3) means an alternate usage of the symbol of the previous line)\n   Symbol Usage     , to separate parameters in a function signature, or the items of a tuple   . (1) to call a field or a function on a variable (field access or method call)    (2) to qualify a type/method with its package name   .\u003e to call a method on an object and return the receiver (chaining)   ' used as alternative name in parameters (prime)   \" to delineate a literal string   \"\"\" to delineate a documentation string   ( (1) start of line: start of a tuple    (2) middle of line: method call   () (1) parentheses, for function or behavior parameters    (2) making a tuple (values separated by ,)    (3) making an enumeration (values separated by |)   [ (1) start of line: start of an array literal    (2) middle of line: generic formal parameters   [] (1) to indicate a generic type, for example Range[U64]    (2) to indicate the return type of an FFI function call   {} a function type   : (1) after a variable: is followed by the type name    (2) to indicate a function return type    (3) a type constraint   ; only used to separate expressions on the same line   = (1) (destructive) assignment    (2) in: use alias = packname    (3) supply default argument for method    (4) supply default type for generics   ! (1) boolean negation    (2) a type that is an alias of another type   ? (1) partial functions    (2) a call to a C function that could raise an error   - (1) start of line: unary negation    (2) middle of line: subtraction   _ (1) to indicate a private variable, constructor, function, behavior    (2) to ignore a tuple item in a pattern match   ~ partial application   ^ an ephemeral type   | (1) separates the types in an enumeration (the value can be any of these types)    (2) starts a branch in a match   \u0026 (1) separates the types in a complex type (the value is of all of these types)    (2) intersection   @ FFI call   // comments   /* */ multi-line or block comments   =\u003e (1) start of a function body    (2) starts the code of a matching branch   -\u003e (1) arrow type    (2) viewpoint   ._i where i = 1,2,… means the ith item of a tuple   \u003c: “is a subtype of” or “can be substituted for”    ","summary":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .","title":"Symbol Lookup Cheatsheet","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/symbol-lookup-cheatsheet.html"},{"content":"","summary":"","title":"Tags","uri":"https://damon-kwok.github.io/pony-tutorial/tags.html"},{"content":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.\nWhen any assertion function fails the test is counted as a fail. However, tests can also indicate failure by raising an error in the test function.\nExample program To use PonyTest simply write a class for each test and a TestList type that tells the PonyTest object about the tests. Typically the TestList will be Main for the package.\nThe following is a complete program with 2 trivial tests.\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAdd) test(_TestSub) class iso _TestAdd is UnitTest fun name(): String =\u003e \"addition\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](4, 2 + 2) class iso _TestSub is UnitTest fun name(): String =\u003e \"subtraction\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](2, 4 - 2) The make() constructor is not needed for this example. However, it allows for easy aggregation of tests (see below) so it is recommended that all test Mains provide it.\nMain.create() is called only for program invocations on the current package. Main.make() is called during aggregation. If so desired extra code can be added to either of these constructors to perform additional tasks.\nTest names Tests are identified by names, which are used when printing test results and on the command line to select which tests to run. These names are independent of the names of the test classes in the Pony source code.\nArbitrary strings can be used for these names, but for large projects, it is strongly recommended to use a hierarchical naming scheme to make it easier to select groups of tests.\nAggregation Often it is desirable to run a collection of unit tests from multiple different source files. For example, if several packages within a bundle each have their own unit tests it may be useful to run all tests for the bundle together.\nThis can be achieved by writing an aggregate test list class, which calls the list function for each package. The following is an example that aggregates the tests from packages foo and bar.\nuse \"ponytest\" use foo = \"foo\" use bar = \"bar\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e foo.Main.make().tests(test) bar.Main.make().tests(test) Aggregate test classes may themselves be aggregated. Every test list class may contain any combination of its own tests and aggregated lists.\nLong tests Simple tests run within a single function. When that function exits, either returning or raising an error, the test is complete. This is not viable for tests that need to use actors.\nLong tests allow for delayed completion. Any test can call long_test() on its TestHelper to indicate that it needs to keep running. When the test is finally complete it calls complete() on its TestHelper.\nThe complete() function takes a Bool parameter to specify whether the test was a success. If any asserts fail then the test will be considered a failure regardless of the value of this parameter. However, complete() must still be called.\nSince failing tests may hang, a timeout must be specified for each long test. When the test function exits a timer is started with the specified timeout. If this timer fires before complete() is called the test is marked as a failure and the timeout is reported.\nOn a timeout, the timed_out() function is called on the unit test object. This should perform whatever test specific tidy up is required to allow the program to exit. There is no need to call complete() if a timeout occurs, although it is not an error to do so.\nNote that the timeout is only relevant when a test hangs and would otherwise prevent the test program from completing. Setting a very long timeout on tests that should not be able to hang is perfectly acceptable and will not make the test take any longer if successful.\nTimeouts should not be used as the standard method of detecting if a test has failed.\nExclusion groups By default, all tests are run concurrently. This may be a problem for some tests, eg if they manipulate an external file or use a system resource. To fix this issue any number of tests may be put into an exclusion group.\nNo tests that are in the same exclusion group will be run concurrently.\nExclusion groups are identified by name, arbitrary strings may be used. Multiple exclusion groups may be used and tests in different groups may run concurrently. Tests that do not specify an exclusion group may be run concurrently with any other tests.\nThe command line option “–sequential” prevents any tests from running concurrently, regardless of exclusion groups. This is intended for debugging rather than standard use.\nTear down Each unit test object may define a tear_down() function. This is called after the test has finished allowing the tearing down of any complex environment that had to be set up for the test.\nThe tear_down() function is called for each test regardless of whether it passed or failed. If a test times out tear_down() will be called after timed_out() returns.\nWhen a test is in an exclusion group, the tear_down() call is considered part of the tests run. The next test in the exclusion group will not start until after tear_down() returns on the current test.\nThe test’s TestHelper is handed to tear_down() and it is permitted to log messages and call assert functions during tear down.\nAdditional resources You can learn more about PonyTest specifics by checking out the API documentation. There’s also a testing section in the Pony Patterns book.\n","summary":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.","title":"Testing with Ponytest","uri":"https://damon-kwok.github.io/pony-tutorial/testing/ponytest.html"},{"content":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction). A ( at the beginning of a line starts a new expression (a tuple), whereas a ( in the middle of an expression is a method call. A [ at the beginning of a line starts a new expression (an array literal), whereas a [ in the middle of an expression is generic formal parameters.  That stuff may seem a little esoteric right now, but we’ll explain it all later. The - part should make sense though.\na - b That means “subtract b from a”.\na -b That means “first do a, then, in a new expression, do a unary negation of b”.\nSemicolons In Pony, you don’t end an expression with a ;, unlike C, C++, Java, C#, etc. In fact, you don’t need to end it at all! The compiler knows when an expression has finished, like Python or Ruby.\nHowever, sometimes it’s convenient to put more than one expression on the same line. When you want to do that, you must separate them with a ;.\nWhy? Can’t the compiler tell an expression has finished? Yes, it can. The compiler doesn’t really need the ;. However, it turns out the programmer does! By requiring a ; between expressions on the same line, the compiler can catch some pretty common syntax errors for you.\nDocstrings Including documentation in your code makes you awesome. If you do it, everyone will love you.\nPony makes it easy by allowing you to put a docstring on every type, field, or method. Just put a string literal right after declaring the type or field, or right after the =\u003e of a method, before writing the body. The compiler will know what to do with them.\nFor traits and interfaces that have methods without bodies, you can put the docstring after the method declaration, even though there is no =\u003e.\nBy convention, a docstring should be a triple-quoted string, and it should use Markdown for any formatting.\nactor Main \"\"\" This is documentation for my Main actor \"\"\" var count: USize = 0 \"\"\" This is documentation for my count field \"\"\" new create(env: Env) =\u003e \"\"\" This is documentation for my create method \"\"\" None trait Readable fun val read() \"\"\" This is documentation for my unimplemented read method \"\"\" Comments Use docstrings first! But if you need to put some comments in the implementation of your methods, perhaps to explain what’s happening on various lines, you can use C++ style comments. In Pony, block comments can be nested.\n// This is a line comment. /* This is a block comment. */ /* This block comment /* has another block comment */ inside of it. */ ","summary":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction).","title":"Whitespace","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/whitespace.html"},{"content":"你需要一个文本编辑器，还有Pony编译器。如果想偷点懒可以直接使用Pony的Playground。\nPony编译器 Pony编译器的：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，非解释型语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以直接运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整程序。\n所以你必须先构建程序，才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python3)，然后使用chmod添加运行权限，然后运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接输入ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果代码在其他目录里，把目录作为参数传入就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，后面会介绍。\n","summary":"你需要一个文本编辑器，还有Pony编译器。如果想偷点懒可以直接使用Pony的Playground。\nPony编译器 Pony编译器的：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，非解释型语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以直接运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整程序。\n所以你必须先构建程序，才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python3)，然后使用chmod添加运行权限，然后运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接输入ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果代码在其他目录里，把目录作为参数传入就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，后面会介绍。","title":"准备工作（What You Need）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/what-you-need.html"},{"content":"__别名（Aliasing）__意味着在同一行为人内对同一对象有多个引用。这可以是变量或字段的情况。\n在大多数编程语言中，别名非常简单。你只需要把一个变量赋值给另一个变量，就得到了一个别名。赋值给的变量与赋值给它的变量具有相同的类型(或某些超类型)，一切正常。\n在Pony中，这适用于一些引用权能，但不是全部。\n别名和拒绝保证（Aliasing and deny guarantees） 这样做的原因是iso引用权能拒绝了指向相同对象的其他iso变量。也就是说，你只能有一个iso变量指向任何给定的对象。trn也是一样。\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = a // Not allowed! 这里我们有一些函数传递给一个孤立的袋熊。如果我们试图通过将a赋值给b来别名a，我们将破坏引用权能保证，因此编译器将阻止我们。\n我可以将iso别名为什么?由于iso表示任何其他变量都不能被_any_ actor用来读写该对象，所以我们只能为既不能读也不能写的iso创建别名。幸运的是，我们有一个引用权能:’ tag ‘。所以我们可以这样做，编译器会很高兴:\nfun test(a: Wombat iso) =\u003e var b: Wombat tag = a // Allowed! 那混叠trn呢?因为‘trn’表示任何其他变量都不能被_any_ actor用来写入该对象，所以我们需要一些不允许写入但也不阻止‘trn’变量写入的东西。幸运的是，我们还有一个引用权能可以做到这一点:box。所以我们可以这样做，编译器会很高兴:\nfun test(a: Wombat trn) =\u003e var b: Wombat box = a // Allowed! 那混叠其他东西呢?对于iso和trn，保证要求别名必须放弃某些权能(iso的读和写，trn的写)。对于其他功能(’ ref ‘、’ val ‘、’ box ‘和’ tag ‘)，别名允许相同的操作，所以这样的引用可以作为它自己的别名。\n什么算假名?（What counts as making an alias?） 有三件事可以算作别名:\n 当您将一个值赋值给一个变量或字段时。 当您将一个值作为参数传递给一个方法时。 当您调用一个method__时，调用的接收者的别名被创建。它可以在方法体中以this的形式访问。  在这三种情况下，都要为对象创建一个新的_name_。这可能是局部变量的名称、字段的名称或方法的参数的名称。\n短暂的类（Ephemeral types） 在小马，每个表情都有一个类型。那么消费a是什么类型的呢?它不是与‘a’相同的类型，因为可能无法别名‘a’。相反，它是一种短暂的类型。也就是说，它是当前没有名称的值的类型(它可能通过其他别名具有名称，但不是我们刚刚使用或销毁读取的名称)。\n要显示一个类型是短暂的，我们在末尾加上一个’ ^ ‘。例如:\nfun test(a: Wombat iso): Wombat iso^ =\u003e consume a 在这里，我们的函数接受一个隔离的袋熊作为参数，并返回一个临时隔离的袋熊。\n这对于处理iso和trn类型以及泛型类型很有用，但是对于构造函数也很重要。构造函数总是返回临时类型，因为它是一个新对象。\n类型别名（Alias types） 就像Pony有临时类型一样，它也有别名类型。别名类型是一种表示我们可以安全地将这个东西别名为的方式。只有在处理泛型类型时才需要它，稍后我们将对此进行讨论。\n我们通过输入'来指示别名类型!``最后。这里有一个例子:\nfun test(a: A) =\u003e var b: A! = a 在这里，我们使用A作为一个变量的类型，我们将在后面介绍。所以!的意思是任何类型的‘A’的别名`。\n","summary":"__别名（Aliasing）__意味着在同一行为人内对同一对象有多个引用。这可以是变量或字段的情况。\n在大多数编程语言中，别名非常简单。你只需要把一个变量赋值给另一个变量，就得到了一个别名。赋值给的变量与赋值给它的变量具有相同的类型(或某些超类型)，一切正常。\n在Pony中，这适用于一些引用权能，但不是全部。\n别名和拒绝保证（Aliasing and deny guarantees） 这样做的原因是iso引用权能拒绝了指向相同对象的其他iso变量。也就是说，你只能有一个iso变量指向任何给定的对象。trn也是一样。\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = a // Not allowed! 这里我们有一些函数传递给一个孤立的袋熊。如果我们试图通过将a赋值给b来别名a，我们将破坏引用权能保证，因此编译器将阻止我们。\n我可以将iso别名为什么?由于iso表示任何其他变量都不能被_any_ actor用来读写该对象，所以我们只能为既不能读也不能写的iso创建别名。幸运的是，我们有一个引用权能:’ tag ‘。所以我们可以这样做，编译器会很高兴:\nfun test(a: Wombat iso) =\u003e var b: Wombat tag = a // Allowed! 那混叠trn呢?因为‘trn’表示任何其他变量都不能被_any_ actor用来写入该对象，所以我们需要一些不允许写入但也不阻止‘trn’变量写入的东西。幸运的是，我们还有一个引用权能可以做到这一点:box。所以我们可以这样做，编译器会很高兴:\nfun test(a: Wombat trn) =\u003e var b: Wombat box = a // Allowed! 那混叠其他东西呢?对于iso和trn，保证要求别名必须放弃某些权能(iso的读和写，trn的写)。对于其他功能(’ ref ‘、’ val ‘、’ box ‘和’ tag ‘)，别名允许相同的操作，所以这样的引用可以作为它自己的别名。\n什么算假名?（What counts as making an alias?） 有三件事可以算作别名:","title":"别名（Aliasing）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/aliasing.html"},{"content":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.\nA package is usually split into several source files, although it does not have to be. This is purely a convenience to allow better code organisation and the compiler treats all the code within a package as if it were from a single file.\nThe package is the privacy boundary for types and methods. That is:\n Private types (those whose name starts with an underscore) can be used only within the package in which they are defined. Private methods (those whose name starts with an underscore) can be called only from code within the package in which they are defined.  It follows that all code within a package is assumed to know and trust, all the rest of the code in the package.\nThere is no such concept as a sub-package in Pony. For example, the packages “foo/bar” and “foo/bar/wombat” will, presumably, perform related tasks but they are two independent packages. Package “foo/bar” does not contain package “foo/bar/wombat” and neither has access to the private elements of the other.\n","summary":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.","title":"包机制（Package System）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/package-system.html"},{"content":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same. They come at the beginning of Pony files and look like this:\nuse \"collections\" This will find all of the publicly visible types defined in the collections package and add them to the type namespace of the file containing the use command. These types are then available to use within that file, just as if they were defined locally.\nFor example, the standard library contains the package time. This contains the following definition (among others):\nprimitive Time fun now(): (I64, I64) To access the now function just add a use command:\nuse \"time\" class Foo fun f() =\u003e (var secs, var nsecs) = Time.now() Use names As we saw above the use command adds all the public types from a package into the namespace of the using file. This means that using a package may define type names that you want to use for your own types. Furthermore, if you use two packages within a file they may both define the same type name, causing a clash in your namespace. For example:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use \"packageB\" class Bar var _x: Foo The declarations of _x is an error because we don’t know which Foo is being referred to. Actually using ‘Foo’ is not even required, simply using both packageA and packageB is enough to cause an error here.\nTo avoid this problem the use command allows you to specify an alias. If you do this then only that alias is put into your namespace. The types from the used package can then be accessed using this alias as a qualifier. Our example now becomes:\n// In package A class Foo // In package B class Foo // In your code use a = \"packageA\" use b = \"packageB\" class Bar var _x: a.Foo // The Foo from package A var _y: b.Foo // The Foo from package B If you prefer you can give an alias to only one of the packages. Foo will then still be added to your namespace referring to the unaliased package:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use b = \"packageB\" class Bar var _x: Foo // The Foo from package A var _y: b.Foo // The Foo from package B Can I just specify the full package path and forget about the use command, like I do in Java and C#? No, you can’t do that in Pony. You can’t refer to one package based on a use command for another package and you can’t use types from a package without a use command for that package. Every package that you want to use must have its own use command.\nAre there limits on the names I can use for an alias? Use alias names have to start with a lower case letter. Other than that you can use whatever name you want, as long as you’re not using that name for any other purpose in your file.\nScheme indicators The string we give to a use command is known as the specifier. This consists of a scheme indicator and a locator, separated by a colon. The scheme indicator tells the use command what we want it to do, for example, the scheme indicator for including a package is “package”. If no colon is found within the specifier string then the use command assumes you meant “package”.\nThe following two use commands are exactly equivalent:\nuse \"foo\" use \"package:foo\" If you are using a locator string that includes a colon, for example, an absolute path in Windows, then you have to include the “package” scheme specifier:\nuse \"C:/foo/bar\" // Error, scheme \"C\" is unknown use \"package:C:/foo/bar\" // OK To allow use commands to be portable across operating systems, and to avoid confusion with escape characters, ‘/’ should always be used as the path separator in use commands, even on Windows.\n","summary":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same.","title":"包的使用方式（Use Statement）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/use-statement.html"},{"content":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.0 =\u003e \"float\" | \"2\" =\u003e \"string\" else \"something else\" end If you’re used to functional languages this should be very familiar.\nFor those readers more familiar with the C and Java family of languages, think of this like a switch statement. But you can switch on values other than just integers, like Strings. In fact, you can switch on any type that provides a comparison function, including your own classes. And you can also switch on the runtime type of an expression.\nA match starts with the keyword match, followed by the expression to match, which is known as the match operand. In this example, the operand is just the variable x, but it can be any expression.\nMost of the match expression consists of a series of cases that we match against. Each case consists of a pipe symbol (‘|’), the pattern to match against, an arrow (‘=\u003e’) and the expression to evaluate if the case matches.\nWe go through the cases one by one until we find one that matches. (Actually, in practice the compiler is a lot more intelligent than that and uses a combination of sequential checks and jump tables to be as efficient as possible.)\nNote that each match case has an expression to evaluate and these are all independent. There is no “fall through” between cases as there is in languages such as C.\nIf the value produced by the match expression isn’t used then the cases can omit the arrow and expression to evaluate. This can be useful for excluding specific cases before a more general case.\nElse cases As with all Pony control structures, the else case for a match expression is used if we have no other value, i.e. if none of our cases match. The else case, if there is one, must come at the end of the match, after all of the specific cases.\nIf the value the match expression results in is used then you need to have an else case, except in cases where the compiler recognizes that the match is exhaustive and that the else case can never actually be reached. If you omit it a default will be added which evaluates to None.\nThe compiler recognizes a match as exhaustive when the union of the types for all patterns that match on type alone is a supertype of the matched expression type. In other words, when your cases cover all possible types for the matched expression, the compiler will not add an implicit else None to your match statement.\nMatching on values The simplest match expression just matches on value.\nfun f(x: U32): String =\u003e match x | 1 =\u003e \"one\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | 5 =\u003e \"not four\" else \"something else\" end For value matching the pattern is simply the value we want to match to, just like a C switch statement. The case with the same value as the operand wins and we use its expression.\nThe compiler calls the eq() function on the operand, passing the pattern as the argument. This means that you can use your own types as match operands and patterns, as long as you define an eq() function.\nclass Foo var _x: U32 new create(x: U32) =\u003e _x = x fun eq(that: Foo): Bool =\u003e _x == that._x actor Main fun f(x: Foo): String =\u003e match x | Foo(1) =\u003e \"one\" | Foo(2) =\u003e \"two\" | Foo(3) =\u003e \"three\" | Foo(5) =\u003e \"not four\" else \"something else\" end Matching on type and value Matching on value is fine if the match operand and case patterns have all the same type. However, match can cope with multiple different types. Each case pattern is first checked to see if it is the same type as the runtime type of the operand. Only then will the values be compared.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | \"5\" =\u003e \"not four\" else \"something else\" end In many languages using runtime type information is very expensive and so it is generally avoided whenever possible.\nIn Pony it’s cheap. Really cheap. Pony’s “whole program” approach to compilation means the compiler can work out as much as possible at compile time. The runtime cost of each type check is generally a single pointer comparison. Plus of course, any checks which can be fully determined at compile time are. So for upcasts there’s no runtime cost at all.\nWhen are case patterns for value matching evaluated? Each case pattern expression that matches the type of the match operand, needs to be evaluated each time the match expression is evaluated until one case matches (further case patterns are ignored). This can lead to creating lots of objects unintentionally for the sole purpose of checking for equality. If case patterns actually only need to differentiate by type, Captures should be used instead, these boil down to simple type checks at runtime.\nAt first sight it is easy to confuse a value matching pattern for a type check. Consider the following example:\nclass Foo is Equatable[Foo] actor Main fun f(x: (Foo | None)): String =\u003e match x | Foo =\u003e \"foo\" | None =\u003e \"bar\" else \"\" end new create(env: Env) =\u003e f(Foo) Both case patterns actually do not check for the match operand x being an instance of Foo or None, but check for equality with the instance created by evaluating the case pattern (each time). None is a primitive and thus there is only one instance at all, in which case this value pattern kind of does the expected thing, but not quite. If None had a custom eq function that would not use identity equality, this could lead to surprising results.\nRemember to always use Captures if all you need is to differentiate by type. Only use value matching if you need a full blown equality check, be it for structural equality or identity equality.\nCaptures Sometimes you want to be able to match the type, for any value of that type. For this, you use a capture. This defines a local variable, valid only within the case, containing the value of the operand. If the operand is not of the specified type then the case doesn’t match.\nCaptures look just like variable declarations within the pattern. Like normal variables, they can be declared as var or let. If you’re not going to reassign them within the case expression it is good practice to use let.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | let u: U32 =\u003e \"other integer\" | let s: String =\u003e s end Can I omit the type from a capture, like I can from a local variable? Unfortunately no. Since we match on type and value the compiler has to know what type the pattern is, so it can’t be inferred.\nImplicit matching on capabilities in the context of union types In union types, when we pattern match on individual classes or traits, we also implicitly pattern match on the corresponding capabilities. In the example provided below, if _x has static type (A iso | B ref | None) and dynamically matches A, then we also know that it must be an A iso.\nclass A fun ref sendable() =\u003e None class B fun ref update() =\u003e None actor Main var _x: (A iso | B ref | None) new create(env: Env) =\u003e _x = None be f(a': A iso) =\u003e match (_x = None) // type of this expression: (A iso^ | B ref | None) | let a: A iso =\u003e f(consume a) | let b: B ref =\u003e b.update() end Note that using a match expression to differentiate solely based on capabilities at runtime is not possible, that is:\nclass A fun ref sendable() =\u003e None actor Main var _x: (A iso | A ref | None) new create(env: Env) =\u003e _x = None be f() =\u003e match (_x = None) | let a1: A iso =\u003e None | let a2: A ref =\u003e None end does not typecheck.\nMatching tuples If you want to match on more than one operand at once then you can simply use a tuple. Cases will only match if all the tuple elements match.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, let u: U32) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) =\u003e s + \" other integer\" else \"something else\" end Do I have to specify all the elements in a tuple? No, you don’t. Any tuple elements in a pattern can be marked as “don’t care” by using an underscore ('_'). The first and fourth cases in our example don’t actually care about the U32 element, so we can ignore it.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, _) =\u003e s + \" other integer\" else \"something else\" end Guards In addition to matching on types and values, each case in a match can also have a guard condition. This is simply an expression, evaluated after type and value matching has occurred, that must give the value true for the case to match. If the guard is false then the case doesn’t match and we move onto the next in the usual way.\nGuards are introduced with the if keyword (was where until 0.2.1).\nA guard expression may use any captured variables from that case, which allows for handling ranges and complex functions.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) if u \u003e 14 =\u003e s + \" other big integer\" | (let s: String, _) =\u003e s + \" other small integer\" else \"something else\" end ","summary":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.","title":"匹配表达式（Match Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/match.html"},{"content":"有时候，能够内联地写一个完整的对象是非常方便的。在Pony中，这被称为匿名对象，它做的事情和JavaScript中的匿名对象差不多：它可以生成一个可以立即使用的对象。\n但是Pony是静态类型的，所以一个匿名对象也会创建一个匿名类，这个匿名对象会满足这个匿名类。这类似于Java和C#中的匿名类。在Pony中，匿名类型可以提供任意数量的特征和接口。\n匿名类和匿名对象是什么？（What’s this look like, then?） 匿名类表达式与类（class）的定义基本相同，object表达式构建了一个匿名类并返回它的的实例，这个实例被称为匿名对象。匿名类和普通类有一些细微的区别，下面是一个简单的例子:\nobject fun apply(): String =\u003e \"hi\" end 很简单明了。让我们对其进行扩展，提供一个Hashable特征的实现，以便编译器能够确保匿名类型满足该接口。也可以用相同的方法来提供其他特征。\nobject is Hashable fun apply(): String =\u003e \"hi\" fun hash(): USize =\u003e this().hash() end 我们不能给匿名对象指定构造函数，因为它本身 就是 一个构造函数。那么我们如何分配字段呢？直接声明就行了。例如:\nuse \"collections\" class Foo fun foo(str: String): Hashable =\u003e object is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 在匿名对象所在的作用域中声明和初始化局部变量，等同于在类的构造函数中定义和初始化字段， 匿名类的所有的成员汉书都可以 捕获（capturing） 这些变量当做字段去实用。这非常有趣！它让我们有任意复杂的可以有多个入口点(例如，你可以在一个闭包上调用函数)的。\n默认情况下，带有字段的匿名对象将以ref（引用权能的一种权限类型）方式返回，除非你通过在object关键字后显示的指定一个引用权能的类型来声明权限。例如，一个带有sendable权限的对象可以在需要时可以声明为iso:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 我们还可以通过在匿名对象中使用词法作用域来隐式捕获值。有时，那些不是局部变量、不是字段、也不是函数参数的值被称为 free variables 。通过在函数中使用它们，我们将对它们进行覆盖——也就是捕获它们。上面的代码可以写没有字段s：\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable fun apply(): String =\u003e str fun hash(): USize =\u003e str.hash() end 闭包（Lambdas） 复杂的匿名对象很有用，但有时我们只想要一个简单的匿名函数。在Pony中，你可以使用闭包（lambdas）。lambda是一个一个函数(被隐式的命名为apply)，写在花括号{}当中:\n{(s: String): String =\u003e \"lambda: \" + s } 等同于：\nobject fun apply(s: String): String =\u003e \"lambda: \" + s end lambda对象的引用权能可以通过在右花括号后声明:\n{(s: String): String =\u003e \"lambda: \" + s } iso 等同于:\nobject iso fun apply(s: String): String =\u003e \"lambda: \" + s end Lambdas可用于从作用域捕获变量，其方式与匿名对象捕获字段的方式相同。通过在参数之后添加第二个参数列表来实现：\nclass Foo new create(env:Env) =\u003e foo({(s: String)(env) =\u003e env.out.print(s) }) fun foo(f: {(String)}) =\u003e f(\"Hello World\") 也可以使用 捕获列表（capture list） 来设置别名。捕获列表在参数之后的第二个括号中：\nnew create(env:Env) =\u003e foo({(s: String)(myenv = env) =\u003e myenv.out.print(s) }) lambda的类型也使用花括号声明。在花括号中，函数形参类型在圆括号中指定，后面跟着一个可选的冒号和返回类型。上面的示例使用{(String)}作为lambda函数的形参类型，该函数接受String作为参数，无返回值。\n如果没有为lambda对象指定引用权能声明，则引用权能的类型将从lambda的结构中推断出来。如果lambda没有捕获到可用权限类型，则默认为val。如果它确实捕获了引用权限，那么默认情况下它将是ref。下面是一个vallambda对象的例子:\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[U32] l.\u003epush(10).\u003epush(20).\u003epush(30).push(40) let r = reduce(l, 0, {(a:U32, b:U32): U32 =\u003e a + b }) env.out.print(\"Result: \" + r.string()) fun reduce(l: List[U32], acc: U32, f: {(U32, U32): U32} val): U32 =\u003e try let acc' = f(acc, l.shift()?) reduce(l, acc', f) else acc end 本例中的reduce方法要求f参数的lambda类型需要val的引用权能。作为参数传入的lambda对象不需要声明显式的引用权能，因为val会被捕获到。\n如前所述，lambda使用apply方法来处理匿名对象。apply方法的引用权能默认为box，跟其他方法一样。在捕获这个的lambda时，如果函数需要修改捕获的任何变量或对其调用ref方法，则需要修改为ref。方法的引用权能(与上面描述的对象引用权能相比)是通过将该权限放在圆括号中的参数列表之前来定义的。\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[String] l.\u003epush(\"hello\").push(\"world\") var count = U32(0) for_each(l, {ref(s:String) =\u003e env.out.print(s) count = count + 1 }) // Displays '0' as the count env.out.print(\"Count: \" + count.string()) fun for_each(l: List[String], f: {ref(String)} ref) =\u003e try f(l.shift()?) for_each(l, f) end 此示例将由lambda表达式生成的apply函数的类型声明为ref。for_each方法中f参数的lambda类型声明也明为ref。lambda类型的引用权能也必须是ref，以便能够调用该方法。lambda对象不需要声明显式引用权能，因为ref会被lambda捕获。\n上面的例子还要注意到一点，捕获的引用的一个微妙的事实。乍一看，你可能会认为count会随着f的应用而增加。但是，在lambda或匿名对象内部count = count + 1永远不会影响到作用域外的值。如果count是一个具有允许修改的引用功能的对象，例如可以私用count.increment()来修改捕获的引用。就会影响到作用域外部count的值。\n匿名Actor（Actor literals） 通常，匿名对象是匿名类的实例。要使它成为匿名Actor的实例，只需在定义中包含一个或多个行为。\nobject be apply() =\u003e env.out.print(\"hi\") end 匿名actor实例总是作为tag（引用权能的一种类型）返回。\n匿名基元类（Primitive literals） 当匿名类型没有字段和行为(例如，声明为lambda的匿名对象)时，编译器将其生成为匿名基元类，除非显式地提供了非val引用功能。基元类就意味着不需要额外的内存分配来生成该类型的实例。\n换句话说，在Pony中，不包含任何字段的lambda没有内存分配开销。这点很棒。\n匿名基元类总是以val的形式返回。\n","summary":"有时候，能够内联地写一个完整的对象是非常方便的。在Pony中，这被称为匿名对象，它做的事情和JavaScript中的匿名对象差不多：它可以生成一个可以立即使用的对象。\n但是Pony是静态类型的，所以一个匿名对象也会创建一个匿名类，这个匿名对象会满足这个匿名类。这类似于Java和C#中的匿名类。在Pony中，匿名类型可以提供任意数量的特征和接口。\n匿名类和匿名对象是什么？（What’s this look like, then?） 匿名类表达式与类（class）的定义基本相同，object表达式构建了一个匿名类并返回它的的实例，这个实例被称为匿名对象。匿名类和普通类有一些细微的区别，下面是一个简单的例子:\nobject fun apply(): String =\u003e \"hi\" end 很简单明了。让我们对其进行扩展，提供一个Hashable特征的实现，以便编译器能够确保匿名类型满足该接口。也可以用相同的方法来提供其他特征。\nobject is Hashable fun apply(): String =\u003e \"hi\" fun hash(): USize =\u003e this().hash() end 我们不能给匿名对象指定构造函数，因为它本身 就是 一个构造函数。那么我们如何分配字段呢？直接声明就行了。例如:\nuse \"collections\" class Foo fun foo(str: String): Hashable =\u003e object is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 在匿名对象所在的作用域中声明和初始化局部变量，等同于在类的构造函数中定义和初始化字段， 匿名类的所有的成员汉书都可以 捕获（capturing） 这些变量当做字段去实用。这非常有趣！它让我们有任意复杂的可以有多个入口点(例如，你可以在一个闭包上调用函数)的。\n默认情况下，带有字段的匿名对象将以ref（引用权能的一种权限类型）方式返回，除非你通过在object关键字后显示的指定一个引用权能的类型来声明权限。例如，一个带有sendable权限的对象可以在需要时可以声明为iso:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.","title":"匿名对象（Object Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/object-literals.html"},{"content":"Pony和其他编程语言一样，可以使用变量存储数据。不同种类的变量有不同的生命周期和使用场景。\n局部变量 Pony中的局部变量与其他语言类似，可以在执行计算时存储临时值。局部变量位于代码块中（它们是该代码块的 local ），并在每次进入代码块时自动创建，并在代码块结束时销毁。\n定义局部变量，可以使用关键字var（也可以使用let，但是我们稍后再讲）。在var后面紧跟着的时变量的名称，变量名后面加上一个：可以设置（可选）变量的类型。例如：\nvar x: String = \"Hello\" var y = \"Hello\" 上面示例中，创建了一个字符串类型的变量x，并赋值为\"Hello\"。\n定义变量时可以不用给变量赋初始值：可以稍后再赋值。但是如果使用没有赋值的变量，编译器会报一个变量还未初始化的错误： uninitialized variable 。\n所有变量要指定类型，但是如果在声明时提供了初始值，就可以省略类型，编译器会根据初始值自动推导出变量的类型。\n下面示例中x，y和z定义方式是等价的。\nvar x: String = \"Hello\" var y = \"Hello\" var z: String z = \"Hello\" 可以同时省略变量的类型和初始值吗？ 不行。这样的话编译器无法确定变量的类型。\n所有局部变量名称均以小写字母开头。如果需要，可以用一个（或多个）引号'结尾，当您规避变量重名问题时，会很有用。例如，有一个名为time的变量，另一个变量名可以用time'。\n变量所在的代码块称为 作用域（scope） 。作用域的范围取决于定义的位置。例如，在if语句的then表达式中定义的变量的作用域就是该then表达式。虽然我们还没有讲到if语句，不过它与其他种语言中的用法是相似的。\nif a \u003e b then var x = \"a is bigger\" env.out.print(x) // OK end env.out.print(x) // Illegal 变量定义后仅在作用域结束前有效。对于变量x，它的有效范围是then表达式到结尾的的end之间：在那之后，就无法再使用它了。\nvar和let 局部变量用var或let声明。使用var表示这个变量可以反复赋值。使用let表示这个是常量只能赋值一次，无法被修改。\nvar x: U32 = 3 let y: U32 = 4 x = 5 // OK y = 6 // Error, y is let 使用let时必须初始化。\nlet x: U32 = 3 // Ok let y: U32 // Error, can't declare a let local without assigning to it y = 6 // Error, can't reassign to a let local 注意，使用let声明的变量只有重新赋值受到限制，并且不影响其引用的对象的可变性。这是引用权能中的内容，本教程后面的章节将对此进行说明。\n变量不一定要用let声明，但是如果永远不会更改变量引用的内容，使用let是个好主义。这也是一种类型注释，指示所引用的内容不能更改。\n字段 在Pony中，字段是对象中的变量。跟其他面向对象语言中的字段没有两样。\n字段与它所在的对象具有相同的生命周期，而不是被限制范围。它们在对象的构造函数内初始化，并与对象一起销毁。\n如果字段名称以“_”开头，表示 私有（private） 。这表示只有该字段所在的类型才能访问该字段。否则，该字段为 公有（public） ，可以从外部访问。\n和局部变量一样，字段也可以用var或let定义。但是字段分配与变量的初始化方式有所不同。无论字段的类型（var还是let），都需要遵守下面的约定：\n1.必须在其定义中分配一个初始值（或第2条） 2.必须在构造方法中分配一个初始值。\n在下面的示例中，类Wombat的两个字段在定义时进行了初始值：\nclass Wombat let name: String = \"Fantastibat\" var _hunger_level: U32 = 0 也可以在构造函数中初始化这些字段：\nclass Wombat let name: String var _hunger_level: U32 new create(hunger: U32) =\u003e name = \"Fantastibat\" _hunger_level = hunger 如果在定义时和构造函数中都没有初始化字段，就会导致编译错误。对于var和let声明的字段都是如此。\n注意，字段必须直接初始化。下面示例其他函数中初始化字段，导致了编译错误，即便该字段是var类型也不可以：\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' set_hunger_level(level) // Error: field _hunger_level left undefined in constructor fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level 在后面的方法章节中，我们会讲到一个类可以有多个构造函数。现在，请记住，如果没有在定义时对字段初始化，就必须在该字段所属类的所有构造函数中进行赋值。\n使用var声明的字段可以多次赋值。使用let声明的字段只能被初始化一次。\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' _hunger_level = level fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level // Ok, _hunger_level is of var type fun ref set_name(name' : String) =\u003e name = name' // Error, can't assign to a let definition more than once 可以在类成员函数中声明字段吗？ 当然不行。如果var或let关键字出现在fun或be声明之后，它们将被视为方法中的局部变量，而不是类型声明中的字段。字段必须出现在类型声明中的所有方法之前。\nEmbedded Fields Unlike local variables, some types of fields can be declared using embed. Specifically, only classes or structs can be embedded - interfaces, traits, primitives and numeric types cannot. A field declared using embed is similar to one declared using let, but at the implementation level, the memory for the embedded class is laid out directly within the outer class. Contrast this with let or var, where the implementation uses pointers to reference the field class. Embedded fields can be passed to other functions in exactly the same way as let or var fields. Embedded fields must be initialised from a constructor expression.\nWhy would I use embed? embed avoids a pointer indirection when accessing a field and a separate memory allocation when creating that field. By default, it is advised to use embed if possible. However, since an embedded field is allocated alongside its parent object, exterior references to the field forbids garbage collection of the parent, which can result in higher memory usage if a field outlives its parent. Use let if this is a concern for you.\n全局变量 很多编程语言都允许全局变量，可以从代码中的任何位置对其进行访问。这是个糟糕的做法！Pony中没有全局变量。\n隐藏（Shadowing） 有些编程语言（类如Rust、Reason）允许你声明一个与现有变量同名的变量，替代旧的。这个方式还被美其名曰 隐藏（shadowing） ，这容易引发bug，Pony中不允许这么做。如果你不小心在Pony中隐藏了变量，编译时会报错。\n如果您需要一个 同名变量 ，可以用前面提到的方式：使用'符号。\n","summary":"Pony和其他编程语言一样，可以使用变量存储数据。不同种类的变量有不同的生命周期和使用场景。\n局部变量 Pony中的局部变量与其他语言类似，可以在执行计算时存储临时值。局部变量位于代码块中（它们是该代码块的 local ），并在每次进入代码块时自动创建，并在代码块结束时销毁。\n定义局部变量，可以使用关键字var（也可以使用let，但是我们稍后再讲）。在var后面紧跟着的时变量的名称，变量名后面加上一个：可以设置（可选）变量的类型。例如：\nvar x: String = \"Hello\" var y = \"Hello\" 上面示例中，创建了一个字符串类型的变量x，并赋值为\"Hello\"。\n定义变量时可以不用给变量赋初始值：可以稍后再赋值。但是如果使用没有赋值的变量，编译器会报一个变量还未初始化的错误： uninitialized variable 。\n所有变量要指定类型，但是如果在声明时提供了初始值，就可以省略类型，编译器会根据初始值自动推导出变量的类型。\n下面示例中x，y和z定义方式是等价的。\nvar x: String = \"Hello\" var y = \"Hello\" var z: String z = \"Hello\" 可以同时省略变量的类型和初始值吗？ 不行。这样的话编译器无法确定变量的类型。\n所有局部变量名称均以小写字母开头。如果需要，可以用一个（或多个）引号'结尾，当您规避变量重名问题时，会很有用。例如，有一个名为time的变量，另一个变量名可以用time'。\n变量所在的代码块称为 作用域（scope） 。作用域的范围取决于定义的位置。例如，在if语句的then表达式中定义的变量的作用域就是该then表达式。虽然我们还没有讲到if语句，不过它与其他种语言中的用法是相似的。\nif a \u003e b then var x = \"a is bigger\" env.out.print(x) // OK end env.out.print(x) // Illegal 变量定义后仅在作用域结束前有效。对于变量x，它的有效范围是then表达式到结尾的的end之间：在那之后，就无法再使用它了。\nvar和let 局部变量用var或let声明。使用var表示这个变量可以反复赋值。使用let表示这个是常量只能赋值一次，无法被修改。\nvar x: U32 = 3 let y: U32 = 4 x = 5 // OK y = 6 // Error, y is let 使用let时必须初始化。","title":"变量（Variables）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/variables.html"},{"content":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段就天然具备不可变性不会产生副作用。只有一个实例的意味着 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\n基元类 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n 作为\"标记值”。例如，Pony经常使用None基元类来表示某事物没有值。当然，它其实具有一个值，并且该值就是None的实例。 作为\"枚举\"类型。通过创建 primitive 类型的 union ，可以使用类型安全的枚举。稍后我们将介绍 union 类型。 作为\"函数集合”。由于基元类也可以有成员函数，因此可以用基元类来做函数分类。例如，标准库中的路径处理相关的函数都被放在Path中（Path就是一个基元类）。  // 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.out.print(\"Is door open? \" + isDoorOpen.string()) env.out.print(\"2 + 3 = \" + BasicMath.add(2,3).string()) 基元类非常强大，尤其是作为枚举使用时。与其他语言中的枚举不同，Pony中枚举的每个值都是一个完整类型，因此可以将数据和函数附加到枚举值上。\n内置的基元类型（Built-in primitive types） primitive 关键字还用于引入某些内置的\"machine word\"类型。除了具有与之关联的值外，这些还类似于用户定义的原语。这些是：\n Bool 。这是一个1位值，true或false。 ISize，ILong，I8，I16，I32，I6​​4，I128 。有符号整数。 USize，ULong，U8，U16，U32，U64，U128 。无符号整数。 F32，F64 。浮点数。  ISize / USize 对应于本机类型size_t的位宽，该位宽因平台而异。 ILong / ULong 类似地对应于本机类型 long的位宽，该位宽也因平台而异。在所有Pony支持的平台上，本机int的位宽均相同，您可以使用 I32 / U32 来实现。\n基元类的初始化和销毁 基元类有两个特殊的成员函数，_init和_final。在任何actor开始之前都会调用_init。在所有参与者都终止之后，将调用_final。这两个函数不带参数。不同的基元类的_init和_final函数始终按顺序执行。\n一个常见的用例是初始化和清理C语言的库，而不用承担actor不当使用的风险。\n","summary":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段就天然具备不可变性不会产生副作用。只有一个实例的意味着 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\n基元类 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n 作为\"标记值”。例如，Pony经常使用None基元类来表示某事物没有值。当然，它其实具有一个值，并且该值就是None的实例。 作为\"枚举\"类型。通过创建 primitive 类型的 union ，可以使用类型安全的枚举。稍后我们将介绍 union 类型。 作为\"函数集合”。由于基元类也可以有成员函数，因此可以用基元类来做函数分类。例如，标准库中的路径处理相关的函数都被放在Path中（Path就是一个基元类）。  // 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.","title":"基元类（Primitives）","uri":"https://damon-kwok.github.io/pony-tutorial/types/primitives.html"},{"content":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\n每一种编程语言都会有字面量对数据的类型进行描述，Pony也不例外。\nPony表达式中常用的字面量有：布尔、数值、字符、字符串、数组。\nBool型 布尔类型有两个可选值：true 和 false。\n数字型 数字型字面量包括：有符号整数、无符号整数和浮点数。\n在大多数情况下，Pony可以从上下文中推导出具体的数据类型（这包括，分配给字段或局部变量或作为方法/行为调用的参数）。\n可以使用以下一种数字类型的构造函数来帮助编译器确定字面量的具体类型：\n U8, U16, U32, U64, U128, USize, ULong I8, I16, I32, I64, I128, ISize, ILong F32, F64  let my_explicit_unsigned: U32 = 42_000 let my_constructor_unsigned = U8(1) let my_constructor_float = F64(1.234) 整数可以以十进制，十六进制或二进制形式给出：\nlet my_decimal_int: I32 = 1024 //十进制 let my_hexadecimal_int: I32 = 0x400\t//十六进制 let my_binary_int: I32 = 0b10000000000\t//二进制 浮点文字以标准浮点或科学计数法表示：\nlet my_double_precision_float: F64 = 0.009999999776482582092285156250 //标准浮点数 let my_scientific_float: F32 = 42.12e-4 //科学计数法 字符型 字符使用单引号'包裹。\n字符和字符串有很大区别，它表示的是一个有符号数字。一个字节即是一个U8。但是它们可以被转换为任意整数类型：\nlet big_a: U8 = 'A' // 65 let hex_escaped_big_a: U8 = '\\x41' // 65 let newline: U32 = '\\n' // 10 下面是Pony支持的字符转义：\n \\x4F hex escape sequence with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\'  多重字符（Multibyte Character literals） Pony的字符字面量可以包含多个字符。生成的整数值是逐字节构造的，每个字符代表生成的整数中的单个字节，最后一个字符是最低有效字节：\nlet multiByte: U64 = 'ABCD' // 0x41424344 字符串 字符串使用\"或\"\"\"包裹。可以包含任意类型的字节或转义字符：\n \\u00FE unicode escape sequence with 4 hex digits encoding one code point \\u10FFFE unicode escape sequence with 6 hex digits encoding one code point \\x4F hex escape sequence for unicode letters with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\\"  每个转义序列编码一个完整字符，而不是字节。\nuse \"format\" actor Main new create(env: Env) =\u003e let pony = \"🐎\" let pony_hex_escaped = \"p\\xF6n\\xFF\" let pony_unicode_escape = \"\\U01F40E\" env.out.print(pony + \" \" + pony_hex_escaped + \" \" + pony_unicode_escape) for b in pony.values() do env.out.print(Format.int[U8](b, FormatHex)) end Pony字符串支持多行定义：\nlet stacked_ponies = \" 🐎 🐎 🐎 \" 字符串和编码 字符串的文字如果从其源代码文件中定义。那么，它们的实际值取决于其源码文件的编码格式。\n请看下面的示例：\nlet u_umlaut = \"ü\" 如果文件编码格式是 UTF-8 那么u_umlaut 的值是: \\xc3\\xbc。如果文件编码格式是ISO-8559-1 (Latin-1) 它的值就是 \\xfc。\n多行字符串（Triple quoted Strings） 要在字符串中嵌入多行文本，请将字符串使用三引号引起来的。\nlet triple_quoted_string_docs = \"\"\" Triple quoted strings are the way to go for long multiline text. They are extensively used as docstrings which are turned into api documentation. They get some special treatment, in order to keep Pony code readable: * The string literal starts on the line after the opening triple quote. * Common indentation is removed from the string literal so it can be conveniently aligned with the enclosing indentation e.g. each line of this literal will get its first two whitespaces removed * Whitespace after the opening and before the closing triple quote will be removed as well. The first line will be completely removed if it only contains whitespace. e.g. this strings first character is `T` not `\\n`. \"\"\" 字符串示例： 如果您的Pony程序中有多出使用相同的单字符字符串时，所有这些字符串都将转换为同一个实例。它们始终相等。\nlet pony = \"🐎\" let another_pony = \"🐎\" if pony is another_pony then // True, therefore this line will run. end 数组（Array Literals） 数组的值需要用方括号括起来。数组的元素可以是任何类型的表达式。元素之间用分号;或换行符分隔：\nlet my_literal_array = [ \"first\"; \"second\" \"third one on a new line\" ] 类型接口（Type inference） 如果没有指定数组的类型，数组表达式的返回类型默认为Array [T] ref，并且，将T（元素的类型）推导为所有元素类型的并集：\nlet my_heterogenous_array = [ U64(42) \"42\" U64.min_value() ] 在上面的示例中，由于数组包含String和U64元素，因此生成的数组类型为Array [(U64 | String)] ref。\n如果将分配给数组的元素是其他类型，Pony将会强制转换为数组的定义类型（译者注：不用担心，如果传入的类型无法被转换编译时就会报错）：\nlet my_stringable_array: Array[Stringable] ref = [ U64(0xA) \"0xA\" ] 这里，my_stringable_array被强制转换为Array [Stringable] ref。之所以能编译通过，是因为String和U64都实现了Stringable特征。\n通过在数组上指定类型说明符val，可以与[ref]不同的引用权能（Reference Capability）的数组：\nlet my_immutable_array: Array[Stringable] val = [ U64(0xBEEF) \"0xBEEF\" ] 你可以创建任何引用权能（Reference Capability）的数组类型。\nas表达式 也有可能使用as表达式来提示数组元素的类型。提示表达式需要在方括号后添加，还要加上冒号：\nlet my_as_array = [ as Stringable: U64(0xFFEF) \"0xFFEF\" U64(1 + 1) ] 这个as表达式，约束此数组类型为：Array [Stringable] ref。\n如果在左侧指定了类型，则需要数组元素与as表达式中的类型完全匹配。\n数组和引用 用字面量构造一个数组会创建对其元素的新引用。因此，为了确保100%的正确性，会将数组元素推导为实际元素类型的别名。如果所有元素的类型均为T，则将数组的北行会被推导为Array [T!] ref，即类型别名为T的数组。\n要使用具有多种引用权能的数组（例如val和ref引用权能类型）可以参考下（构造函数和所有权转让章节）。\n","summary":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\n每一种编程语言都会有字面量对数据的类型进行描述，Pony也不例外。\nPony表达式中常用的字面量有：布尔、数值、字符、字符串、数组。\nBool型 布尔类型有两个可选值：true 和 false。\n数字型 数字型字面量包括：有符号整数、无符号整数和浮点数。\n在大多数情况下，Pony可以从上下文中推导出具体的数据类型（这包括，分配给字段或局部变量或作为方法/行为调用的参数）。\n可以使用以下一种数字类型的构造函数来帮助编译器确定字面量的具体类型：\n U8, U16, U32, U64, U128, USize, ULong I8, I16, I32, I64, I128, ISize, ILong F32, F64  let my_explicit_unsigned: U32 = 42_000 let my_constructor_unsigned = U8(1) let my_constructor_float = F64(1.234) 整数可以以十进制，十六进制或二进制形式给出：\nlet my_decimal_int: I32 = 1024 //十进制 let my_hexadecimal_int: I32 = 0x400\t//十六进制 let my_binary_int: I32 = 0b10000000000\t//二进制 浮点文字以标准浮点或科学计数法表示：","title":"字面量（Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/literals.html"},{"content":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n 权能是一个不可伪造的令牌，它(a)指定一个对象，(b)授予程序对该对象执行特定操作集的权限。\n 那代币是什么?这是一个地址。一个指针。一个引用。它只是…一个对象。\n这怎么可能是不可伪造的呢? 由于Pony没有指针算法，并且是类型安全的，内存安全的，对象引用不能被程序“发明”(即伪造)。您只能通过构造一个对象或传递一个对象来获得一个。\n那么C FFI呢? 使用信用证可以打破这一保证。稍后我们将讨论如何控制边界。\n那么全局变量呢? 他们是坏的!因为您可以在不构造它们或不传递它们的情况下获得它们。\n全局变量是所谓的_ambient authority_的一种形式。环境权限的另一种形式是不受约束地访问文件系统。\nPony没有全局变量，也没有全局函数。这并不意味着所有的环境权限都神奇地消失了——例如，我们仍然需要注意文件系统。没有全局权限对于消除环境权限是必要的，但还不够。\n这有什么用呢? 与使用权限列表、访问控制列表或其他形式的安全性不同，对象-功能模型意味着，如果您有对某个对象的引用，则可以使用该对象进行操作。简单而有效的。\n有一篇关于对象-能力模型如何工作的好论文，读起来很容易:\n权能梦碎——对象权能模型跌落神坛\n权能和并发 对象功能模型本身并不处理并发性。它明确了如果同时访问一个对象将会发生什么，但是没有规定控制这个对象的单一方法。\n将功能与角色模型相结合是一个良好的开端，以前已经在E和Joule等语言中实现过。\nPony做到了这一点，并在类型系统中使用了一个_reference功能的系统。\n","summary":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n 权能是一个不可伪造的令牌，它(a)指定一个对象，(b)授予程序对该对象执行特定操作集的权限。\n 那代币是什么?这是一个地址。一个指针。一个引用。它只是…一个对象。\n这怎么可能是不可伪造的呢? 由于Pony没有指针算法，并且是类型安全的，内存安全的，对象引用不能被程序“发明”(即伪造)。您只能通过构造一个对象或传递一个对象来获得一个。\n那么C FFI呢? 使用信用证可以打破这一保证。稍后我们将讨论如何控制边界。\n那么全局变量呢? 他们是坏的!因为您可以在不构造它们或不传递它们的情况下获得它们。\n全局变量是所谓的_ambient authority_的一种形式。环境权限的另一种形式是不受约束地访问文件系统。\nPony没有全局变量，也没有全局函数。这并不意味着所有的环境权限都神奇地消失了——例如，我们仍然需要注意文件系统。没有全局权限对于消除环境权限是必要的，但还不够。\n这有什么用呢? 与使用权限列表、访问控制列表或其他形式的安全性不同，对象-功能模型意味着，如果您有对某个对象的引用，则可以使用该对象进行操作。简单而有效的。\n有一篇关于对象-能力模型如何工作的好论文，读起来很容易:\n权能梦碎——对象权能模型跌落神坛\n权能和并发 对象功能模型本身并不处理并发性。它明确了如果同时访问一个对象将会发生什么，但是没有规定控制这个对象的单一方法。\n将功能与角色模型相结合是一个良好的开端，以前已经在E和Joule等语言中实现过。\nPony做到了这一点，并在类型系统中使用了一个_reference功能的系统。","title":"对象权能模型（Object Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/object-capabilities.html"},{"content":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 和 函数 的区别：函数是 同步执行 的，行为是 异步执行 的。当您调用一个函数时，该函数将立即执行，并且立即就可以得到返回值。函数就像其他面向对象语言中的方法调用一样。\n行为被调用后 不会 立即执行。相反，该行为的将在未来的某个时间执行。\n行为看起来很像一个函数，但它不是用关键字fun定义的，而是用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何权能接收器上调用行为），但不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None（None基元类的实例），就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) 在这个例子里，我们定义了一个可以异步进餐的土拨鼠。\n消息处理 如果您熟悉基于actor模型的语言（例如Erlang），那么你对\"消息传递\"的概念一定很熟悉了。actor之间就是这样交流的。Pony中的行为等价于Erlang中的消息。当您调用actor的行为时，相当于在向其发送消息。\n如果您不熟悉消息传递，也不必担心。所有内容将在下面说明。\n并发 由于行为是异步执行的，因此可以同时运行很多个行为，这在Pony程序中的很常见。Pony程序在运行的时候会启动一个调度器，默认情况下，该调度器的线程数等于您计算机上的CPU内核数。每个调度器的线程随时待命执行actor的行为，因此Pony程序是原生并发的。\n执行次序 Actor自身是有序的，（译者注：一个actor同一时间只会归属于一个调度器线程），并且每个actor一次只能执行一个行为。编写actor的代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，actor运行的时候只会按照顺序执行操作。在下面的示例中，Main actor调用了一个行为call_me_later，该行为 异步执行 ，因此我们无需等待它运行就可以继续。然后，我们运行方法 env.out.print，它也是 异步执行的 ，并将文本输出到控制台。现在，我们已经了解了Main actor的工作机制，尝试运行下程序吧。\nactor Main new create(env: Env) =\u003e call_me_later(env) env.out.print(\"This is printed first\") be call_me_later(env: Env) =\u003e env.out.print(\"This is printed last\") 所有代码都在同一个actor中运行，并且对其他行为env.out.print的调用也都是顺序的，因此始终会先输出\"This is printed first\"后输出\"This is printed last\"。\n为什么这些代码时安全的？ 得益于Pony的 权能安全的类型系统 。之前在讨论函数接收器引用权能的时候，我们已经简单的介绍了引用权能。它们是对类型的注释，这些注释使得Pony在处理并行问题上没有任何运行时开销。\n稍后我们将深入介绍引用权能。\nActor的开销非常低 如果您以前做过并发编程，你一定很清楚线程的开销非常昂贵。上下文切换可能会导致一系列问题，每个线程都需要一个堆栈（这会占用很多内存），并且您需要大量的锁和其他机制来辅助编写线程安全的代码。\n但是actor的开销可以忽略不计。与类对象相比，actor的额外开销大约为256个字节的内存。注意是字节，而不是千字节！而且没有锁，也没有上下文切换。除了少数几个额外的内存字节外，没有执行的actor不会消耗资源。\n一个程序中使用成千上万的actor对Pony来说是再正常不过的事。\nActor finalisers 和类一样，actor也有销毁函数。销毁函数的定义也是（fun _final（））。类的销毁函数的所有保证和限制也对actor有效。另外，actor的销毁函数被调用后，就不会再收到任何消息。\n","summary":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 和 函数 的区别：函数是 同步执行 的，行为是 异步执行 的。当您调用一个函数时，该函数将立即执行，并且立即就可以得到返回值。函数就像其他面向对象语言中的方法调用一样。\n行为被调用后 不会 立即执行。相反，该行为的将在未来的某个时间执行。\n行为看起来很像一个函数，但它不是用关键字fun定义的，而是用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何权能接收器上调用行为），但不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None（None基元类的实例），就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) 在这个例子里，我们定义了一个可以异步进餐的土拨鼠。\n消息处理 如果您熟悉基于actor模型的语言（例如Erlang），那么你对\"消息传递\"的概念一定很熟悉了。actor之间就是这样交流的。Pony中的行为等价于Erlang中的消息。当您调用actor的行为时，相当于在向其发送消息。\n如果您不熟悉消息传递，也不必担心。所有内容将在下面说明。\n并发 由于行为是异步执行的，因此可以同时运行很多个行为，这在Pony程序中的很常见。Pony程序在运行的时候会启动一个调度器，默认情况下，该调度器的线程数等于您计算机上的CPU内核数。每个调度器的线程随时待命执行actor的行为，因此Pony程序是原生并发的。\n执行次序 Actor自身是有序的，（译者注：一个actor同一时间只会归属于一个调度器线程），并且每个actor一次只能执行一个行为。编写actor的代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，actor运行的时候只会按照顺序执行操作。在下面的示例中，Main actor调用了一个行为call_me_later，该行为 异步执行 ，因此我们无需等待它运行就可以继续。然后，我们运行方法 env.out.print，它也是 异步执行的 ，并将文本输出到控制台。现在，我们已经了解了Main actor的工作机制，尝试运行下程序吧。\nactor Main new create(env: Env) =\u003e call_me_later(env) env.","title":"并发单元（Actors）","uri":"https://damon-kwok.github.io/pony-tutorial/types/actors.html"},{"content":"我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来，逐行解释它们的含义：\n第一行 actor Main 这是一个类型声明。actor关键字表示定义了一个并发执行单元，暂时你只要了解到这是Pony声明Main函数的做法，等同于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲到。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Main actor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。new关键字表示它可以被实例化，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。可以用不同的构造函数创建不同的实例。这里我们用的是默认构造函数create。\n接下来，构造函数的参数。构造函数定义了一个env参数，类型为Env。\nPony的参数类型在参数名之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、TypeScript、ActionScript、Haxe等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout （可以在控制台上输出一些内容）。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号是C/C++的风格的定义方式（支持字符转译）。三引号\"\"\"可以定义Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony中没有全局变量，需要通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名为Main的actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。下一节讲解Pony的类型系统。\n","summary":"我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来，逐行解释它们的含义：\n第一行 actor Main 这是一个类型声明。actor关键字表示定义了一个并发执行单元，暂时你只要了解到这是Pony声明Main函数的做法，等同于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲到。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Main actor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。new关键字表示它可以被实例化，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。可以用不同的构造函数创建不同的实例。这里我们用的是默认构造函数create。\n接下来，构造函数的参数。构造函数定义了一个env参数，类型为Env。\nPony的参数类型在参数名之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、TypeScript、ActionScript、Haxe等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout （可以在控制台上输出一些内容）。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号是C/C++的风格的定义方式（支持字符转译）。三引号\"\"\"可以定义Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony中没有全局变量，需要通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名为Main的actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。下一节讲解Pony的类型系统。","title":"庖丁解牛","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/how-it-works.html"},{"content":"你可能熟悉Python、Ruby、Java、C++等语言中的异常处理方式，Pony中有所不同，Pony提供了一个更简单的机制来帮助处理异常。Pony触发异常的方式与其他语言有一些重要的语义区别，Pony用error（还有as）关键字和偏函数(Partial functions)来触发异常。让我们看看Pony是如何处理异常的，然后和你习惯的语言对比一下有什么不同。\n异常的触发和处理(Raising and handling errors) 使用error可以触发一个异常。可以任何时候都可以使用error。此时后续代码会停止执行，调用链被解除，逻辑跳寻找并转到异常处理代码块中继续执行。异常处理机制是在编译时会进行检查，确保在运行时不会导致整个程序崩溃。\n异常处理程序是使用try-else语法声明的。\ntry callA() if not callB() then error end callC() else callD() end 在上面的代码中，callA()总是会被执行，callB()也会被执行。如果callB()的返回值为true，那么我们将按照正常方式继续执行callC()，那么callD()将不会被执行。\n但是，如果callB()返回false，则会触发一个异常。此时，执行将停止，寻找并执行最近的异常处理程序。在本例中，else中的callD()将被执行。\n在这两种情况下，程序都将继续执行try end后面的逻辑。\n必须提供一个异常处理程序吗? 不需要。try可以单独工作。如果不提供else，则不会执行任何异常处理操作,直接转转到try表达式之后继续执行。\n如果有一些可能会触发异常的逻辑，但你不需要在发生后做出处理(比如:一个文件存在的话就读取它的内容)，可以把这段逻辑里面放在一个try中,不需要提供else。\ntry // Do something that may raise an error end __异常处理逻辑中需要做些什么? __ 无所谓。如果您提供了一个异常处理程序，那么它必须包含一些代码，具体执行些什么逻辑取决于你自己。\n一个try代码块的返回值是什么?try的返回值是try的最后一个表达式的值，如果出现过程中出现了异常，就使用else子句中的最后一个表达式的值。如果出现了一个异常，并且没有提供else子句，那么返回值将是None。\n偏函数(Partial functions) Pony并不要求像前面的例子那样立即处理所有的异常。函数执行时可能触发异常，而这些异常可以由调用它们的代码处理。这些被称为偏函数(Partial functions)(这是一个数学术语，意思是对于所有可能的输入(即参数)没有定义返回值的函数)。偏函数必须在函数签名(定义返回类型)之后和调用位置(右括号之后)加上?。\n下面示例，如果输入为负数，那么接受有符号整数的阶乘函数就会出错。这个函数只在有效的输入时才会正确执行。\nfun factorial(x: I32): I32 ? =\u003e if x \u003c 0 then error end if x == 0 then 1 else x * factorial(x - 1)? end 在Pony会发生异常的逻辑(error表达式，偏函数的调用，或者某些内置的机制（比如as）)，都必须实用try代码块，或者放在偏函数中。编译时对此进行检查，以确保异常的触发不会导致程序崩溃。\n在Pony的0.16.0版本之前，偏函数的调用位置不需要标记?，在阅读代码时会有点费解。之后的版本为偏函数作出清楚的标记，代码更易读，可以清晰的了解逻辑会跳转到最近的异常处理代码块中执行，条例更加清晰明确。\n部分构造函数和行为(Partial constructors and behaviours) 类的构造函数也可以标记为偏函数。如果在类的构造函数中触发异常，则认为构造失败，正在构造的对象被丢弃，而且不会返回给调用者。\n当调用actor构造函数时，将创建actor并立即返回对它的引用。但是，actor的构造函数代码将在稍后的某个时间异步执行。如果在actor构造函数内触发一个异常，那么向调用者报告这个异常就晚了。因此，actor的构造函数不能被设置为偏函数。\n行为也是异步执行的，因此行为也不被标记为偏函数。\nTry-then表达式 除了else表达式外，try还可以使用then表达式。它会在try和else之后执行，不管是否触发异常一定会被执行。我们对前面的示例做一下扩展:\ntry callA() if not callB() then error end callC() else callD() then callE() end callE()始终会被执行。如果callB()返回true，那么执行的序列是callA()， callB()， callC()， callE()。如果callB()返回false，那么执行的序列是callA()， callB()， callD()， callE()。\n必须在使用了else处理程序后,才能用then表达式吗? 不需要。如果你喜欢的话，你可以直接使用try-then,省略掉else。\nthen代码块真的总是被执行吗，如果在try里面直接retuan呢? 放心，当try表达式无论以何种方式完成时，你的then表达式一定会被执行。唯一的例外情况的是，如果try永远无法完成(陷入一个死循环)，电脑被人拔掉电源，或者进程被终止(那你的then就有可能不会被执行…)。\nWith表达式 with表达式可用于对象不再需要时,执行一些处理操作。常见的情况是数据库连接在使用后需要关闭，以避免服务器上的资源浪费。例如:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj end obj.dispose()会自动在with表达式内的代码成功完成或触发异常时被调用。一个对象要使用with表达式，需要必须提供一个dispose()方法:\nclass SomeObjectThatNeedsDisposing // constructor, other functions fun dispose() =\u003e // release resources 可以with提供else选项，它只在触发了异常的情况下被调用:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj else // only run if an error has occurred end with可以一次设置多个对象进行处理:\nwith obj = SomeObjectThatNeedsDisposing(), other = SomeOtherDisposableObject() do // use obj end with的返回值是代码块中的最后一个表达式的值，或者是else代码块中的最后一个表达式的值(如果有一个表达式并且发生了异常)。\n触发异常的关键字 除了error表达式或调用偏函数外，触发异常还可以使用as表达式。比如，将给定的值转换为指定的类型,如果不能转换，就会触发异常。所以as命令只能在try代码块或偏函数中使用。\n与其他语言中的异常处理进行比较 Pony的异常处理与C++、Java、C#、Python和Ruby中的异常处理非常类似。主要的区别在于，Pony的异常不需要与类型或实例相关联。这就像抛出固定错误号的C++异常一样。throw 3;。这种方式简化了程序员的异常处理逻辑，也可以拥有更好的运行时性能。\ntry表达式中的else处理程序就像C++中的catch(...)，Java或C#中的catch(Exception e)， Python中的except:或Ruby中的rescue。因为异常没有类型，所以处理程序不需要指定类型，也就不需要一个try代码块中对应多个异常处理程序。\ntry表达式中的then代码块就像Java、C#或Python中的finally和Ruby中的ensure一样。\n如果需要，异常处理逻辑可以通过使用error表达式再次执行。\n","summary":"你可能熟悉Python、Ruby、Java、C++等语言中的异常处理方式，Pony中有所不同，Pony提供了一个更简单的机制来帮助处理异常。Pony触发异常的方式与其他语言有一些重要的语义区别，Pony用error（还有as）关键字和偏函数(Partial functions)来触发异常。让我们看看Pony是如何处理异常的，然后和你习惯的语言对比一下有什么不同。\n异常的触发和处理(Raising and handling errors) 使用error可以触发一个异常。可以任何时候都可以使用error。此时后续代码会停止执行，调用链被解除，逻辑跳寻找并转到异常处理代码块中继续执行。异常处理机制是在编译时会进行检查，确保在运行时不会导致整个程序崩溃。\n异常处理程序是使用try-else语法声明的。\ntry callA() if not callB() then error end callC() else callD() end 在上面的代码中，callA()总是会被执行，callB()也会被执行。如果callB()的返回值为true，那么我们将按照正常方式继续执行callC()，那么callD()将不会被执行。\n但是，如果callB()返回false，则会触发一个异常。此时，执行将停止，寻找并执行最近的异常处理程序。在本例中，else中的callD()将被执行。\n在这两种情况下，程序都将继续执行try end后面的逻辑。\n必须提供一个异常处理程序吗? 不需要。try可以单独工作。如果不提供else，则不会执行任何异常处理操作,直接转转到try表达式之后继续执行。\n如果有一些可能会触发异常的逻辑，但你不需要在发生后做出处理(比如:一个文件存在的话就读取它的内容)，可以把这段逻辑里面放在一个try中,不需要提供else。\ntry // Do something that may raise an error end __异常处理逻辑中需要做些什么? __ 无所谓。如果您提供了一个异常处理程序，那么它必须包含一些代码，具体执行些什么逻辑取决于你自己。\n一个try代码块的返回值是什么?try的返回值是try的最后一个表达式的值，如果出现过程中出现了异常，就使用else子句中的最后一个表达式的值。如果出现了一个异常，并且没有提供else子句，那么返回值将是None。\n偏函数(Partial functions) Pony并不要求像前面的例子那样立即处理所有的异常。函数执行时可能触发异常，而这些异常可以由调用它们的代码处理。这些被称为偏函数(Partial functions)(这是一个数学术语，意思是对于所有可能的输入(即参数)没有定义返回值的函数)。偏函数必须在函数签名(定义返回类型)之后和调用位置(右括号之后)加上?。\n下面示例，如果输入为负数，那么接受有符号整数的阶乘函数就会出错。这个函数只在有效的输入时才会正确执行。\nfun factorial(x: I32): I32 ? =\u003e if x \u003c 0 then error end if x == 0 then 1 else x * factorial(x - 1)?","title":"异常处理（Errors）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/errors.html"},{"content":"因为类型是保证，所以讨论引用权能的保证是很有用的。\n拒绝访问（What is denied） 我们将讨论引用权能保证在什么情况下访问被拒绝。这里我们讨论的问题是：当你有一个具有一定引用权能的变量时，其他变量 不能 做什么?\n我们需要区分包含有变量的actor和 其他 actor。\n这一点很重要，因为来自其他actor的数据读写可能同时发生。如果两个actor都能读取相同的数据，并且其中一个更改了数据，那么另一个actor的数据也会发生变化。这将导致数据竞争和对锁的需求。只有确保这种情况永远不会发生，Pony才能消除对锁的需求。\n任何一个actor中的所有代码总是顺序执行。这意味着来自单个actor中的多个变量的数据访问不会受到数据竞争的影响。\n可变引用权能（Mutable reference capabilities） 可变的引用权能有iso、trn和ref。用这些引用权能标记的数据是可修改的，它们可以用来读写对象。\n 如果一个actor有一个iso变量，那么 任何 actor都不能读写这个对象。这表示iso变量是程序中惟一可以读写该对象的变量。 如果一个actor有一个trn变量，那么 任何 actor都不能写入该对象，其他 actor也不能读写该对象。这表示trn变量是程序中惟一可以写入该对象的变量，但是同一actor持有的其他变量可能可以从该对象读取数据。它是 write unique 。 如果一个actor有一个ref变量，那么 其他 actor都不能使用其他变量来读写这个对象。这意味着可以使用其他变量对对象进行读写操作，但只能从相同的actor中进行。  为什可以安全的修改？ 因为 其他 的actor无法对其读写。不可变的引用权能(Immutable reference capabilities) 不可改变的引用权能是val和box。这些引用权能是不可变的，它们可以用于从对象中读取数据，而不是写入数据。\n 如果一个actor有一个val变量，那么 任何 actor不能修改。这表示它 无法被修改 。它是永恒不变。 如果一个actor有一个box变量，那么 其他 actors就不能修改。但时其他actor可以读取，而同一actor中的其他变量才可以修改(尽管不是同时写入)。无论哪种情况，我们读取变量都是安全的。对象是_localy mmutable_。  为什么可以读取不能修改? 因为这些引用权能只会阻止 其他 actor修改对象。这表示不能保证 其他 actor不会从对象中读取数据，这意味着写入它是不安全的。但是，多个actor同时读取一个对象是安全的，所以我们可以这样做。\n不透明的引用权能（Opaque reference capabilities） 只有一种模糊的引用权能，那就是tag。tag变量对其他变量没有任何保证。因此，它既不能用于从对象中读取数据，也不能用于从对象中写入数据;因此被称为 不透明（opaque） 。\n它仍然是有用的:你可以用它做身份比较，你可以在它上面调用行为，你可以在它上面调用功能，只需要一个tag接收器。\n为什么tag不能用来读或写?因为tag并不会阻止其他的角色写入对象。这意味着，如果我们试图读取，我们不能保证没有其他actor写入对象，所以我们可能会得到竞态条件。\n","summary":"因为类型是保证，所以讨论引用权能的保证是很有用的。\n拒绝访问（What is denied） 我们将讨论引用权能保证在什么情况下访问被拒绝。这里我们讨论的问题是：当你有一个具有一定引用权能的变量时，其他变量 不能 做什么?\n我们需要区分包含有变量的actor和 其他 actor。\n这一点很重要，因为来自其他actor的数据读写可能同时发生。如果两个actor都能读取相同的数据，并且其中一个更改了数据，那么另一个actor的数据也会发生变化。这将导致数据竞争和对锁的需求。只有确保这种情况永远不会发生，Pony才能消除对锁的需求。\n任何一个actor中的所有代码总是顺序执行。这意味着来自单个actor中的多个变量的数据访问不会受到数据竞争的影响。\n可变引用权能（Mutable reference capabilities） 可变的引用权能有iso、trn和ref。用这些引用权能标记的数据是可修改的，它们可以用来读写对象。\n 如果一个actor有一个iso变量，那么 任何 actor都不能读写这个对象。这表示iso变量是程序中惟一可以读写该对象的变量。 如果一个actor有一个trn变量，那么 任何 actor都不能写入该对象，其他 actor也不能读写该对象。这表示trn变量是程序中惟一可以写入该对象的变量，但是同一actor持有的其他变量可能可以从该对象读取数据。它是 write unique 。 如果一个actor有一个ref变量，那么 其他 actor都不能使用其他变量来读写这个对象。这意味着可以使用其他变量对对象进行读写操作，但只能从相同的actor中进行。  为什可以安全的修改？ 因为 其他 的actor无法对其读写。不可变的引用权能(Immutable reference capabilities) 不可改变的引用权能是val和box。这些引用权能是不可变的，它们可以用于从对象中读取数据，而不是写入数据。\n 如果一个actor有一个val变量，那么 任何 actor不能修改。这表示它 无法被修改 。它是永恒不变。 如果一个actor有一个box变量，那么 其他 actors就不能修改。但时其他actor可以读取，而同一actor中的其他变量才可以修改(尽管不是同时写入)。无论哪种情况，我们读取变量都是安全的。对象是_localy mmutable_。  为什么可以读取不能修改? 因为这些引用权能只会阻止 其他 actor修改对象。这表示不能保证 其他 actor不会从对象中读取数据，这意味着写入它是不安全的。但是，多个actor同时读取一个对象是安全的，所以我们可以这样做。\n不透明的引用权能（Opaque reference capabilities） 只有一种模糊的引用权能，那就是tag。tag变量对其他变量没有任何保证。因此，它既不能用于从对象中读取数据，也不能用于从对象中写入数据;因此被称为 不透明（opaque） 。\n它仍然是有用的:你可以用它做身份比较，你可以在它上面调用行为，你可以在它上面调用功能，只需要一个tag接收器。\n为什么tag不能用来读或写?因为tag并不会阻止其他的角色写入对象。这意味着，如果我们试图读取，我们不能保证没有其他actor写入对象，所以我们可能会得到竞态条件。","title":"引用权能保证（Reference Capability Guarantees）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/guarantees.html"},{"content":"如果对象具有权能，我们该怎么来控制？比如如何表示该对象的 访问权限（access rights） ？\nPony中，可以用引用权能（reference capabilities）来处理。\n权限只是权能的一部分 如果在UNIX系统中打开一个文件，会返回一个文件描述符，该文件描述符只是一个文件指向标识——并不是一个权能（描述符只体现了能没有体现权,描述符使可以访问文件，但是访问权呢？）。完整的权能：需要获得权限，然后指定文件路径和打开模式。例如:\nchmod u+w /etc/passwd int fd = open(\"/etc/passwd\", O_RDWR); 现在我们拥有了/etc/passwd文件的读写权，然后使用O_RDWR模式打开们见得到了一个文件描述符。访问授权、打开模式、文件描述符共同构成了一个权能。\n在Pony中，所有被引用的数据都有一个类型和一个引用权能（reference capabilities）。实际上，引用权能（reference capabilities）是其类型的一部分。这允许你指定哪些对象可以与其他actor共享，并允许编译器检查你的逻辑是并发安全的。\n基本概念（Basic concepts） 在引用权能（reference capabilities）变得有意义之前，您需要理解一些简单的概念。我们已经讨论过其中的一些，有些可能对你来说已经很明显了，但是在这里值得回顾一下。\n共享可变数据非常困难\n并发性的问题根源来自于共享可变数据。如果两个线程可以同时访问同一个数据，那么它们可能会同时修改它。这最多可能导致两个线程拥有不同版本的数据。在最坏的情况下，更新可能会交互不良，导致数据被垃圾覆盖。避免这些问题的常规做法是使用锁来防止同时发生数据更新。这会导致巨大的性能开销（上下文切换），并且一不小心就会导致bug。\n不可变数据可以安全地共享\n任何不可变的数据(即不会被修改数据)都可以安全地并发使用。因为它们永远不会更新，正是更新导致了并发性问题。\n被隔离的数据是安全的\n如果一个数据块只有一个对它的引用，那么我们称它为 被隔离的数据(isolated) 。因为只有一个对它的引用，所以不会被被多个线程共享，也就不存在并发问题。被隔离的数据可以在多个线程之间传递。只要同一时间只存在一个对它的引用，那么数据就是安全的，不会出现并发问题。\n被隔离的数据有可以是复合类型\n一个被隔离的数据（isolated）可以是一个字节，也可以是一个大型数据结构，并且在该结构中的各个对象之间有多个引用。对于隔离的数据来说，重要的是整个程序中只有一个单一的引用。我们讨论了数据结构的隔离边界。对结构进行隔离:\n 外部必须只能有一个指向内部对象的引用。 外部可以有任意数量的引用，但它们都不能指向外部的对象。  每个actor都只会在一个线程中运行\nactor内部的代码永远不会并发运行。在actor中，数据更新不会导致并发问题。只有当我们希望在actor之间共享数据时，才会遇到问题。\n好吧，看来同时安全地共享数据确实很棘手，来看看引用权能（reference capabilities）是怎么做到的。\n通过只共享不可变的数据和只交换被隔离的数据，我们可以拥有没有锁的安全并发程序。问题是要正确地做到这一点是非常困难的。如果您不小心挂起了对某些已提交的独立数据的引用，或者将已共享的内容更改为不可变的，那么一切都会出错。你需要的是编译器强迫你去实现你的承诺。小马引用权能（reference capabilities）允许编译器这样做。\n类型限定符（Type qualifiers） 如果你使用过C/C++，您可能熟悉const，它是一个 类型限定符（type qualifier） ，告诉编译器不允许程序员修改某些东西。\nA reference capability is a form of type qualifier and provides a lot more guarantees than const does! 引用权能（reference capabilities）是 type qualifier 的一种形式，它提供了比const多得多的保证!\n在Pony中，所有的类型都有一个引用权能（reference capabilities）作为类型限定符。这个规则只适用于变量（局部变量、字段、参数等），而不是类型。换句话说，当你定义一个类Wombat时，你不会为这个类的所有实例使用某个引用权能（reference capabilities）。相反，Wombat的每个字段都有自己的引用权能（reference capabilities）。\n例如，在某些语言中，必须定义一个表示可变字符串(String)的类型和另一个表示不可变字符串的类型。例如，在Java中，有一个String和一个StringBuilder。在Pony中，一个String类就够了，定义可变字符串：String ref和不可变字符串：String val。\n引用权能（reference capabilities）列表 Pony有六种引用权能（reference capabilities），它们都有严格的定义和使用规则。我们稍后会讲到，现在先来看看它们的名字和用途:\n被隔离的数据（Isolated），关键字为iso。这是为了引用隔离的数据结构。如果你有一个“iso”变量，那么你就知道没有其他变量可以访问这些数据。所以你可以随心所欲地改变它，把它给另一个演员。\n不可变数据（Value）,关键字为val。这是用于引用不可变的数据结构。如果你有一个“val”变量，那么你就知道没有人可以改变数据。所以你可以读它，并与其他演员分享。\n可变数据（Reference），关键字为ref。这是为了引用非独立的可变数据结构，换句话说，就是“正常”数据。如果你有一个ref变量，那么你可以读和写的数据，无论你喜欢，你可以有多个变量，可以访问相同的数据。但是你不能和其他演员分享。\n只读引用（Box） ，关键字为box，这是为了引用对您来说是只读的数据。这些数据可能是不可变数据，并与其他actor共享，或者在您的actor中使用它的其他变量可以更改数据。无论哪种方式，box变量都可以用来安全地读取数据。这听起来可能有点无意义，但它允许您编写既可以用于val变量又可以用于ref变量的代码，只要它不写入对象即可。\n可传输数据（Transition）,关键字为trn。这用于您希望写入的数据结构，同时为它们保存只读(box)变量。如果您愿意，您还可以稍后将trn变量转换为val变量，这将阻止任何人更改数据，并允许与其他actor共享数据。\n标识（Tag） 关键字为tag。它仅用于定义标识符。不能对tag变量进行读写。但是tag可以存储和比较，可以方便的用以对象标识检查，另外tag变量可以与其他actor共享。\n注意，如果您有一个变量引用一个actor，那么您可以向该actor发送消息，而不用关心该变量具有什么引用权能（reference capabilities）。\n引用权能如何使用（How to write a reference capability） 引用权能（reference capabilities）限定符放在类型后。举个例子:\nString iso // An isolated string String trn // A transition string String ref // A string reference String val // A string value String box // A string box String tag // A string tag 当类型没有指定引用权能（reference capabilities）时，它意味着什么?__意味着你使用了该类型的 默认 引用权能（reference capabilities），默认引用权能是和类型一起定义的。下面是来自标准库的一个例子:\nclass val String 当我们使用一个字符串时，我们通常指的是一个不可变的字符串值，因此我们将val作为String的默认引用权能（reference capabilities）(但不一定是String构造函数，请参阅下面)。例如，当我们没有在下面的代码中指定引用权能时，编译器会使用默认引用权能（reference capabilities）``val:\nlet a: String val = \"Hello, world!\" let b: String = \"I'm a wombat!\" // Also a String val 所以定义一个类型时，必须指定一个引用权能（reference capabilities）吗？ 有特殊需求时才需要制定，大多数类型都会使用合理的默认值。类使用ref，基元类使用val(即不可变的引用)，以及actor使用tag。\n如何创建具有不同引用权能的对象 在编写构造函数时，该构造函数默认将创建一个具有ref或tag功能的新对象。actor的构造函数总是创建一个tag。对于class默认为ref，但是你可以使用其他引用权能创建。来看一个例子:\nclass Foo let x: U32 new val create(x': U32) =\u003e x = x' 当你调用Foo。create(1)时，你会得到一个Foo val而不是Foo ref。\n但是如果你想同时创建val和ref的Foo实例呢？你可以这样做：\nclass Foo let x: U32 new val create_val(x': U32) =\u003e x = x' new ref create_ref(x': U32) =\u003e x = x' 但是，这不是最佳做法。最好的做法是使用Pony的权能借用功能，我们将在后面的权能借用一节中介绍。\n","summary":"如果对象具有权能，我们该怎么来控制？比如如何表示该对象的 访问权限（access rights） ？\nPony中，可以用引用权能（reference capabilities）来处理。\n权限只是权能的一部分 如果在UNIX系统中打开一个文件，会返回一个文件描述符，该文件描述符只是一个文件指向标识——并不是一个权能（描述符只体现了能没有体现权,描述符使可以访问文件，但是访问权呢？）。完整的权能：需要获得权限，然后指定文件路径和打开模式。例如:\nchmod u+w /etc/passwd int fd = open(\"/etc/passwd\", O_RDWR); 现在我们拥有了/etc/passwd文件的读写权，然后使用O_RDWR模式打开们见得到了一个文件描述符。访问授权、打开模式、文件描述符共同构成了一个权能。\n在Pony中，所有被引用的数据都有一个类型和一个引用权能（reference capabilities）。实际上，引用权能（reference capabilities）是其类型的一部分。这允许你指定哪些对象可以与其他actor共享，并允许编译器检查你的逻辑是并发安全的。\n基本概念（Basic concepts） 在引用权能（reference capabilities）变得有意义之前，您需要理解一些简单的概念。我们已经讨论过其中的一些，有些可能对你来说已经很明显了，但是在这里值得回顾一下。\n共享可变数据非常困难\n并发性的问题根源来自于共享可变数据。如果两个线程可以同时访问同一个数据，那么它们可能会同时修改它。这最多可能导致两个线程拥有不同版本的数据。在最坏的情况下，更新可能会交互不良，导致数据被垃圾覆盖。避免这些问题的常规做法是使用锁来防止同时发生数据更新。这会导致巨大的性能开销（上下文切换），并且一不小心就会导致bug。\n不可变数据可以安全地共享\n任何不可变的数据(即不会被修改数据)都可以安全地并发使用。因为它们永远不会更新，正是更新导致了并发性问题。\n被隔离的数据是安全的\n如果一个数据块只有一个对它的引用，那么我们称它为 被隔离的数据(isolated) 。因为只有一个对它的引用，所以不会被被多个线程共享，也就不存在并发问题。被隔离的数据可以在多个线程之间传递。只要同一时间只存在一个对它的引用，那么数据就是安全的，不会出现并发问题。\n被隔离的数据有可以是复合类型\n一个被隔离的数据（isolated）可以是一个字节，也可以是一个大型数据结构，并且在该结构中的各个对象之间有多个引用。对于隔离的数据来说，重要的是整个程序中只有一个单一的引用。我们讨论了数据结构的隔离边界。对结构进行隔离:\n 外部必须只能有一个指向内部对象的引用。 外部可以有任意数量的引用，但它们都不能指向外部的对象。  每个actor都只会在一个线程中运行\nactor内部的代码永远不会并发运行。在actor中，数据更新不会导致并发问题。只有当我们希望在actor之间共享数据时，才会遇到问题。\n好吧，看来同时安全地共享数据确实很棘手，来看看引用权能（reference capabilities）是怎么做到的。\n通过只共享不可变的数据和只交换被隔离的数据，我们可以拥有没有锁的安全并发程序。问题是要正确地做到这一点是非常困难的。如果您不小心挂起了对某些已提交的独立数据的引用，或者将已共享的内容更改为不可变的，那么一切都会出错。你需要的是编译器强迫你去实现你的承诺。小马引用权能（reference capabilities）允许编译器这样做。\n类型限定符（Type qualifiers） 如果你使用过C/C++，您可能熟悉const，它是一个 类型限定符（type qualifier） ，告诉编译器不允许程序员修改某些东西。\nA reference capability is a form of type qualifier and provides a lot more guarantees than const does! 引用权能（reference capabilities）是 type qualifier 的一种形式，它提供了比const多得多的保证!","title":"引用权能（Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html"},{"content":"在Pony中，所有的执行逻辑（代码）都被放在方法中。方法有三种：函数、构造函数和行为。所有的方法都要写在类型定义中（例如：类、基元类、actor等），不存在全局函数或全局行为。\n行为用于处理发送给参与者的异步消息，我们在类型系统章节中已经讲解过行为。\n可以像Python那样在任何方法之外添加一些代码吗？ 不行。所有的Pony代码都必须在一个方法中。\n函数（Functions） Pony的函数与其他语言中的函数（或方法）非常相似。它们可以具有0个或多个参数，以及0个或1个返回值（如果需要像Go语言的多返回值可以使用元组）。如果省略了返回类型，则该函数的返回值将为None。\nclass C fun add(x: U32, y: U32): U32 =\u003e x + y fun nop() =\u003e add(1, 2) // Pointless, we ignore the result 函数参数（如果有）在函数名称后的括号中指定。即便没有任何参数的函数定义时，括号也不能省略。\n每个参数都有一个名称和类型。在我们的示例函数中，add函数有两个参数x和y，它们都是U32类型。传递给函数调用的值（示例中为1和 2）称为实参（arguments），并且在进行调用时会对其求值并分配给形参（parameters）。形参虽然没有明确给出声明的方式，但实际上它们被声明为let。\n形参后面的的是返回类型。如果不需要返回值，可以省略。\n返回值后面是=\u003e，最后是函数体。返回值是函数体表达式的执行结果（请记住，所有内容都是表达式），也就是函数中最后一条表达式的值。\n如果想从函数中提前返回，可以使用return表达式。如果函数具有返回类型，需要为return提供一个值。如果该函数没有返回类型，单独用return就行。\n可以按参数类型重载函数吗？ 不行，同一个类型中不允许出现重名的方法。\n构造函数（Constructors） 跟其他语言一样，Pony的构造函数也是用于初始化对象。不同的是，Pony构造函数可以自定义函数名字，也可以使用任意数量和类型的参数。Pony的默认构造函数（所有的类型定义都一样）为create。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x 构造函数的作用，是为了在创建对象时初始化对象内部状态。Pony中构造函数必须对所有字段做出初始化。\n可以从构造函数中提前返回吗？ 是的。使用不带值的return命令。但是要确保return前所有字段都已经进行了初始化。\n方法调用（Calling） 方法的调用与其他语言一样，通过在方法名称后的括号内提供参数来调用。即使没有参数需要传递，也需要括号。\nclass Foo fun hello(name: String): String =\u003e \"hello \" + name fun f() =\u003e let a = hello(\"Fred\") 要实例化一个类型，需要调用这个类型的构造函数。指定类型，后跟一个点，然后是要调用的构造函数名：\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = Foo.from_int(3) 调用对象的函数：对象名后跟一个点，然后是要调用的函数名。如果省略了要调用的对象，则使用当前对象（即this）。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x fun get(): U32 =\u003e _x class Bar fun f() =\u003e var a: Foo = Foo.from_int(3) var b: U32 = a.get() var c: U32 = g(b) fun g(x: U32): U32 =\u003e x + 1 构造函数也可以直接调用。相当于用this在调用，创建的对象类型就是当前类型。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = a.from_int(3) 我们甚至可以在赋值表达式中用另一个实例名来调用构造函数（上面的示例中）。\nclass Bar fun f() =\u003e var a: Foo = a.create() 来一个更骚的操作，上面例子中，我们用var a声明了一个Foo类型，然后直接使用a调用Foo的构造函数create()创建实例赋值给a。\n参数默认值（Default arguments） 在定义方法时，可以为参数提供默认值。调用者可以选择使用默认值，或者提供自己的值。参数的默认值在形参名后面用=指定。\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create() // Contains (0, 0) var b: Coord = Coord.create(3) // Contains (3, 0) var c: Coord = Coord.create(3, 4) // Contains (3, 4) 我必须为所有的参数提供默认值吗? 不需要，可以自己决定为哪些参数设置默认值。\n命名传参（Named arguments） 到目前为止，在调用方法时，我们总是按顺序给出所有参数。这被称为使用 位置传参或顺序传参（positional arguments） 。但是，我们也可以通过指定参数的名称来指定传参顺序。这被称为 命名传参或无序传参（named arguments）。\n要使用命名传参的方式调用方法，需要使用where关键字，然后是形参名和值。\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create(3, 4) // Contains (3, 4) var b: Coord = Coord.create(where y = 4, x = 3) // Contains (3, 4) 注意，上面示例中的b实例的创建，演示了如何使用where的用法。\n我需要为每个参数都指定一个where吗? 不需要。方法调用时只需要一个where。\n在方法的调用中可以同时使用命名传参和位置传参。从需要的位置开始，使用where关键字就可以了。但是要注意，每个参数只能指定一次。\n默认参数也可以与位置传参和命名传参结合使用——只需要忽略传递默认参数即可。\nclass Foo fun f(a: U32 = 1, b: U32 = 2, c: U32 = 3, d: U32 = 4, e: U32 = 5): U32 =\u003e 0 fun g() =\u003e f(6, 7 where d = 8) // Equivalent to: f(6, 7, 3, 8, 5) 使用位置传参调用方法是，是否忽略第一个参数? 不行。如果使用位置传参，没有设置默认值的参数必须放在前面。（注意：位置传参方式配合默认参数使用时，如果为方法的某个参数设置了默认值，后续的参数都必须给出默认值）。\n连续调用Chaining 方法链接允许您将对对象的调用链接起来，而不需要方法返回其接收器。调用一个方法并链接接收器的语法是object.\u003emethod()，它大致相当于(object.method() ; object)。连续调用方法时会丢弃它的正常返回值：\nprimitive Printer fun print_two_strings(out: StdStream, s1: String, s2: String) =\u003e out.\u003eprint(s1).\u003eprint(s2) // 等同于： out.print(s1) out.print(s2) out 注意，如果最后一次调用的返回值很重要的话，可以把.\u003e换成.。\ninterface Factory fun add_option(o: Option) fun make_object(): Object primitive Foo fun object_wrong(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).\u003emake_object() // 错误! 这个表达式返回的是`Facyory` fun object_right(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).make_object() // 正确。 这个表达式返回了一个`Object` 匿名方法（Anonymous methods） Pony中可以使用匿名方法（或者叫Lambdas）。看一下示例:\nuse \"collections\" actor Main new create(env: Env) =\u003e let list_of_numbers = List[U32].from([1; 2; 3; 4]) let is_odd = {(n: U32): Bool =\u003e (n % 2) == 1} let list_of_odd_numbers = list_of_numbers.filter(is_odd) for odd_number in list_of_odd_numbers.values() do env.out.print(odd_number.string()) end 在匿名对象中有更详细的介绍。\n私有方法（Privacy） 在Pony中，方法名只能以小写字母或下划线后跟小写字母开头。下划线开头的方法是私有的。它们只能被当前包中的代码调用。非下划线开头的方法是公有的，可以在外部(其他包)调用。\n我可以用2个(或更多)下划线来开始我的方法名吗? 不行。如果第一个字符是下划线，那么第二个字符必须是小写字母。\n调用优先级(Precedence) 我们之前已经讨论过运算符符优先级，在Pony中，方法调用和字段访问的优先级比所有的运算符都要高。\n我们来总结回顾一下,在复杂的表达式中:\n 方法调用和字段访问的优先级高于任何运算符符。 一元运算符具有比中缀运算符更高的优先级。 在复杂表达式中混合中缀运算符时，我们必须使用括号来显式地指定前缀。  ","summary":"在Pony中，所有的执行逻辑（代码）都被放在方法中。方法有三种：函数、构造函数和行为。所有的方法都要写在类型定义中（例如：类、基元类、actor等），不存在全局函数或全局行为。\n行为用于处理发送给参与者的异步消息，我们在类型系统章节中已经讲解过行为。\n可以像Python那样在任何方法之外添加一些代码吗？ 不行。所有的Pony代码都必须在一个方法中。\n函数（Functions） Pony的函数与其他语言中的函数（或方法）非常相似。它们可以具有0个或多个参数，以及0个或1个返回值（如果需要像Go语言的多返回值可以使用元组）。如果省略了返回类型，则该函数的返回值将为None。\nclass C fun add(x: U32, y: U32): U32 =\u003e x + y fun nop() =\u003e add(1, 2) // Pointless, we ignore the result 函数参数（如果有）在函数名称后的括号中指定。即便没有任何参数的函数定义时，括号也不能省略。\n每个参数都有一个名称和类型。在我们的示例函数中，add函数有两个参数x和y，它们都是U32类型。传递给函数调用的值（示例中为1和 2）称为实参（arguments），并且在进行调用时会对其求值并分配给形参（parameters）。形参虽然没有明确给出声明的方式，但实际上它们被声明为let。\n形参后面的的是返回类型。如果不需要返回值，可以省略。\n返回值后面是=\u003e，最后是函数体。返回值是函数体表达式的执行结果（请记住，所有内容都是表达式），也就是函数中最后一条表达式的值。\n如果想从函数中提前返回，可以使用return表达式。如果函数具有返回类型，需要为return提供一个值。如果该函数没有返回类型，单独用return就行。\n可以按参数类型重载函数吗？ 不行，同一个类型中不允许出现重名的方法。\n构造函数（Constructors） 跟其他语言一样，Pony的构造函数也是用于初始化对象。不同的是，Pony构造函数可以自定义函数名字，也可以使用任意数量和类型的参数。Pony的默认构造函数（所有的类型定义都一样）为create。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x 构造函数的作用，是为了在创建对象时初始化对象内部状态。Pony中构造函数必须对所有字段做出初始化。\n可以从构造函数中提前返回吗？ 是的。使用不带值的return命令。但是要确保return前所有字段都已经进行了初始化。\n方法调用（Calling） 方法的调用与其他语言一样，通过在方法名称后的括号内提供参数来调用。即使没有参数需要传递，也需要括号。\nclass Foo fun hello(name: String): String =\u003e \"hello \" + name fun f() =\u003e let a = hello(\"Fred\") 要实例化一个类型，需要调用这个类型的构造函数。指定类型，后跟一个点，然后是要调用的构造函数名：","title":"方法（Methods）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/methods.html"},{"content":"借用（recover）表达式允许你提升（lift）结果的引用权能。可变引用权能(iso、trn或ref)可以成为_any_引用权能，而不可变引用权能(val或box)可以成为任何不可变或不透明的引用权能。\nWhy is this useful? 借用（recover）最直接的用法是获得一个可以传递给另一个参与者的iso。但是它也可以用在很多其他的事情上，比如:\n*创建循环的不可变数据结构。也就是说，你可以在借用（recover）表达式中创建一个复杂的可变数据结构，将结果ref提升为val。 *借（Borrow）一个iso作为参考，对它进行一系列复杂的可变操作，然后再次以iso的形式返回。 *从iso中提取（Extract）一个可变字段，并将其作为iso返回。\nWhat does this look like? 借用（recover）表达式包装了一个表达式列表，并以end结尾，就像这样:\nrecover Array[String].create() end 借用表达式返回一个Array[String] iso，而不是Array[String] ref。它是iso而不是其他可变引用权能的原因是，当你不指定一个时，会有一个默认的引用权能。任何可变引用权能的默认值是iso，而任何不可变引用权能的默认值是val。\n下面是一个来自标准库的更复杂的例子:\nrecover var s = String((prec + 1).max(width.max(31))) var value = x try if value == 0 then s.push(table(0)?) else while value != 0 do let index = ((value = value / base) - (value * base)) s.push(table(index.usize())?) end end end _extend_digits(s, prec') s.append(typestring) s.append(prestring) _pad(s, width, align, fill) s end 从format/ _FormatInt。它创建了一个String ref，用它做了很多事情，最后返回一个String iso类型。\n你也可以给出一个明确的引用权能:\nlet key = recover val line.substring(0, i).\u003estrip() end 这是来自’net/http/_PayloadBuilder。我们得到一个line的子字符串，它是String iso^然后我们调用strip，它会返回自身。但是因为strip是一个ref函数，所以它以String ref^的形式返回自己——所以我们用recover val来结束一个String val`。\nHow does this work? 在借用（recover）表达式中，你的代码只能从封闭的词法作用域访问。换句话说，你只能使用iso、val和tag来自借用（recover）表达式外部的内容。\n这意味着当借用（recover）表达式结束时，除了iso、val和tag之外，表达式结果的任何别名都将不复存在。这使得提升表达式结果的引用权能变得安全。\n如果借用（recover）表达式可以从封闭的词法范围中访问非sendable__值，那么提升结果的引用权能就不安全了。其中一些值可能会泄漏到iso或val结果中，导致数据竞争。\nAutomatic receiver recovery 当你有一个iso或trn接收器，你通常不能调用ref方法。这是因为接收方也是方法的一个参数，这意味着方法主体和调用方可以同时访问接收方。_that意味着当我们调用一个方法时，我们必须别名化接收者。iso的别名是tag(不是ref的子类型)，trn的别名是box(也不是ref的子类型)。\n但我们可以避开这个!如果方法的所有参数(接收方除外，接收方是正在被借用（recover）的隐式参数)at call-site_都是_sendable_，并且方法的返回类型要么是_sendable__，要么在call-site_没有被使用，那么我们可以自动借用（recover）接收方。这只是意味着我们不需要别名接收器-这意味着我们可以调用ref方法的iso或trn，因为iso和trn都是ref的子类型。\n注意，这种技术主要关注调用站点，而不是被调用方法的定义。这使得它更加灵活。例如，如果被调用的方法需要一个ref参数，而我们给它传递了一个iso参数，那么在调用站点上它是_sendable__，因此我们仍然可以执行自动接收方借用（recover）。\n这听起来可能有点复杂，但在实践中，这意味着你可以编写将iso主要视为ref的代码，当它出错时，编译器将发出抱怨。例如:\nlet s = recover String end s.append(\"hi\") 在这里，我们创建一个String iso，然后附加一些文本到它。append方法接受一个ref接收器和一个box参数。我们可以自动借用（recover）iso接收器，因为我们传递了一个val参数，所以一切都很好。\n","summary":"借用（recover）表达式允许你提升（lift）结果的引用权能。可变引用权能(iso、trn或ref)可以成为_any_引用权能，而不可变引用权能(val或box)可以成为任何不可变或不透明的引用权能。\nWhy is this useful? 借用（recover）最直接的用法是获得一个可以传递给另一个参与者的iso。但是它也可以用在很多其他的事情上，比如:\n*创建循环的不可变数据结构。也就是说，你可以在借用（recover）表达式中创建一个复杂的可变数据结构，将结果ref提升为val。 *借（Borrow）一个iso作为参考，对它进行一系列复杂的可变操作，然后再次以iso的形式返回。 *从iso中提取（Extract）一个可变字段，并将其作为iso返回。\nWhat does this look like? 借用（recover）表达式包装了一个表达式列表，并以end结尾，就像这样:\nrecover Array[String].create() end 借用表达式返回一个Array[String] iso，而不是Array[String] ref。它是iso而不是其他可变引用权能的原因是，当你不指定一个时，会有一个默认的引用权能。任何可变引用权能的默认值是iso，而任何不可变引用权能的默认值是val。\n下面是一个来自标准库的更复杂的例子:\nrecover var s = String((prec + 1).max(width.max(31))) var value = x try if value == 0 then s.push(table(0)?) else while value != 0 do let index = ((value = value / base) - (value * base)) s.push(table(index.usize())?) end end end _extend_digits(s, prec') s.append(typestring) s.append(prestring) _pad(s, width, align, fill) s end 从format/ _FormatInt。它创建了一个String ref，用它做了很多事情，最后返回一个String iso类型。","title":"权能借用（Recovering Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html"},{"content":"子类型是关于_替换性的。也就是说，如果我们需要提供某一种类型，我们还可以替代什么类型?其中包括引用权能。\nSimple substitution 首先，让我们讨论替换，而不必担心临时类型(^)或别名类型(!)。符号\u003c:表示是的子类型，或者可以被替换。\n iso \u003c: trn。iso是_read和write unique_， trn是_write unique_，所以用iso代替trn是安全的。 trn \u003c: ref。一个trn是可变的，也_write unique_。ref是可变的，但不能保证唯一性。用trn代替ref是安全的。 trn \u003c: val。这个很有趣。trn是_write unique_， val是全局不可变的，那么为什么用trn代替val是安全的呢?关键是，为了做到这一点，你必须放弃你所拥有的一切。如果你放弃了_only_变量可以写一个对象，你知道没有变量可以写它。这意味着它是全局不变的。 ref \u003c: box。ref保证没有_other_actor可以读写对象。box只是保证没有_other_ actor可以写对象，所以用ref代替box是安全的。 val \u003c: box。一个val保证_no_actor，即使是这个，也不能写对象。一个box只是保证没有_other_ actor可以写对象，所以用val代替box是安全的。 box \u003c: tag。box保证没有其他参与者可以写入对象，而tag则完全没有保证，所以用box替换tag是安全的。  子类型化_transitive_。这意味着，由于iso \u003c: trn和trn \u003c: ref和ref \u003c: box，我们也得到iso \u003c: box。\nAliased substitution 现在让我们考虑一下当我们有一个引用权能的别名时会发生什么。例如，如果我们有一些iso，并对其进行别名处理(不执行消费或破坏性读取)，则得到的类型是iso!,而不是iso。\n*iso !\u003c:tag。这是一个相当大的变化。而不是像iso这样的所有东西的子类型，唯一的东西是iso!是tag的子类型。这是因为iso仍然存在，并且仍然是_read和write unique_。任何别名既不能从对象中读取，也不能从对象中写入。这意味着iso!'只能是tag的子类型。 *trn!\u003c:box。这也是一个变化，但并不是很大的变化。因为trn只是_write unique_，所以别名可以从对象中读取，但是别名不能写入对象。这意味着我们可以有box或val别名-除了val保证_no_ alias可以写入对象!因为我们的trn仍然存在，并可以写入对象，val别名将打破val作出的保证。所以一个ref!只能是box的子类型(及及物动词tag)。 *ref!\u003c:ref。由于ref只保证_other_ actor既不能从对象中读取也不能从对象中写入，所以可以在同一个actor中创建更多ref别名。 *val!\u003c:val。因为val只能保证_no_ actor可以写入对象，所以可以使用更多的val别名，因为它们也不能写入对象。 *box!\u003c:box。一个框只能保证_other_ actor不能写对象。val和ref都做了保证，那么为什么box只能别名为box呢?这是因为我们不能做更多的保证当我们别名的东西。这意味着box只能别名为box。 *tag!\u003c:tag。一个tag根本不能保证什么。就像框一样，我们不能在创建新别名时做更多的保证，因此tag只能作为tag的别名。\nEphemeral substitution 最后要考虑的情况是当我们有临时引用权能时。例如，如果我们有一些iso，我们'消费'它或做一个破坏性的阅读，我们得到的类型是iso^，而不是iso。\n iso^ \u003c: iso。这很简单。当我们给一个iso^一个名字时，通过把它赋值给某个东西或者把它作为参数传递给某个方法，它就会失去^而变成一个普通的旧的iso。我们知道我们已经放弃了之前的iso，所以换一个新的是安全的。 trn^ \u003c: trn。这和iso^ 完全一样。保证是较弱的(write uniqueness_而不是_read和write uniquess)，但它的工作方式是一样的。 ref^ \u003c: ref 和ref ^ \u003c: ref和ref \u003c: ref ^。这里，我们有另一个例子。a ref不仅是a ref的子类型，它也是a ref的子类型。这是怎么回事?原因是临时引用权能是在别名时产生基本引用权能的引用权能的一种说法。由于ref可以别名为ref，这意味着ref和ref^是完全可以互换的。  val^， box^， tag^。它们的工作方式都与ref相同，即可以与基本引用权能互换。原因是一样的:所有这些引用权能都可以作为它们自己的别名。  如果ref^、val^、box^和tag^可以与它们的基本引用权能互换，那么为什么还存在ref^、val^、box^和tag^呢?有两个原因:引用权能恢复__和一般__。这两个我们后面都会讲到。\n","summary":"子类型是关于_替换性的。也就是说，如果我们需要提供某一种类型，我们还可以替代什么类型?其中包括引用权能。\nSimple substitution 首先，让我们讨论替换，而不必担心临时类型(^)或别名类型(!)。符号\u003c:表示是的子类型，或者可以被替换。\n iso \u003c: trn。iso是_read和write unique_， trn是_write unique_，所以用iso代替trn是安全的。 trn \u003c: ref。一个trn是可变的，也_write unique_。ref是可变的，但不能保证唯一性。用trn代替ref是安全的。 trn \u003c: val。这个很有趣。trn是_write unique_， val是全局不可变的，那么为什么用trn代替val是安全的呢?关键是，为了做到这一点，你必须放弃你所拥有的一切。如果你放弃了_only_变量可以写一个对象，你知道没有变量可以写它。这意味着它是全局不变的。 ref \u003c: box。ref保证没有_other_actor可以读写对象。box只是保证没有_other_ actor可以写对象，所以用ref代替box是安全的。 val \u003c: box。一个val保证_no_actor，即使是这个，也不能写对象。一个box只是保证没有_other_ actor可以写对象，所以用val代替box是安全的。 box \u003c: tag。box保证没有其他参与者可以写入对象，而tag则完全没有保证，所以用box替换tag是安全的。  子类型化_transitive_。这意味着，由于iso \u003c: trn和trn \u003c: ref和ref \u003c: box，我们也得到iso \u003c: box。\nAliased substitution 现在让我们考虑一下当我们有一个引用权能的别名时会发生什么。例如，如果我们有一些iso，并对其进行别名处理(不执行消费或破坏性读取)，则得到的类型是iso!,而不是iso。\n*iso !\u003c:tag。这是一个相当大的变化。而不是像iso这样的所有东西的子类型，唯一的东西是iso!是tag的子类型。这是因为iso仍然存在，并且仍然是_read和write unique_。任何别名既不能从对象中读取，也不能从对象中写入。这意味着iso!'只能是tag的子类型。 *trn!\u003c:box。这也是一个变化，但并不是很大的变化。因为trn只是_write unique_，所以别名可以从对象中读取，但是别名不能写入对象。这意味着我们可以有box或val别名-除了val保证_no_ alias可以写入对象!因为我们的trn仍然存在，并可以写入对象，val别名将打破val作出的保证。所以一个ref!只能是box的子类型(及及物动词tag)。 *ref!\u003c:ref。由于ref只保证_other_ actor既不能从对象中读取也不能从对象中写入，所以可以在同一个actor中创建更多ref别名。 *val!\u003c:val。因为val只能保证_no_ actor可以写入对象，所以可以使用更多的val别名，因为它们也不能写入对象。 *box!\u003c:box。一个框只能保证_other_ actor不能写对象。val和ref都做了保证，那么为什么box只能别名为box呢?这是因为我们不能做更多的保证当我们别名的东西。这意味着box只能别名为box。 *tag!\u003c:tag。一个tag根本不能保证什么。就像框一样，我们不能在创建新别名时做更多的保证，因此tag只能作为tag的别名。\nEphemeral substitution 最后要考虑的情况是当我们有临时引用权能时。例如，如果我们有一些iso，我们'消费'它或做一个破坏性的阅读，我们得到的类型是iso^，而不是iso。\n iso^ \u003c: iso。这很简单。当我们给一个iso^一个名字时，通过把它赋值给某个东西或者把它作为参数传递给某个方法，它就会失去^而变成一个普通的旧的iso。我们知道我们已经放弃了之前的iso，所以换一个新的是安全的。 trn^ \u003c: trn。这和iso^ 完全一样。保证是较弱的(write uniqueness_而不是_read和write uniquess)，但它的工作方式是一样的。 ref^ \u003c: ref 和ref ^ \u003c: ref和ref \u003c: ref ^。这里，我们有另一个例子。a ref不仅是a ref的子类型，它也是a ref的子类型。这是怎么回事?","title":"权能包含关系（Capability Subtyping）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html"},{"content":"当一个对象的一个字段被读取时，它的引用权能既取决于字段的引用权能，也取决于_origin__的引用权能，也就是说，从该字段被读取的对象。\n这是因为对其字段所做的所有保证都必须对其字段进行维护。\n观点适应（Viewpoint adaptation） 将原始权能和字段权能相结合的过程称为 视角适应 。也就是说，origin 有一个 viewpoint ，并且只能从那个 viewpoint 中访问它的字段。\n下表展示了不同权能的 字段 看起来是如何与每个权能的 源 相匹配的。\n    ▷ iso field trn field ref field val field box field tag field     iso origin iso tag tag val tag tag   trn origin iso trn box val box tag   ref origin iso trn ref val box tag   val origin val val val val val tag   box origin tag box box val box tag   tag origin n/a n/a n/a n/a n/a n/a     例如，如果你有一个’ trn ‘原点，你读了一个’ ref ‘字段，你会得到一个’ box ‘结果:\nclass Foo var x: String ref class Bar fun f() =\u003e var y: Foo trn = get_foo_trn() var z: String box = y.x 解释了为什么（Explaining why） 最终，你会觉得这张桌子很自然。但可能还没有。为了让它看起来更自然，让我们遍历表中的每个单元格并解释为什么它是这样的。\n读取iso变量 任何通过“iso”来源读取的内容都必须保持来源的隔离保证。要记住的关键一点是，“iso”可以发送给另一个参与者，它也可以成为任何其他引用权能。因此，当我们读取一个字段时，我们需要得到一个结果，这个结果永远不会打破源所做的隔离保证，即_read和write uniqueness_。\n“iso”字段与“iso”源字段具有相同的保证，所以读起来没有问题。“val”字段是_global immutable_，这意味着它总是可以读取，不管它的来源是什么(好吧，除了“标签”)。\n然而，其他一切都可能打破我们的隔离保障。这就是为什么其他引用权能被视为“标记”:它是唯一一种既不可读又不可写的类型。\n读取trn变量 这就像“iso”，但有一个较弱的保证(write uniqueness_而不是_read和write uniqueness)。这是一个很大的不同，因为现在我们可以返回一些可读的东西，当我们执行我们的保证。\n“iso”字段比“trn”字段提供了更强的保证，而“trn”字段也提供了相同的保证，所以可以阅读它们。一个“val”字段是全局不可变的，所以这也是可以的。“box”字段是可读的，我们只保证_write的独特性，所以这也是可以的。\n不过，“ref”字段允许写入。因此我们返回一个“box”。\n读取ref变量 “ref”源根本不修改它的字段。这是因为’ ref ‘源不做任何与它的字段不兼容的保证。\n读取val变量 “val”源是深度的、全局不可变的，所以它的所有字段也是“val”。唯一的例外是’ tag ‘字段。因为我们不能读它，我们也不能保证没有人可以写它，所以它保持'标签’。\n读取box变量 一个“box”变量是局部不可变的。这意味着它可能通过其他变量(’ trn ‘或’ ref ‘)发生突变，但也有可能我们的’ box ‘变量是某个’ val ‘变量的别名。\n当我们读取一个字段时，我们需要返回一个与该字段兼容但也是局部不可变的引用权能。\n“iso”字段作为“标记”返回，因为没有本地不可变引用权能可以维护它的隔离保证。“val”字段作为“val”返回，因为全局不变性比局部不变性更能保证全局不变性。一个“box”字段与它的起源具有相同的局部不变性保证，所以这也是可以的。\n一个“box”变量是局部不可变的。这意味着它可能通过其他变量(’ trn ‘或’ ref ‘)发生突变，但也有可能我们的’ box ‘变量是某个’ val ‘变量的别名。\n读取tag变量 这个很简单:’ tag ‘变量是不透明的!它们不能被读出来。\n为对象的字段赋值 与读取字段一样，字段的赋值取决于存储的对象使用的引用权能和包含该字段的对象所属类型的引用权能类型。存储的对象的引用权能不能违反源对象的引用权能所作的保证。例如，val对象引用可以存储在iso源文件中。这是因为val引用权能保证不存在任何可能违反iso权能保证的对象别名。\n下面是上面表格的简化版本，它显示了哪些引用权能可以存储在原始对象的字段中。\n    ◁ iso object trn object ref object val object box object tag object     iso origin ✔   ✔  ✔   trn origin ✔ ✔  ✔  ✔   ref origin ✔ ✔ ✔ ✔ ✔ ✔   val origin         box origin         tag origin           这个图表的下半部分是空的，因为只有具有可变权能的起源才能修改它们的字段。\n","summary":"当一个对象的一个字段被读取时，它的引用权能既取决于字段的引用权能，也取决于_origin__的引用权能，也就是说，从该字段被读取的对象。\n这是因为对其字段所做的所有保证都必须对其字段进行维护。\n观点适应（Viewpoint adaptation） 将原始权能和字段权能相结合的过程称为 视角适应 。也就是说，origin 有一个 viewpoint ，并且只能从那个 viewpoint 中访问它的字段。\n下表展示了不同权能的 字段 看起来是如何与每个权能的 源 相匹配的。\n    ▷ iso field trn field ref field val field box field tag field     iso origin iso tag tag val tag tag   trn origin iso trn box val box tag   ref origin iso trn ref val box tag   val origin val val val val val tag   box origin tag box box val box tag   tag origin n/a n/a n/a n/a n/a n/a     例如，如果你有一个’ trn ‘原点，你读了一个’ ref ‘字段，你会得到一个’ box ‘结果:","title":"权能合并（Combining Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html"},{"content":"此时，您很可能已经阅读了本章前面的部分，仍然对引用权能之间的关系感到困惑。这是好的!当我们学习小马的这一部分时，我们也都很挣扎。一旦你开始编写小马代码，你就会对它们有一个更好的直觉。\n与此同时，如果您仍然觉得本章中的所有花絮仍在您的脑海中乱作一堆，那么有一种通常使用Pony提供的资源可以为您提供一种更直观的表示:即 引用权能矩阵（reference capability matrix）。\n它也是Pony中每个权能背后的概念的起源，意思是每个权能如何拒绝它所引用的某些属性——换句话说，这保证了权能的产生。在展示矩阵之前，我们会解释这到底是什么意思。\nLocal and global aliases 首先，我们要澄清\"本地\"和\"全局\"别名的含义。\n局部别名是对存在于同一参与者中的相同变量的引用。当你传递一个值的时候，它不是一个actor行为的参数，这是我们使用的别名。\n另一方面，全局别名是对可以存在于_different actor中的相同变量的引用。也就是说，它描述了两个或多个参与者如何与同一个引用交互的属性。\nPony中的每个引用权能实际上是一对局部保证和全局保证。例如，ref不否认参与者内部的任何读/写权能，但否认其他参与者对该引用的读或写权能。\n您可能还记得在[Reference Capability guarantee](guarantee .md)一节中提到，易变的引用不能在参与者之间安全地共享，而不可变的引用可以由多个参与者读取。一般来说，全局属性总是与引用的局部属性具有相同或更严格的限制—全局拒绝的内容也必须在局部拒绝。例如，不可能以全局或本地别名写入不可变引用。也不可能从不透明的引用tag读取或写入。因此，局部和全局别名的某些组合是不可能的，并且没有指定的权能。\nReference capability matrix 言归正传，下面是引用权能矩阵:\n      Deny global read/write aliases Deny global write aliases Don’t deny any global aliases     Deny local read/write aliases iso     Deny local write aliases trn val    Don’t deny any local aliases ref box tag     (Mutable) (Immutable) (Opaque)     在矩阵的上下文中，“拒绝某个权能\"意味着不允许该引用的任何其他别名执行该操作。例如，由于trn拒绝其他本地写别名(但允许读)，所以这是惟一允许对对象进行写的引用;由于它同时拒绝向其他参与者写入和读取别名，所以在这个actor中写入别名是安全的，因此是可变的。由于box不会破坏trn所做的任何保证(允许本地读取，但禁止全局写入)，所以我们可以为trn引用创建box别名。\n你会发现右上角是空的。这是因为，正如前面所讨论的，我们不能做出比全局保证更具限制性的任何局部保证，否则我们将以无效的权能结束，这些权能可以在这个actor中写入，但同时读取其他内容。\n矩阵还有助于可视化其他概念之前在本章讨论:\n Sendable capabilities。如果我们希望将引用发送给不同的参与者，我们必须确保全局别名和本地别名做出相同的保证。将trn发送给另一个演员是不安全的，因为我们可能在本地保存box引用。只有iso、val和tag具有相同的全局和局部限制—所有这些都在矩阵的主对角线上。 Ephemeral subtyping。如果我们有一个临时的权能(例如，iso^在使用了一个单独的变量之后)，我们可以对新的别名更加宽容，例如删除限制，例如允许本地别名具有读取权能，并将引用接收到一个trn^;或者是读和写，这给了我们ref。对于更多的全局别名也是如此，我们可以得到val、box或tag。从视觉上看，这相当于从矩阵的权能开始向下走和/或向右走。 Recovering capabilities。这就是我们提升一个权能的时候，从一个可变的引用提升到iso，或者从一个不可变的引用提升到val。矩阵等价物将会从权能开始向上走-在这种情况下相当字面地提升。 Aliasing。想象一下，你可以把iso和trn的别名分别映射到矩阵的次对角线上的tag和box上。其原因在于哪些限制是由地方担保产生的。iso不允许不同的别名读取或写入，而标签则强制执行;trn不允许不同的别名写入，但允许他们做本地读取，符合box的限制。  我们想要强调的是，试图将引用权能矩阵应用于某些权能问题并不能保证一定有效(视点适应就是一个例子)。矩阵是引用权能的原始定义，在这里作为助记设备给出。每当您遇到引用权能方面的困难时，我们建议您重新阅读本章相应的部分，以理解为什么编译器不允许某些东西。\n","summary":"此时，您很可能已经阅读了本章前面的部分，仍然对引用权能之间的关系感到困惑。这是好的!当我们学习小马的这一部分时，我们也都很挣扎。一旦你开始编写小马代码，你就会对它们有一个更好的直觉。\n与此同时，如果您仍然觉得本章中的所有花絮仍在您的脑海中乱作一堆，那么有一种通常使用Pony提供的资源可以为您提供一种更直观的表示:即 引用权能矩阵（reference capability matrix）。\n它也是Pony中每个权能背后的概念的起源，意思是每个权能如何拒绝它所引用的某些属性——换句话说，这保证了权能的产生。在展示矩阵之前，我们会解释这到底是什么意思。\nLocal and global aliases 首先，我们要澄清\"本地\"和\"全局\"别名的含义。\n局部别名是对存在于同一参与者中的相同变量的引用。当你传递一个值的时候，它不是一个actor行为的参数，这是我们使用的别名。\n另一方面，全局别名是对可以存在于_different actor中的相同变量的引用。也就是说，它描述了两个或多个参与者如何与同一个引用交互的属性。\nPony中的每个引用权能实际上是一对局部保证和全局保证。例如，ref不否认参与者内部的任何读/写权能，但否认其他参与者对该引用的读或写权能。\n您可能还记得在[Reference Capability guarantee](guarantee .md)一节中提到，易变的引用不能在参与者之间安全地共享，而不可变的引用可以由多个参与者读取。一般来说，全局属性总是与引用的局部属性具有相同或更严格的限制—全局拒绝的内容也必须在局部拒绝。例如，不可能以全局或本地别名写入不可变引用。也不可能从不透明的引用tag读取或写入。因此，局部和全局别名的某些组合是不可能的，并且没有指定的权能。\nReference capability matrix 言归正传，下面是引用权能矩阵:\n      Deny global read/write aliases Deny global write aliases Don’t deny any global aliases     Deny local read/write aliases iso     Deny local write aliases trn val    Don’t deny any local aliases ref box tag     (Mutable) (Immutable) (Opaque)     在矩阵的上下文中，“拒绝某个权能\"意味着不允许该引用的任何其他别名执行该操作。例如，由于trn拒绝其他本地写别名(但允许读)，所以这是惟一允许对对象进行写的引用;由于它同时拒绝向其他参与者写入和读取别名，所以在这个actor中写入别名是安全的，因此是可变的。由于box不会破坏trn所做的任何保证(允许本地读取，但禁止全局写入)，所以我们可以为trn引用创建box别名。","title":"权能矩阵（Reference Capability Matrix）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-matrix.html"},{"content":"Pony能力的一个重要部分就是能够说\"我已经完成了这件事。“我们将介绍处理这种情况的两种方法:使用变量和破坏性读取。\n权能转让（Consuming a variable） 有时，你希望将对象从一个变量移动到另一个变量。换句话说，你不希望为对象创建一个_new_名称，确切地说，你希望将对象从某个现有名称移动到另一个不同的名称。\n你可以通过使用转让（consume）来做到这一点。当你转让（consume）一个变量时，你将从中取出该变量的值，实际上是将该变量留空。在向该变量写入新值之前，任何代码都不能再次读取该变量。使用局部变量或参数允许你使用相同类型的别名，即使它是iso或trn。例如:\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! 编译器对此很高兴，因为通过使用a，你已经说过该值不能再次使用，如果你尝试使用，编译器将会抱怨。\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! var c: Wombat tag = a // Not allowed! 这里有一个例子。当你试图把a赋值给c时，编译器会报错。\n我可以转让（consume）一个字段吗?__当然不行!转让（consume）意味着它是空的，也就是说，它没有价值。无法确保对象的其他别名不会访问该字段。如果我们试图访问一个空字段，我们会崩溃。但是有一种方法可以做你想做的:destructive read。\n破坏性读取（Destructive read） 还有一种方法可以将值从一个名称移动到另一个名称。在前面，我们讨论了Pony中的赋值如何返回左侧的_old_值，而不是新值。这叫做_destructive read_，我们可以用它来做我们想做的事情，即使是字段。\nclass Aardvark var buddy: Wombat iso new create() =\u003e buddy = recover Wombat end fun ref test(a: Wombat iso) =\u003e var b: Wombat iso = buddy = consume a // Allowed! 在这里，我们使用a，将它分配给buddy字段，并将buddy的_old_值分配给b。\n为什么当我们不能使用字段时，可以销毁它们呢?因为当我们做一个破坏性的读取时，我们给字段赋值，所以它总是有一个值。不像转让（consume），没有时间当字段是空的。这意味着它是安全的，编译器不会报错。\n","summary":"Pony能力的一个重要部分就是能够说\"我已经完成了这件事。“我们将介绍处理这种情况的两种方法:使用变量和破坏性读取。\n权能转让（Consuming a variable） 有时，你希望将对象从一个变量移动到另一个变量。换句话说，你不希望为对象创建一个_new_名称，确切地说，你希望将对象从某个现有名称移动到另一个不同的名称。\n你可以通过使用转让（consume）来做到这一点。当你转让（consume）一个变量时，你将从中取出该变量的值，实际上是将该变量留空。在向该变量写入新值之前，任何代码都不能再次读取该变量。使用局部变量或参数允许你使用相同类型的别名，即使它是iso或trn。例如:\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! 编译器对此很高兴，因为通过使用a，你已经说过该值不能再次使用，如果你尝试使用，编译器将会抱怨。\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! var c: Wombat tag = a // Not allowed! 这里有一个例子。当你试图把a赋值给c时，编译器会报错。\n我可以转让（consume）一个字段吗?__当然不行!转让（consume）意味着它是空的，也就是说，它没有价值。无法确保对象的其他别名不会访问该字段。如果我们试图访问一个空字段，我们会崩溃。但是有一种方法可以做你想做的:destructive read。\n破坏性读取（Destructive read） 还有一种方法可以将值从一个名称移动到另一个名称。在前面，我们讨论了Pony中的赋值如何返回左侧的_old_值，而不是新值。这叫做_destructive read_，我们可以用它来做我们想做的事情，即使是字段。\nclass Aardvark var buddy: Wombat iso new create() =\u003e buddy = recover Wombat end fun ref test(a: Wombat iso) =\u003e var b: Wombat iso = buddy = consume a // Allowed!","title":"权能转让和破坏性读取（Consume and Destructive Read）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html"},{"content":"柯里化（Partial Application）允许我们对构造函数、函数或行为设置 部分 参数，然后返回一个新函数，以便后面再填充其余的参数。\n一个简单的例子 这里有一个简单的例子，创建一个回调函数。例如:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) 这是一个有点傻的示例，但希望，思路是清楚的。我们在foo上柯里化了addmul函数，把接收者绑定到foo上，把add参数绑定为3。我们得到一个返回值它是一个匿名对象：f，它有一个apply方法，接受一个mul参数。当它被调用时，它执行foo.addmul (3,mul)。\n我们也可以绑定所有的参数：\nlet f = foo~addmul(3, 4) f() 也不提绑定任何实参：\nlet f = foo~addmul() f(3, 4) 命名传参（之前讲过的无序传参方式） 命名传参的方式允许柯里化（Partial Application）以任意顺序绑定参数，而不只是从左到右。例如:\nlet f = foo~addmul(where mul = 4) f(3) 在这里，我们绑定了mul参数，但未绑定add。\n对柯里化函数进行柯里化（Partially applying a partial application） 由于柯里化（Partial Application）会返回一个一个带有apply方法的匿名对象，所以我们对它的返回值再次进行柯里化！\nlet f = foo~addmul() let f2 = f~apply(where mul = 4) f2(3) 柯里化的返回值是一个匿名对象（Partial application is an object literal） 底层实现上，柯里化（Partial Application）会自动封装为一个匿名对象。它捕获从作用域中捕获字段，并有一个apply方法，该方法接受一些参数。这一切都是是在编译阶段，将柯里化的抽象语法树翻译为匿名对象来实现的。\n这意味着柯里化（Partial Application）将生成一个匿名类并返回一个ref权限的匿名对象。如果你需要其他引用权能，可以将柯里化（Partial Application）封装在一个recover表达式中。\n","summary":"柯里化（Partial Application）允许我们对构造函数、函数或行为设置 部分 参数，然后返回一个新函数，以便后面再填充其余的参数。\n一个简单的例子 这里有一个简单的例子，创建一个回调函数。例如:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) 这是一个有点傻的示例，但希望，思路是清楚的。我们在foo上柯里化了addmul函数，把接收者绑定到foo上，把add参数绑定为3。我们得到一个返回值它是一个匿名对象：f，它有一个apply方法，接受一个mul参数。当它被调用时，它执行foo.addmul (3,mul)。\n我们也可以绑定所有的参数：\nlet f = foo~addmul(3, 4) f() 也不提绑定任何实参：\nlet f = foo~addmul() f(3, 4) 命名传参（之前讲过的无序传参方式） 命名传参的方式允许柯里化（Partial Application）以任意顺序绑定参数，而不只是从左到右。例如:\nlet f = foo~addmul(where mul = 4) f(3) 在这里，我们绑定了mul参数，但未绑定add。","title":"柯里化（Partial Application）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/partial-application.html"},{"content":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them. All Pony source files have an implicit use \"builtin\" command. This means all the types defined in the package builtin are automatically available in the type namespace of all Pony source files.\nDocumentation for the standard library is available online\n","summary":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them.","title":"标准库（Standard Library）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/standard-library.html"},{"content":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, ! and much more.\n","summary":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, !","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/appendices.html"},{"content":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features. Calling well written, bug-free, C code will have no ill effects on your program. However, calling buggy or malicious C code or calling C incorrectly can cause your Pony program to go wrong, including corrupting data and crashing. Consequently, all of the Pony guarantees regarding not crashing, memory safety and concurrent correctness can be voided by calling FFI functions.\n","summary":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi.html"},{"content":"本章介绍Pony语言的各种表达方式。从变量到流程控制等内容。\n","summary":"本章介绍Pony语言的各种表达方式。从变量到流程控制等内容。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions.html"},{"content":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters. The parameters for a generic class are types. Parameters are introduced to a class using square brackets.\nTake the following example of a non-generic class:\nclass Foo var _c: U32 new create(c: U32) =\u003e _c = c fun get(): U32 =\u003e _c fun ref set(c: U32) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) This class only works for the type U32, a 32 bit unsigned integer. We can make this work over other types by making the type a parameter to the class. For this example it looks like:\nclass Foo[A: Any val] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) let b = Foo[F32](1.5) env.out.print(b.get().string()) let c = Foo[String](\"Hello\") env.out.print(c.get().string()) The first thing to note here is that the Foo class now takes a type parameter in square brackets, [A: Any val]. That syntax for the type parameter is:\nName: Constraint ReferenceCapability  In this case, the name is A, the constraint is Any and the reference capability is val. Any is used to mean that the type can be any type - it is not constrained. The remainder of the class definition replaces U32 with the type name A.\nThe user of the class must provide a type when referencing the class name. This is done when creating it:\nlet a = Foo[U32](42) let b = Foo[F32](1.5) let c = Foo[String](\"Hello\") That tells the compiler what specific class to create, replacing A with the type provided. For example, a Foo[String] usage becomes equivalent to:\nclass FooString var _c: String val new create(c: String val) =\u003e _c = c fun get(): String val =\u003e _c fun ref set(c: String val) =\u003e _c = c Generic Methods Methods can be generic too. They are defined in the same way as normal methods but have type parameters inside square brackets after the method name:\nprimitive Foo fun bar[A: Stringable val](a: A): String =\u003e a.string() actor Main new create(env:Env) =\u003e let a = Foo.bar[U32](10) env.out.print(a.string()) let b = Foo.bar[String](\"Hello\") env.out.print(b.string()) This example shows a constraint other than Any. The Stringable type is any type with a string() method to convert to a String.\nThese examples show the basic idea behind generics and how to use them. Real world usage gets quite a bit more complex and the following sections will dive deeper into how to use them.\n","summary":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/generics.html"},{"content":"本章将带你开始使用Pony，安装编译器运行第一个程序。\n在本教程的学习过程中，你可能会遇到已经熟悉的概念，想跳过这些章节完全没问题。\n不过，如果你第一次接触Pony肯定会遇到陌生的概念，如果想使用Pony，你需要特别！特别！！注意：引用权能章节。引用权能 是Pony的核心，凭借着特立独行的思想使Pony在现代编程语言的中脱颖而出。\n在本教程从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其介绍。阅读过程中，强烈建议你将教程中的代码在自己的编辑器中敲一遍。注意，当你冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全文，得先彻底理解 引用权能 。学习过程中配合编译器一起使用，可以验证教程中代码示例，加深理解。\n或许你正急着阅读后面的章节，稍微花点时间读完入门章节，了解下社区为你提供了哪些帮助，可以少走一些弯路。学习Pony会改变你对并发问题的看法。\n","summary":"本章将带你开始使用Pony，安装编译器运行第一个程序。\n在本教程的学习过程中，你可能会遇到已经熟悉的概念，想跳过这些章节完全没问题。\n不过，如果你第一次接触Pony肯定会遇到陌生的概念，如果想使用Pony，你需要特别！特别！！注意：引用权能章节。引用权能 是Pony的核心，凭借着特立独行的思想使Pony在现代编程语言的中脱颖而出。\n在本教程从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其介绍。阅读过程中，强烈建议你将教程中的代码在自己的编辑器中敲一遍。注意，当你冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全文，得先彻底理解 引用权能 。学习过程中配合编译器一起使用，可以验证教程中代码示例，加深理解。\n或许你正急着阅读后面的章节，稍微花点时间读完入门章节，了解下社区为你提供了哪些帮助，可以少走一些弯路。学习Pony会改变你对并发问题的看法。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started.html"},{"content":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results. Probably the best way to approach this chapter is to imagine each section has a giant flashing “DO NOT DO THIS” sign.\n","summary":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas.html"},{"content":"如果您正在按顺序阅读本教程，那么您刚刚完成了参考功能一章，您的大脑可能会感到疼痛。我们对此表示抱歉。希望对象能力，虽然是一个新概念，是较少的精神弯曲。\n我们在之前的教程中提到过对象功能，本章将深入探讨。那么，什么是对象功能？\n能力是做\"某事\"的能力。通常，“某物\"涉及您可能希望访问的外部资源;比如文件系统或网络。这称为对象功能。对象功能已经出现在许多编程语言中，包括E。\n","summary":"如果您正在按顺序阅读本教程，那么您刚刚完成了参考功能一章，您的大脑可能会感到疼痛。我们对此表示抱歉。希望对象能力，虽然是一个新概念，是较少的精神弯曲。\n我们在之前的教程中提到过对象功能，本章将深入探讨。那么，什么是对象功能？\n能力是做\"某事\"的能力。通常，“某物\"涉及您可能希望访问的外部资源;比如文件系统或网络。这称为对象功能。对象功能已经出现在许多编程语言中，包括E。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities.html"},{"content":"","summary":"","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/packages.html"},{"content":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.\n","summary":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching.html"},{"content":"我们已经介绍了Pony的类型系统的基础知识，然后是表达式，这一章关于引用权能将介绍Pony的类型系统的另一个特性。目前还没有任何主流编程语言具有引用权能。什么是引用权能?\n引用权能是建立在能力这个概念上的。 能力是做某事的能力。通常，某物涉及您可能希望访问的外部资源;比如文件系统或网络。这种能力的使用被称为对象能力，在下一章中将对此进行讨论。\nPony还有一种不同的功能，称为引用权能。对象功能是指被授予使用对象执行操作的能力，而引用权能是指拒绝使用内存引用执行操作的能力。例如，“你可以访问这个内存，但只能读取它。你不能向它发送消息”。这是一个引用权能，它拒绝你做事情。\n引用权能是Pony与众不同的核心。你可能还记得在本教程的介绍中我们说过的Pony:\n 它是类型安全的。类型安全。有一个数学证明和一切。 它是内存安全的。这个带有类型安全，但仍然很有趣。没有悬空指针，没有缓冲区溢出，糟糕的是，这种语言甚至没有_null_的概念! 它是异常安全的。没有运行时异常。所有的异常都有定义的语义，它们总是被处理。 数据竞争。Pony没有锁或原子操作或任何类似的东西。相反，类型系统确保_at编译时您的并发程序永远不会发生数据竞争。因此，您可以编写高度并发的代码，并且永远不会出错。 没有死锁。这个很简单，因为Pony根本没有锁!所以它们肯定不会死锁，因为它们不存在。  引用权能使所有这些都成为可能。\n本章中的代码示例可能比较少，因为我们主要处理的是更高级的概念。在把这些想法付诸实践之前，试着至少通读一遍这一章。在完成本章之前，您应该已经开始了解什么是引用权能以及如何使用它们。如果你一开始就和他们斗争，不要担心。对于大多数人来说，这是一种思考代码的新方式，需要一段时间才能掌握。如果你在努力提高自己的能力时遇到了困难，一定要寻求帮助。一旦你使用了几周，功能上的问题就开始消失了，但在那之前可能是一个真正的斗争。别担心，我们都经历过这种挣扎。事实上，Pony网站上有一节专门介绍可以帮助学习引用权能的资源(https://www.ponylang.io/learn/#reference-capabilities)。无论如何，向Pony社区寻求帮助。我们在这里帮助您克服引用权能学习曲线。这并不容易。我们都知道。这对人们来说是一种新的思维方式，所以请伸出你的手(https://ponylang.zulipchat.com/#narrow/stream/189985-beginner-help)。我们在等你的消息。\n害怕吗?不要。准备好了吗?好。让我们开始吧。\n","summary":"我们已经介绍了Pony的类型系统的基础知识，然后是表达式，这一章关于引用权能将介绍Pony的类型系统的另一个特性。目前还没有任何主流编程语言具有引用权能。什么是引用权能?\n引用权能是建立在能力这个概念上的。 能力是做某事的能力。通常，某物涉及您可能希望访问的外部资源;比如文件系统或网络。这种能力的使用被称为对象能力，在下一章中将对此进行讨论。\nPony还有一种不同的功能，称为引用权能。对象功能是指被授予使用对象执行操作的能力，而引用权能是指拒绝使用内存引用执行操作的能力。例如，“你可以访问这个内存，但只能读取它。你不能向它发送消息”。这是一个引用权能，它拒绝你做事情。\n引用权能是Pony与众不同的核心。你可能还记得在本教程的介绍中我们说过的Pony:\n 它是类型安全的。类型安全。有一个数学证明和一切。 它是内存安全的。这个带有类型安全，但仍然很有趣。没有悬空指针，没有缓冲区溢出，糟糕的是，这种语言甚至没有_null_的概念! 它是异常安全的。没有运行时异常。所有的异常都有定义的语义，它们总是被处理。 数据竞争。Pony没有锁或原子操作或任何类似的东西。相反，类型系统确保_at编译时您的并发程序永远不会发生数据竞争。因此，您可以编写高度并发的代码，并且永远不会出错。 没有死锁。这个很简单，因为Pony根本没有锁!所以它们肯定不会死锁，因为它们不存在。  引用权能使所有这些都成为可能。\n本章中的代码示例可能比较少，因为我们主要处理的是更高级的概念。在把这些想法付诸实践之前，试着至少通读一遍这一章。在完成本章之前，您应该已经开始了解什么是引用权能以及如何使用它们。如果你一开始就和他们斗争，不要担心。对于大多数人来说，这是一种思考代码的新方式，需要一段时间才能掌握。如果你在努力提高自己的能力时遇到了困难，一定要寻求帮助。一旦你使用了几周，功能上的问题就开始消失了，但在那之前可能是一个真正的斗争。别担心，我们都经历过这种挣扎。事实上，Pony网站上有一节专门介绍可以帮助学习引用权能的资源(https://www.ponylang.io/learn/#reference-capabilities)。无论如何，向Pony社区寻求帮助。我们在这里帮助您克服引用权能学习曲线。这并不容易。我们都知道。这对人们来说是一种新的思维方式，所以请伸出你的手(https://ponylang.zulipchat.com/#narrow/stream/189985-beginner-help)。我们在等你的消息。\n害怕吗?不要。准备好了吗?好。让我们开始吧。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities.html"},{"content":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.\n","summary":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/testing.html"},{"content":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。\n","summary":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/types.html"},{"content":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony. In particular, materials to help you grapple with reference capabilities.\n“Learn” on Ponylang.io\nPlanet Pony We don’t have an automatic blog aggregator but wish we did. In the meantime, we have a hand-curated list of videos, blog posts etc that would be of interest to members of the Pony community. Just beware when you are checking out older posts, it’s quite possible that their examples no longer compile as Pony development is currently moving very quickly.\nPlanet Pony\nPony Patterns Pony Patterns\n标准库文档 标准库文档\nPonylang Zulip Pony Zulip\nPony Virtual Users’ Group The Pony Virtual Users’ Group has occassional presentations that you can attend “in person” or catch later via the recorded video. Join our Zulip community to stay up to date on upcoming meetings. All the previous videos are available via Sean T Allen’s Vimeo account.\nA final word We’re immensely happy that you have taken the time to start learning Pony. It’s still a new and immature language with plenty of sharp pointy edges. You are going to get frustrated at times. Don’t worry, it has happened to all of us. Drop by one of our support channels and someone will try to lend a hand. We want you to succeed. The more people who succeed with Pony, the more the community grows and the better it is for all of us.\nWelcome to the community! Have fun!\n","summary":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/where-next.html"},{"content":"Pony有两种形式的平等:结构平等和身份平等。\n类型比较（Identity equality） Pony中的类型检查是通过is关键字来完成的。is可以判断两个类型是否相同。\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP! TRUE! end 结构化比较（Structural equality） Pony的结构化比较是通过中缀运算符==来完成的。它可以判断同的数据是否具有相同的值。如果被比较结果为true，可以认为它们具有相同的值。\n可以通过实现fun eq(that: box-\u003eFoo): Bool来自定义对比逻辑。注意，因为==是一个中缀操作符，eq必须定义在左边的操作数上，而右边的操作数必须是Foo类型。\nclass Foo let _a: String new create(a: String) =\u003e _a = a fun eq(that: box-\u003eFoo): Bool =\u003e this._a == that._a actor Main new create(e: Env) =\u003e let a = Foo(\"hi\") let b = Foo(\"bye\") let c = Foo(\"hi\") if a == b then // won't print e.out.print(\"1\") end if a == c then // will print e.out.print(\"2\") end if a is c then // won't print e.out.print(\"3\") end 如果没有定义自己的eq，Pony将会提供一个默认实现，该实现只是简单的对比类型是否相同。\ninterface Equatable[A: Equatable[A] #read] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) 基元类的类型比较（Primitives and equality） 你可能还记得在第二章：基元类中讲过，除了两个重要的区别之外，基元类与类有两个重要区别:\n 基元类没有字段。 所有用户自定义的基元类只会有一个实例。  这意味着，同类型的基元类实例在结构上总是相等的，并且是完全相等。例如，所有的None都是同一个实例。\nif None is None then // this is always true end if None == None then // this is also always true end ","summary":"Pony有两种形式的平等:结构平等和身份平等。\n类型比较（Identity equality） Pony中的类型检查是通过is关键字来完成的。is可以判断两个类型是否相同。\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP! TRUE! end 结构化比较（Structural equality） Pony的结构化比较是通过中缀运算符==来完成的。它可以判断同的数据是否具有相同的值。如果被比较结果为true，可以认为它们具有相同的值。\n可以通过实现fun eq(that: box-\u003eFoo): Bool来自定义对比逻辑。注意，因为==是一个中缀操作符，eq必须定义在左边的操作数上，而右边的操作数必须是Foo类型。\nclass Foo let _a: String new create(a: String) =\u003e _a = a fun eq(that: box-\u003eFoo): Bool =\u003e this.","title":"比较（Equality in Pony）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/equality.html"},{"content":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:\n// Note - this won't compile class Foo[A] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) Unfortunately, this doesn’t compile. For a generic class to compile it must be compilable for all possible types and reference capabilities that satisfy the constraints in the type parameter. In this case, that’s any type with any reference capability. The class works for the specific reference capability of val as we saw earlier, but how well does it work for ref? Let’s expand it and see:\n// Note - this also won't compile class Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): String ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) This does not compile. The compiler complains that get() doesn’t actually return a String ref, but this-\u003eString ref. We obviously need to simply change the type signature to fix this, but what is going on here? this-\u003eString ref is an arrow type. An arrow type with “this-\u003e” states to use the capability of the actual receiver (ref in our case), not the capability of the method (which defaults to box here). According to viewpoint adaption this will be ref-\u003eref which is ref. Without this arrow type we would only see the field _c as box because we are in a box method.\nSo let’s apply what we just learned:\nclass Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): this-\u003eString ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) That compiles and runs, so ref is valid now. The real test though is iso. Let’s convert the class to iso and walk through what is needed to get it to compile. We’ll then revisit our generic class to get it working:\nAn iso specific class // Note - this won't compile class Foo var _c: String iso new create(c: String iso) =\u003e _c = c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) This fails to compile. The first error is:\nmain.pony:5:8: right side must be a subtype of left side _c = c ^ Info: main.pony:4:17: String iso! is not a subtype of String iso: iso! is not a subtype of iso new create(c: String iso) =\u003e ^ The error is telling us that we are aliasing the String iso - The ! in iso! means it is an alias of an existing iso. Looking at the code shows the problem:\nnew create(c: String iso) =\u003e _c = c We have c as an iso and are trying to assign it to _c. This creates two aliases to the same object, something that iso does not allow. To fix it for the iso case we have to consume the parameter. The correct constructor should be:\nnew create(c: String iso) =\u003e _c = consume c A similar issue exists with the set method. Here we also need to consume the variable c that is passed in:\nfun set(c: String iso) =\u003e _c = consume c Now we have a version of Foo that is working correctly for iso. Note how applying the arrow type to the get method also works for iso. But here the result is a different one, by applying viewpoint adaptation we get from ref-\u003eiso (with ref being the capability of the receiver, the Foo object referenced by a) to iso. Through the magic of automatic receiver recovery we can call the string method on it:\nclass Foo var _c: String iso new create(c: String iso) =\u003e _c = consume c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) A capability generic class Now that we have iso working we know how to write a generic class that works for iso and it will work for other capabilities too:\nclass Foo[A] var _c: A new create(c: A) =\u003e _c = consume c fun get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo[String iso](\"Hello\".clone()) env.out.print(a.get().string()) let b = Foo[String ref](recover ref \"World\".clone() end) env.out.print(b.get().string()) let c = Foo[U8](42) env.out.print(c.get().string()) It’s quite a bit of work to get a generic class or method to work across all capability types, in particular for iso. There are ways of restricting the generic to subsets of capabilities and that’s the topic of the next section.\n","summary":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:","title":"泛型和引用权能（Generics and Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generics-and-reference-capabilities.html"},{"content":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic. The valid qualifiers are:\n   ▷ Capabilities allowed Description     #read ref, val, box Anything you can read from   #send iso, val, tag Anything you can send to an actor   #share val, tag Anything you can send to more than one actor   #any iso, trn, ref, val, box, tag Default of a constraint   #alias ref, val, box, tag Set of capabilities that alias as themselves (used by compiler)    In the previous section, we went through extra work to support iso. If there’s no requirement for iso support we can use #read and support ref, val, and box:\nclass Foo[A: Any #read] var _c: A new create(c: A) =\u003e _c = c fun ref get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[String ref](recover ref \"hello\".clone() end) env.out.print(a.get().string()) let b = Foo[String val](\"World\") env.out.print(b.get().string()) ","summary":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic.","title":"泛型约束（Constraints）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generic-constraints.html"},{"content":"在程序开发过程中，你需要能够对条件做出判断，对集合进行遍历，或者重复执行一些逻辑。因此，流程控制必不可少。Pony具有你在其他语言中所熟悉的流程控制控制，例如if，while和for，但是在Pony中，它们的工作方式略有不同。\n条件判断（Conditionals） if是最简单的流程控制控制。它仅在条件为真时才允许您执行某些操作。在Pony中的用法：\nif a \u003e b then env.out.print(\"a is bigger\") end 可以像在C语言中那样使用整数和指针作为条件吗？ 不行。在Pony中，if条件必须是布尔类型，即条件的返回值值始终为true或false。如果要判断数字a是否不为0，则需要明确的使用a！= 0。这个限制让Pony程序避免了潜在的类型错误。\n需要在条件失败时的执行一些逻辑，只需添加一个else：\nif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"a is not bigger\") end 通常，您想要检测和处理多种条件，可以嵌套if语句，但这有点丑陋：\nif a == b then env.out.print(\"they are the same\") else if a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end end 作为替代方案，Pony提供了结合了else和if的elseif关键字。这与其他语言中else if相同，并且每个if可以有任意数量的elseif：\nif a == b then env.out.print(\"they are the same\") elseif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end 为什么不能像在C语言中那样用else if？为什么要用新的关键字？ C和其他类似语言中的if和else之间的关系是模棱两可的。例如：\n// C code if(a) if(b) printf(\"a and b\\n\"); else printf(\"not a\\n\"); 上面的示例中，else到底归属于第一个还是第二个if有点让人困惑。实际上，else归属与if(b)，显然示例里面else语句本意是想归属于if(a)。Pony通过以不同的方式处理if和else来避免此类错误，那就是elseif。\n一切皆表达式（Everything is an expression） Pony的流程控制与其他语言的最大区别在于，在Pony中，一切都是表达式。在C++和Java这样的语言中，if是语句，而不是表达式。这意味着您不能在表达式中包含if，而必须有一个单独的条件运算符？（三目运算符 a ? b : c）。\n在Pony中，不存在语句的概念，只有表达式，所有东西都有返回一个值。if表达式是一个求值过程。for循环表达式也（稍后再讨论）也是如此。\n这意味着您可以在计算中直接使用if：\nx = 1 + if lots then 100 else 2 end 通过变量 lots ，为 x 赋值为3或101。\n如果if的then和else分支产生不同的类型，则if返回两者的 联合类型（union） 。\nvar x: (String | Bool) = if friendly then \"Hello\" else false end 但是if表达式没有else呢？ 任何不存在的else分支都会默认返回None（None是基元类的实例）。\nvar x: (String | None) = if friendly then \"Hello\" end if表达式的规则也适用于循环。我们看一下Pony的循环是什么样的：\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end x 会被赋值为Sarah，它是循环列表中的最后一个元素。如果循环直接跳出了（0次迭代），那么__x__ 的值就是else表达式的返回值。如果没有else块，则该值为None。\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name else \"no names!\" end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end _x 的值在这里是\"no names!\"。\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end 最后，x 的值是None。\nLoops表达式（Loops） if允许您选择要执行的操作，但是不止一次想要循环就可以执行其他操作。\nWhile表达式（While） Pony的while循环与其他语言非常相似。条件表达式将被求值，如果为真，将执行一次循环内的代码，完成后，我们将再次评估条件，并继续进行直到条件不成立为止。\n这是一个打印数字1到10的示例：\nvar count: U32 = 1 while count \u003c= 10 do env.out.print(count.string()) count = count + 1 end 就像if表达式，while也是表达式一样。返回值是最后循环执行时的表达式返回值。在这个例子中，当count递增到11时，也就是count = count + 1的返回值值。Pony会将最后一次正确执行循环的 旧值（old） 返回，最终while循环将返回10。\n但是如果while在第一次判断就为假，那不久就不会执行循环吗？ 在Pony中，while表达式也可以有一个else块，在没有提供else表达式时，Pony的else块会提供一个默认值None。注意：只有在第一次评估就为false时（也就是while循环体没机会执行时），才会返回else表达式的值。\n所以这就像Python中while循环中的else块吗？ 这是非常不同的。在Python中，else在while完成时运行。在Pony中，else仅在while没有机会运行时才执行。\n中止循环（Break） 有时，您希望在循环中途停止并跳出。 Pony为此使用了关键字break，它与C ++，C＃和Python等语言中的关键字非常相似。\nbreak会立即从它所在的最里面的循环中退出。由于循环必须返回一个值，break可以采用一个表达式。这是可选的，如果错过了，则返回else块中的值。\n让我们举个例子。假设您要浏览从某处获取的名称列表，查找Jack或Jill。如果这两个都没有出现，则只使用您的姓氏，如果根本不使用任何名字，则使用Herbert。\nvar name = while moreNames() do var name' = getName() if name' == \"Jack\" or name' == \"Jill\" then break name' end name' else \"Herbert\" end 因此，首先我们要询问是否还有其他名字。如果有的话，我们得到这个名字，看看它是Jack还是Jill，如果符合条件，将跳出循环，将找到的名字递回。如果没有，我们再试一次。\nname行出现在循环的末尾，因此如果找不到Jack或Jill，返回值最后一次迭代的名字。\n如果一开始就发现根本没有可用名，则返回else块提供的Herbert值。\n可以从多层嵌套的循环中直接跳出吗？就像Java的break那样 没有，Pony不支持。这是糟糕的逻辑表达方式，当你遇到需要从多层嵌套循环中直接跳出的情况，你应该重构你的代码或使用辅助函数。\nContinue表达式 有时，您希望在一次循环迭代中中途停止，然后进行下一次循环。像其他语言一样，Pony为此使用了continue关键字。\ncontinue将停止执行它所在的最内层循环的当前迭代，并评估条件以准备进行下一次迭代。\n如果在循环的最后一次迭代中continue被触发了，那么我们循环就不会有返回值。在这种情况下，将返回else表达式的值。与if表达式一样，如果未提供else表达式，则返回None。\nPony的continue可以直接跳到一个外部嵌套循环中继续执行吗？就像Java的continue。 不行，Pony不支持。如果需要跳转到外层循环继续执行，说明你的逻辑应该重构了。\nFor表达式 在Pony中需要便利集合，可以使用for表达式。当与集合一起使用时，这非常类似于C＃中的foreach，Python中的for..in和Java中的for。它与C和C++中的for非常不同。\nPony的for循环使用迭代器遍历集合。在每次迭代中，都会询问迭代器是否还有要处理的元素。\n例如，打印出数组中的所有字符串：\nfor name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do env.out.print(name) end 注意在数组上调用values()，是因为循环需一个迭代器。\n迭代器没有特定的类型需求，但需要提供以下接口方法：\nfun has_next(): Bool fun next(): T? 其中T是集合中对象的类型。除非您需要编写自己的迭代器，否则无需担心。要使用现有的集合（例如标准库中提供的集合），您只需使用for即可。如果你编写了自己的迭代器，请使用结构化多态的方式满足接口需求，你的迭代器无需特定的类型声明。\n您可以认为上述示例等效于：\nlet iterator = [\"Bob\"; \"Fred\"; \"Sarah\"].values() while iterator.has_next() do let name = iterator.next()? env.out.print(name) end 请注意，变量 name 使用 let 声明，所以不能在循环内为其重新赋值。\n我可以使用break并继续使用for循环吗？ 可以的，for循环可以附加else表达式，并且可以像while一样使用break和continue。\n重复执行表达式（Repeat） Pony提供的最后一个循环表达式是repeat``until。在这里，我们评估循环中的表达式，然后评估条件表达式，看看是否完成或应该再次处理。\n这与C++，C＃和Java中的do``while类似，不同之处在于终止条件是相反的，即那些语言在条件表达式为false时终止循环，而Pony在条件表达式为true时终止循环。\nPony中的while和repeat的区别是：\n repeat表达式至少会执行一次，而使用while则可能一次都不执行。 结束条件相反。  加入我们正在尝试执行一些逻辑，并且想不断重复直到满足条件为止：\nactor Main new create(env: Env) =\u003e var counter = U64(1) repeat env.out.print(\"hello!\") counter = counter + 1 until counter \u003e 7 end 就像while循环一样，repeat循环返回的值就是上一次迭代时循环内表达式的值，并且可以使用break和continue。\n由于至少要执行一次重复循环，还有必要给它提供一个else表达式吗？ 是的，您可能需要这样做。 如果repeat循环的最后一次迭代中触发了continue那就需要从某个地方获取一个值，这就需要使用else表达式。\n","summary":"在程序开发过程中，你需要能够对条件做出判断，对集合进行遍历，或者重复执行一些逻辑。因此，流程控制必不可少。Pony具有你在其他语言中所熟悉的流程控制控制，例如if，while和for，但是在Pony中，它们的工作方式略有不同。\n条件判断（Conditionals） if是最简单的流程控制控制。它仅在条件为真时才允许您执行某些操作。在Pony中的用法：\nif a \u003e b then env.out.print(\"a is bigger\") end 可以像在C语言中那样使用整数和指针作为条件吗？ 不行。在Pony中，if条件必须是布尔类型，即条件的返回值值始终为true或false。如果要判断数字a是否不为0，则需要明确的使用a！= 0。这个限制让Pony程序避免了潜在的类型错误。\n需要在条件失败时的执行一些逻辑，只需添加一个else：\nif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"a is not bigger\") end 通常，您想要检测和处理多种条件，可以嵌套if语句，但这有点丑陋：\nif a == b then env.out.print(\"they are the same\") else if a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end end 作为替代方案，Pony提供了结合了else和if的elseif关键字。这与其他语言中else if相同，并且每个if可以有任意数量的elseif：\nif a == b then env.out.print(\"they are the same\") elseif a \u003e b then env.","title":"流程控制（Control Structures）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/control-structures.html"},{"content":"与其他面向对象的语言一样，Pony具有 多态性（subtyping） 。也就是说，某些类型充当 categories ，其他类型可以成为其成员。\n编程语言的实现上有两种 多态（subtyping） 类型： 声明式（nominal）多态 和 结构化（structural）多态 。它们有细微的不同，大多数编程语言只会选择一种实现。但是Pony两种都实现了！\n声明式多态（Nominal subtyping） 这种多态的实现被称为 声明式 ，因为它需要你明确指出你要实现的 类型名 。\n如果你有过面向对象编程经验，你应该熟悉 继承（单） 、 多重继承 、 组合 、 特征 或类似的概念，所有的这些都属于 声明式多态\n核心思想是您有一个声明与某种类别类型有关系的类型。例如，在Java中，类（具体类型）可以实现某个接口（抽象类型）。在Java中，这表示这个类必须要实现指定抽象接口。编译器将检查该类是否实现了此抽象类型需要的所有接口。\nPony的特征（Traits）：声明式多态（Nominal subtyping） Pony使用 特征（trait） 来实现声明式多态。trait 的定义看上去有点像 class ，但是它使用关键字trait，并且不能有任何字段。\ntrait Named fun name(): String =\u003e \"Bob\" class Bob is Named 上面代码中，我们定义了一个名为Named的特征，他又一个名为name()的成员函数，返回类型是字符串。它还提供了name()函数的默认实现，返回字符串\"Bob”。\n接着定义了类名为Bob的类。Bob在明确的声明自己实现了Named特征。在Pony中，我们把这成为 Bob拥有Named特征 ，或者说 Bob就是Named 。\n我们看到Bob并没有定义name()函数，所以它会使用特征中的默认实现。如果特征对name()函数没有做出默认实现，则编译器就会报一个错告知：Bob没有实现name()。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald fun hair(): Bool =\u003e false class Bob is (Named \u0026 Bald) 一个类可以同时具备多个特征。在上面的示例中，Bob类同时提供了Named和Bald特征。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald is Named fun hair(): Bool =\u003e false class Bob is Bald 特征是支持组合的。在上面的示例中，所有Bald特征类被声明为包含Named特征。因此，Bob类可以访问两个特征类中的hair()和name()函数的默认实现。从语义上来说，我们可以认为Bald是一个更加明确的特征：Named泛指一个人的基础特征拥有一个名字，Bald更加明确的去描述是否有头发，然后我们使用这套规则描述一个没有头发的老头Bob。\nclass Larry fun name(): String =\u003e \"Larry\" 这个示例中，我们定义了一个名为Larry的类，该类也具备name()函数。但是Larry不是一个Named。\n等等，为什么不是呢？ 因为它并没有声明自己具备Named特征！ 请记住，特征需要 声明（nominal） ：想要提供特征的类型必须显式的声明。Larry确实没有声明。\n结构化多态（Structural subtyping） 多态还有另一种实现方式，无需明确声明，这种被称为 结构化多态 ，这意味着这与类型的构建方式有关，与名称无关。\n结构化多态的实现思路是，如果一个类型A恰好具备一个结构类别B所有必需的成员，那么A就是B。\n如果你用过Go语言，你会自然而然的想到Go的interface就是结构化多态的实现。\nPony的接口（Interfaces）: 结构化多态（structural subtyping） Pony也支持结构化多态，用 接口（interfaces）_ 就可以做到。接口看起来和特征差不多，不过它用interface定义。\ninterface HasName fun name(): String 上面的示例中，我们看到HasName接口和之前的Named特征，除了定义用的关键字不同外，似乎没多大区别。还记得Larry吗？“Larry不是一个Named”，但是\"Larry却是是一个HasName”，“Bob也是一个HasName”。但是程序中没有任何地方声明Bob和Larry与HasName有什么关联。\nPony的接口也可以具有默认实现的功能。如果类型明确声明它是该接口，则该类型将仅接受这些类型。\n我应该在自己的代码中使用特征还是接口？ 相信我，你两种都用的着！接口更加灵活，因此，如果不确定自己想要什么，请使用接口。但是特征也是一个强大的工具：它可以帮你检查子类型实现的完整性。\n","summary":"与其他面向对象的语言一样，Pony具有 多态性（subtyping） 。也就是说，某些类型充当 categories ，其他类型可以成为其成员。\n编程语言的实现上有两种 多态（subtyping） 类型： 声明式（nominal）多态 和 结构化（structural）多态 。它们有细微的不同，大多数编程语言只会选择一种实现。但是Pony两种都实现了！\n声明式多态（Nominal subtyping） 这种多态的实现被称为 声明式 ，因为它需要你明确指出你要实现的 类型名 。\n如果你有过面向对象编程经验，你应该熟悉 继承（单） 、 多重继承 、 组合 、 特征 或类似的概念，所有的这些都属于 声明式多态\n核心思想是您有一个声明与某种类别类型有关系的类型。例如，在Java中，类（具体类型）可以实现某个接口（抽象类型）。在Java中，这表示这个类必须要实现指定抽象接口。编译器将检查该类是否实现了此抽象类型需要的所有接口。\nPony的特征（Traits）：声明式多态（Nominal subtyping） Pony使用 特征（trait） 来实现声明式多态。trait 的定义看上去有点像 class ，但是它使用关键字trait，并且不能有任何字段。\ntrait Named fun name(): String =\u003e \"Bob\" class Bob is Named 上面代码中，我们定义了一个名为Named的特征，他又一个名为name()的成员函数，返回类型是字符串。它还提供了name()函数的默认实现，返回字符串\"Bob”。\n接着定义了类名为Bob的类。Bob在明确的声明自己实现了Named特征。在Pony中，我们把这成为 Bob拥有Named特征 ，或者说 Bob就是Named 。\n我们看到Bob并没有定义name()函数，所以它会使用特征中的默认实现。如果特征对name()函数没有做出默认实现，则编译器就会报一个错告知：Bob没有实现name()。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald fun hair(): Bool =\u003e false class Bob is (Named \u0026 Bald) 一个类可以同时具备多个特征。在上面的示例中，Bob类同时提供了Named和Bald特征。","title":"特征和接口（Traits and Interfaces）","uri":"https://damon-kwok.github.io/pony-tutorial/types/traits-and-interfaces.html"},{"content":"算术运算就是你在小学中学到的与数字有关的概念：加法，减法，乘法，除法等。小菜一碟。人人都知道这个东西。尽管如此，还是希望花点时间阅读下这一节教程，因为牵扯到计算机，魔鬼总是隐藏在细节中。\n在基元类章节中介绍过，Pony中的数字类型是一种映射到机器码的特殊原语。整数类型和浮点类型都支持一组丰富的算术运算和位运算。中缀运算符，在数字基元类型上作为普通函数实现。\nPony语言专注于两个目标，性能和安全性。这两个目标有时会发生冲突。对于整数和浮点数的算术尤其如此。为了确保代码安全，应在每个可能发生计算操的作上检查溢出，被零除和其他错误情况。 Pony尝试在编译时强制执行尽可能多的安全性检查，但是对算术运算的检查只能在运行时进行。另一方面，从代码的性能角度考虑，应尽快的执行整数算术运算，并在尽可能少的CPU周期内执行完毕。检查溢出是昂贵的，导致溢出的简单危险算术是廉价的。\nPony提供了不同的算术运算方式，使程序员可以自由选择最适合他们的操作：安全但较慢的操作或不太安全但快速的操作，因为性能对于某些应用场景至关重要。\n整数（Integers） 默认的算术运算符（Ponys default Arithmetic） 在处理整数的+, -, *, /算术运算上，Pony使用了一些技巧，试图平衡对性能和正确性的需求。所有默认的算术运算都不会暴露任何未定义的行为或错误条件。这意味着它可以处理上溢/下溢和零除的情况。上溢/下溢使用对带符号整数的补全来适当地环绕语义来处理。在这方面，我们得到如下行为：\n// unsigned wrap-around on overflow U32.max_value() + 1 == 0 // signed wrap-around on overflow/underflow I32.min_value() - 1 == I32.max_value() 除零是一种特殊情况，它会影响除法运算符/和取余%运算符。在数学中，零除是不确定的。为了避免将除法定义为部分除法，在除数为零时引发错误或在这种情况下引入未定义的行为，当除数为0时，将 normal 除法定义为0。如果不小心使用，可能会导致无提示错误。选择部分和校验的算术以除以零。\n与[Unsafe Arithmetic](#非安全的算术运算符（Unsafe Arithmetic）) 相比，默认算法具有一点点运行时开销，因为它与unsafe变体不同，它会检测并处理溢出和除零的情况。\n    Operator Method Description     + add() wrap around on over-/underflow   - sub() wrap around on over-/underflow   * mul() wrap around on over-/underflow   / div() x / 0 = 0   % rem() x % 0 = 0   %% mod() x %% 0 = 0   - neg() wrap around on over-/underflow   \u003e\u003e shr() filled with zeros, so x \u003e\u003e 1 == x/2 is true   \u003c\u003c shl() filled with zeros, so x \u003c\u003c 1 == x*2 is true     非安全的算术运算符（Unsafe Arithmetic） 不安全的整数算术接近于C语言中的整数算术所期望的结果。不做任何检查， raw speed ，上溢，下溢或被零除的可能性。像在C中一样，上溢，下溢和被零除的情况是不确定的。在这些情况下，请勿依赖结果。它可以是任何东西，并且高度特定于平台。被零除甚至可能会用SIGFPE使程序崩溃。我们的建议是仅在确保可以排除这些情况时才使用这些运算符。\n非安全的算术运算符函数别名的完整列表：\n    Operator Method Undefined in case of     +~ add_unsafe() Overflow E.g. I32.max_value() +~ I32(1)   -~ sub_unsafe() Overflow   *~ mul_unsafe() Overflow.   /~ div_unsafe() Division by zero and overflow. E.g. I32.min_value() / I32(-1)   %~ rem_unsafe() Division by zero and overflow.   %%~ mod_unsafe() Division by zero and overflow.   -~ neg_unsafe() Overflow. E.g. -~I32.max_value()   \u003e\u003e~ shr_unsafe() If non-zero bits are shifted out. E.g. I32(1) \u003e\u003e~ U32(2)   \u003c\u003c~ shl_unsafe() If bits differing from the final sign bit are shifted out.     非安全的类型转换（Unsafe Conversion） 在Pony中整数类型之间的转换需要明确进行。每个数字类型都可以显式转换为其他类型。\n// converting an I32 to a 32 bit floating point I32(12).f32() 对于每个转换操作，都存在一个不安全的对应项，当从浮点数转换为浮点数时，转换会更快。如果目标类型长度小于源类型，例如，数字类型之间的所有这些不安全转换都是不确定的。如果我们将I64转换为F32：\n// converting an I32 to a 32 bit floating point, the unsafe way I32(12).f32_unsafe() // an example for an undefined unsafe conversion I64.max_value().f32_unsafe() // an example for an undefined unsafe conversion, that is actually safe I64(1).u8_unsafe() 这是数字类型所有可用转换的完整列表：\n    Safe conversion Unsafe conversion     u8() u8_unsafe()   u16() u16_unsafe()   u32() u32_unsafe()   u64() u64_unsafe()   u128() u128_unsafe()   ulong() ulong_unsafe()   usize() usize_unsafe()   i8() i8_unsafe()   i16() i16_unsafe()   i32() i32_unsafe()   i64() i64_unsafe()   i128() i128_unsafe()   ilong() ilong_unsafe()   isize() isize_unsafe()   f32() f32_unsafe()   f64() f64_unsafe()     Partial and Checked Arithmetic 如果需要避免溢出或被零除，并且性能问题不太关键，那么部分或校验算法将在运行期间提供极大的安全性。上/下溢和除以零的部分算术运算符错误。经过检查的算术方法将返回运算结果的元组，并返回表示溢出或其他异常行为的布尔值。\n// partial arithmetic let result = try USize.max_value() +? env.args.size() else env.out.print(\"overflow detected\") end // checked arithmetic let result = match USize.max_value().addc(env.args.size()) | (let result: USize, false) =\u003e // use result ... | (_, true) =\u003e env.out.print(\"overflow detected\") end 请注意，部分以及经过检查的算法会带来在不同的异常处理逻辑负担，并会产生一些性能开销。\n   Partial Operator Method Description     +? add_partial() errors on overflow/underflow   -? sub_partial() errors on overflow/underflow   *? mul_partial() errors on overflow/underflow   /? div_partial() errors on overflow/underflow and division by zero   %? rem_partial() errors on overflow/underflow and division by zero   %%? mod_partial() errors on overflow/underflow and division by zero     算术运算检查函数返回运算结果和一个布尔值，指示在元组中上溢/下溢或被零除。\n   Checked Method Description     addc() Checked addition, second tuple element is true on overflow/underflow.   subc() Checked subtraction, second tuple element is true on overflow/underflow.   mulc() Checked multiplication, second tuple element is true on overflow.   divc() Checked division, second tuple element is true on overflow or division by zero.   remc() Checked remainder, second tuple element is true on overflow or division by zero.   modc() Checked modulo, second tuple element is true on overflow or division by zero.   fldc() Checked floored division, second typle element is true on overflow or division by zero.     浮点数（Floating Point） Pony中默认的浮点数(F32, F64)算法的行为与浮点标准 IEEE 754. 中定义的相同。\n这意味着用+0除会返回Inf ，用-0除会返回-Inf。\n非安全的算术运算（Unsafe Arithmetic） 对于每个输入或每个结果，不安全的浮点操作不一定符合IEEE 754。如果任何不安全操作或其结果的参数为“ +/- Inf”或“ NaN”，则结果实际上是不确定的。\n这样可以进行更积极的优化并加快执行速度，但是对于与例外值+/- Inf和NaN不同的值，只会产生有效的结果。如果可以排除这些情况，建议仅对浮点数使用不安全的算法。\n    Operator Method     +~ add_unsafe()   -~ sub_unsafe()   *~ mul_unsafe()   /~ div_unsafe()   %~ rem_unsafe()   %%~ mod_unsafe()   -~ neg_unsafe()   \u003c~ lt_unsafe()   \u003e~ gt_unsafe()   \u003c=~ le_unsafe()   \u003e=~ ge_unsafe()   =~ eq_unsafe()   !=~ ne_unsafe()     另外，没有对于负数定义sqrt_unsafe()。\n","summary":"算术运算就是你在小学中学到的与数字有关的概念：加法，减法，乘法，除法等。小菜一碟。人人都知道这个东西。尽管如此，还是希望花点时间阅读下这一节教程，因为牵扯到计算机，魔鬼总是隐藏在细节中。\n在基元类章节中介绍过，Pony中的数字类型是一种映射到机器码的特殊原语。整数类型和浮点类型都支持一组丰富的算术运算和位运算。中缀运算符，在数字基元类型上作为普通函数实现。\nPony语言专注于两个目标，性能和安全性。这两个目标有时会发生冲突。对于整数和浮点数的算术尤其如此。为了确保代码安全，应在每个可能发生计算操的作上检查溢出，被零除和其他错误情况。 Pony尝试在编译时强制执行尽可能多的安全性检查，但是对算术运算的检查只能在运行时进行。另一方面，从代码的性能角度考虑，应尽快的执行整数算术运算，并在尽可能少的CPU周期内执行完毕。检查溢出是昂贵的，导致溢出的简单危险算术是廉价的。\nPony提供了不同的算术运算方式，使程序员可以自由选择最适合他们的操作：安全但较慢的操作或不太安全但快速的操作，因为性能对于某些应用场景至关重要。\n整数（Integers） 默认的算术运算符（Ponys default Arithmetic） 在处理整数的+, -, *, /算术运算上，Pony使用了一些技巧，试图平衡对性能和正确性的需求。所有默认的算术运算都不会暴露任何未定义的行为或错误条件。这意味着它可以处理上溢/下溢和零除的情况。上溢/下溢使用对带符号整数的补全来适当地环绕语义来处理。在这方面，我们得到如下行为：\n// unsigned wrap-around on overflow U32.max_value() + 1 == 0 // signed wrap-around on overflow/underflow I32.min_value() - 1 == I32.max_value() 除零是一种特殊情况，它会影响除法运算符/和取余%运算符。在数学中，零除是不确定的。为了避免将除法定义为部分除法，在除数为零时引发错误或在这种情况下引入未定义的行为，当除数为0时，将 normal 除法定义为0。如果不小心使用，可能会导致无提示错误。选择部分和校验的算术以除以零。\n与[Unsafe Arithmetic](#非安全的算术运算符（Unsafe Arithmetic）) 相比，默认算法具有一点点运行时开销，因为它与unsafe变体不同，它会检测并处理溢出和除零的情况。\n    Operator Method Description     + add() wrap around on over-/underflow   - sub() wrap around on over-/underflow   * mul() wrap around on over-/underflow   / div() x / 0 = 0   % rem() x % 0 = 0   %% mod() x %% 0 = 0   - neg() wrap around on over-/underflow   \u003e\u003e shr() filled with zeros, so x \u003e\u003e 1 == x/2 is true   \u003c\u003c shl() filled with zeros, so x \u003c\u003c 1 == x*2 is true     非安全的算术运算符（Unsafe Arithmetic） 不安全的整数算术接近于C语言中的整数算术所期望的结果。不做任何检查， raw speed ，上溢，下溢或被零除的可能性。像在C中一样，上溢，下溢和被零除的情况是不确定的。在这些情况下，请勿依赖结果。它可以是任何东西，并且高度特定于平台。被零除甚至可能会用SIGFPE使程序崩溃。我们的建议是仅在确保可以排除这些情况时才使用这些运算符。","title":"算术运算符（Arithmetic）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/arithmetic.html"},{"content":"当我们讨论了 引用权能组合 和 观点适应 时，我们处理了我们知道来源的引用权能的情况。然而，有时我们并不知道原点的精确引用权能。\n当这种情况发生时，我们可以编写一个适合类型为 的视角 ，我们称其为一个 型箭头 ，因为我们用一个-\u003e来编写它。\nUsing this-\u003e as a viewpoint 带有box接收器的函数也可以用ref接收器或val接收器来调用，因为它们都是box的子类型。有时，我们希望能够讨论一种类型来考虑这一点。例如:\nclass Wombat var _friend: Wombat fun friend(): this-\u003eWombat =\u003e _friend 在这里，我们有一个袋熊，每个袋熊都有一个同样是袋熊的朋友(幸运的袋熊)。事实上，它是一个Wombat ref，因为ref是Wombat的默认引用权能(因为我们没有指定一个)。我们还有一个函数返回那个朋友。它有一个box接收器(因为box是一个函数的默认接收器引用权能，如果我们不指定它的话)。\n所以返回类型通常是袋熊盒子。为什么?因为，正如我们前面看到的，当我们从一个box源读取一个ref字段时，我们会得到一个box。在本例中，原点是接收器，它是一个方框。\n但是等等!如果我们想要一个函数，在接收方是ref时返回Wombat ref，在接收方是val时返回Wombat val，在接收方是box时返回Wombat box，那该怎么办?我们不想把这个函数写三遍。\n我们使用this-\u003e！在这种情况下，this-\u003eWombat。它的意思是\"接收者看到的Wombat ref”。\n我们知道在 call站点上 ，接收方的实际引用权能是什么。因此，当函数被调用时，编译器知道它需要知道的一切，以使其正确。\nUsing a type parameter as a viewpoint 我们还没有涉及泛型，所以这看起来有点奇怪。当我们讨论泛型(即参数化类型)时，我们将再次讨论这个问题，但是我们在这里提到它是为了完整性。\n另一种情况是，我们不知道某个东西的精确引用权能，即我们是否使用了类型参数。下面是来自标准库的一个例子:\nclass ListValues[A, N: ListNode[A] box] is Iterator[N-\u003eA] 这里，我们有一个ListValues类型，它有两个类型参数a和N。此外，N还有一个约束:它必须是ListNode[a] box的子类型。这很好，但我们也说ListValues[A, N]提供了Iterator[N-\u003eA]。这就是有趣的地方:我们提供了一个接口，让我们对类型N-\u003eA的值进行迭代。\n这意味着我们将返回类型为A的对象，但是引用权能将与类型为N的对象看到类型为A的对象相同。\nUsing box-\u003e as a viewpoint 还有一种使用箭头类型的方法，它也与泛型有关。有时，我们希望讨论某个类型参数，因为它是由某个未知类型看到的，as long as该类型可以读取type parameter 。\n换句话说，未知类型将是box的子类型，但我们只知道这些。下面是来自标准库的一个例子:\ninterface Comparable[A: Comparable[A] box] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) 在这里，我们说一个东西是‘Comparable[A]’，当且仅当它有函数‘eq’和‘ne’，而这些函数有一个类型为‘box-\u003eA’的参数并返回一个‘Bool’时。换句话说，不管A与什么有关，我们只需要能够读懂它。\n","summary":"当我们讨论了 引用权能组合 和 观点适应 时，我们处理了我们知道来源的引用权能的情况。然而，有时我们并不知道原点的精确引用权能。\n当这种情况发生时，我们可以编写一个适合类型为 的视角 ，我们称其为一个 型箭头 ，因为我们用一个-\u003e来编写它。\nUsing this-\u003e as a viewpoint 带有box接收器的函数也可以用ref接收器或val接收器来调用，因为它们都是box的子类型。有时，我们希望能够讨论一种类型来考虑这一点。例如:\nclass Wombat var _friend: Wombat fun friend(): this-\u003eWombat =\u003e _friend 在这里，我们有一个袋熊，每个袋熊都有一个同样是袋熊的朋友(幸运的袋熊)。事实上，它是一个Wombat ref，因为ref是Wombat的默认引用权能(因为我们没有指定一个)。我们还有一个函数返回那个朋友。它有一个box接收器(因为box是一个函数的默认接收器引用权能，如果我们不指定它的话)。\n所以返回类型通常是袋熊盒子。为什么?因为，正如我们前面看到的，当我们从一个box源读取一个ref字段时，我们会得到一个box。在本例中，原点是接收器，它是一个方框。\n但是等等!如果我们想要一个函数，在接收方是ref时返回Wombat ref，在接收方是val时返回Wombat val，在接收方是box时返回Wombat box，那该怎么办?我们不想把这个函数写三遍。\n我们使用this-\u003e！在这种情况下，this-\u003eWombat。它的意思是\"接收者看到的Wombat ref”。\n我们知道在 call站点上 ，接收方的实际引用权能是什么。因此，当函数被调用时，编译器知道它需要知道的一切，以使其正确。\nUsing a type parameter as a viewpoint 我们还没有涉及泛型，所以这看起来有点奇怪。当我们讨论泛型(即参数化类型)时，我们将再次讨论这个问题，但是我们在这里提到它是为了完整性。\n另一种情况是，我们不知道某个东西的精确引用权能，即我们是否使用了类型参数。下面是来自标准库的一个例子:\nclass ListValues[A, N: ListNode[A] box] is Iterator[N-\u003eA] 这里，我们有一个ListValues类型，它有两个类型参数a和N。此外，N还有一个约束:它必须是ListNode[a] box的子类型。这很好，但我们也说ListValues[A, N]提供了Iterator[N-\u003eA]。这就是有趣的地方:我们提供了一个接口，让我们对类型N-\u003eA的值进行迭代。\n这意味着我们将返回类型为A的对象，但是引用权能将与类型为N的对象看到类型为A的对象相同。\nUsing box-\u003e as a viewpoint 还有一种使用箭头类型的方法，它也与泛型有关。有时，我们希望讨论某个类型参数，因为它是由某个未知类型看到的，as long as该类型可以读取type parameter 。\n换句话说，未知类型将是box的子类型，但我们只知道这些。下面是来自标准库的一个例子:\ninterface Comparable[A: Comparable[A] box] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) 在这里，我们说一个东西是‘Comparable[A]’，当且仅当它有函数‘eq’和‘ne’，而这些函数有一个类型为‘box-\u003eA’的参数并返回一个‘Bool’时。换句话说，不管A与什么有关，我们只需要能够读懂它。","title":"箭头的用法（Arrow Types aka Viewpoints）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/arrow-types.html"},{"content":"一个 类型别名（type alias） 可以给一个类型起一个不同的名字。听起来可能有点傻：毕竟类型已经有名字了，感觉有点多此一举！但有时会遇到非常复杂的类型名，起一个简短的别名是很方便的。\n我们将给出几个使用类型别名的示例，以便更好的了解。\n枚举（Enumerations） 类型别名的一个很常见的应用场景是表示枚举。例如，我们想定义一组包含颜色值的枚举，：红色、蓝色或绿色。我们可以这样写:\nprimitive Red primitive Blue primitive Green type Colour is (Red | Blue | Green) 这里有两个新概念。第一个是类型别名，它由关键字type引入。它只是意味着type后面的名称可以表示is后面的类型。\n第二个新概念是is后面的类型。它不是一个普通类型，而是一个（类型联合体）。在这个上下文中，您可以将|符号理解为或， 因此它的类型是红色、蓝色或绿色。\n类型联合体是 closed world 类型的一种形式。也就是说，每种类型都可能是它的一个成员。相反，面向对象的子类型通常是 open world ，例如在Java中，一个接口可以由任意数量的类实现。\n你也可以用类型别名机制来声明类似于C或Go语言中的常量：\nprimitive Red fun apply(): U32 =\u003e 0xFF0000FF primitive Green fun apply(): U32 =\u003e 0x00FF00FF primitive Blue fun apply(): U32 =\u003e 0x0000FFFF type Colour is (Red | Blue | Green) 或者用来表示C++中的名字空间（namespace）：\nprimitive Colours fun red(): U32 =\u003e 0xFF0000FF fun green(): U32 =\u003e 0x00FF00FF 如果你像遍历枚举列表以打印它们的名字，以便进行调试：\nprimitive ColourList fun apply(): Array[Colour] =\u003e [Red; Green; Blue] for colour in ColourList().values() do end 复合类型（Complex types） 如果你的类型非常复杂，可以用类型别名来起一个简短的名字改善易读性。例如，如果想表达一个类型必须实现多个接口，我们可以这样做:\ninterface HasName fun name(): String interface HasAge fun age(): U32 interface HasAddress fun address(): String type Person is (HasName \u0026 HasAge \u0026 HasAddress) 这种复合类型的使用不仅适用于接口，也适用于特征:\ntrait HasName fun name(): String =\u003e \"Bob\" trait HasAge fun age(): U32 =\u003e 42 trait HasAddress fun address(): String =\u003e \"3 Abbey Road\" type Person is (HasName \u0026 HasAge \u0026 HasAddress) 这里还有一个新概念：类型中有一个\u0026。这类似于一个 类型联合体（union） 的|：\u0026意味着这是一个类型集合 。也就是说，它的类型是HasName、HasAge和HasAddress的组合。\n但是这里使用的type的作用与上面的枚举示例完全相同，它只是为类型提供了一个名称，否则反复输入这么长的类型名会有点无聊。\n有一个来自标准库的例子SetIs。这是它的定义:\ntype SetIs[A] is HashSet[A, HashIs[A!]] 这里有一些新的东西。名称SetIs后面是方括号中的名称A。这是因为SetIs是一个泛型类型。也就是说可以为SetIs提供一种类型参数，以生成特定类型的set。如果您使用过C++，那么它等价于模板，但是它们的工作方式有很大差别。\n上面的代码用类型别名提供了一个更简短优雅的名字SetIs[A]指代了复合类型名：\nHashSet[A, HashIs[A!]] 这是也是一个泛型。它表示SetIs实际上是一种HashSet。另一个概念悄然而至，那就是类型后面的!符号。这是另一种类型别名用法。这是只在编写复杂泛型类型时才需要的写法，所以我们将其留到以后讨论。\n另一个例子，同样来自标准库，是经常使用的Map类型。它实际上也是一个类型别名。以下是Map的定义:\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] 与前面的示例不同，第一个类型参数K具有与之关联的类型。这是一个泛型约束（constraint，这意味着当你参数化一个Map时，传递给K的类型必须是泛型约束条件要求的类型。\n另外，请注意box出现在类型中。这是一个引用权能。英文我们我们需要使用用K来做某一类的运算。稍后我们将对此进行更详细的讨论。\n跟前面的其他例子一样，这里的Map实际上是HashMap的一个类型别名。\n其他补充（Other stuff） 类型别名有很多用途，但这里只是大致的介绍了它概念。只需记住，类型别名可以提供一种便利：每次使用type后的别名替换is之后的完整类型名。\nPony对于类型别名替的换是在编译时进行的。\n","summary":"一个 类型别名（type alias） 可以给一个类型起一个不同的名字。听起来可能有点傻：毕竟类型已经有名字了，感觉有点多此一举！但有时会遇到非常复杂的类型名，起一个简短的别名是很方便的。\n我们将给出几个使用类型别名的示例，以便更好的了解。\n枚举（Enumerations） 类型别名的一个很常见的应用场景是表示枚举。例如，我们想定义一组包含颜色值的枚举，：红色、蓝色或绿色。我们可以这样写:\nprimitive Red primitive Blue primitive Green type Colour is (Red | Blue | Green) 这里有两个新概念。第一个是类型别名，它由关键字type引入。它只是意味着type后面的名称可以表示is后面的类型。\n第二个新概念是is后面的类型。它不是一个普通类型，而是一个（类型联合体）。在这个上下文中，您可以将|符号理解为或， 因此它的类型是红色、蓝色或绿色。\n类型联合体是 closed world 类型的一种形式。也就是说，每种类型都可能是它的一个成员。相反，面向对象的子类型通常是 open world ，例如在Java中，一个接口可以由任意数量的类实现。\n你也可以用类型别名机制来声明类似于C或Go语言中的常量：\nprimitive Red fun apply(): U32 =\u003e 0xFF0000FF primitive Green fun apply(): U32 =\u003e 0x00FF00FF primitive Blue fun apply(): U32 =\u003e 0x0000FFFF type Colour is (Red | Blue | Green) 或者用来表示C++中的名字空间（namespace）：\nprimitive Colours fun red(): U32 =\u003e 0xFF0000FF fun green(): U32 =\u003e 0x00FF00FF 如果你像遍历枚举列表以打印它们的名字，以便进行调试：","title":"类型别名（Type Aliases）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-aliases.html"},{"content":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 causal. (Not casual!)  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。\n","summary":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 causal. (Not casual!)  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。","title":"类型系统概览","uri":"https://damon-kwok.github.io/pony-tutorial/types/at-a-glance.html"},{"content":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。\n类型集合的特性可以让我们很容易的将特征和接口组合在一起。例如，标准库中的Map的定义方式：\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] 这是一个相当复杂的类型别名。让我们看一下K的定义：(Hashable box \u0026 Comparable[K] box)，这表示K是一个Hashable 同时 它也具有Comparable[K]的特征。\n类型表达式组合（Combining type expressions） 类型表达式可以组合出更复杂的类型。这是标准库中的另一个示例：\nvar _array: Array[((K, V) | _MapEmpty | _MapDeleted)] 在这里，我们定义了一个数组类型的变量，数组的元素可以是(K, V)类型的元组，也可以是_MapEmpty 或 _MapDeleted。\n每个类型表达式都有括号，所以了解了这一点，实际上还是很容易阅读的。如果遇到需要高频率使用复杂的类型表达式，最好为它提供一个类型别名。\ntype Number is (Signed | Unsigned | Float) type Signed is (I8 | I16 | I32 | I64 | I128) type Unsigned is (U8 | U16 | U32 | U64 | U128) type Float is (F32 | F64) 上面的类型别名定义都来自于标准库。\nNumber是一个类型别名，它定义中中还可以包含其他类型别名？ 没错，这是个非常有趣和方便的特性。\n","summary":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。","title":"类型表达式（Type Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-expressions.html"},{"content":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\n类的组成部分 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.就可以选择构造函数：\nlet defaultWombat = Wombat(\"Fantastibat\") // 使用默认构造函数 let hungryWombat = Wombat.hungry(\"Nomsbat\", 12) // 使用`hunger`构造函数 构造函数中name'参数的单引号时啥意思？ 你可以在 参数 和 内部变量 命名中使用单引号，用来区分时 外部传入 和 内部定义 的字段（就像Python的self.name=name Java的this.nama=name C++的：this-\u003ename=name)。\n每一个构造函数都要为所有字段做出初始化，否则编译器会给你一个error。Pony中是不存在null的，我们不能像Java，C#等语言中一样将字段赋值为null，也没有数字不初始化默认为0的规则。Pony不希望在你运行时因为字段undefined导致崩溃（不像C和C++）。\n有时我们希望可以为所有构造函数快速的设置字段初始值：\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面的例子中，通过为字段赋初值，默认将口渴等级字段设置为1，需要不同的值，可以在构造函数中做修改。\n无参数的构造函数\nclass Hawk var _hunger_level: U64 = 0 class Owl var _hunger_level: U64 new create() =\u003e _hunger_level = 42 上面例子中我们定义了两个类，Hawk类没有构造函数，编译器会生成一个默认的create构造函数。Owl定义了一个构造函数设置_hunger_level字段。\n创建实例时如果类拥有一个无参数构造函数，直接省略掉括号：\nclass Forest let _owl: Owl = Owl let _hawk: Hawk = Hawk 稍后我们会在语法糖章节中做出详细解释。\n成员函数 Pony中的成员函数类似于Java，C#，C++，Ruby，Python等面向对象语言中的方法（类成员函数）。和构造函数一样它们也可以有参数和返回值类型（注意是_可以有_，不是必须。如果没有明确给出返回值类型，默认为None，表示没有返回值）。\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' fun hunger(): U64 =\u003e _hunger_level fun ref set_hunger(to: U64 = 0): U64 =\u003e _hunger_level = to 我们从hunger函数说起：它有一个U64返回类型，返回树袋熊当前的口渴等级。这里我们没有使用return关键字，因为我们要返回的_hunger_level是函数的最后一个表达式。\nPony中有return关键字吗？ 当然有，当你需要在函数中\"提前\"返回时，也就是说你不希望函数运行到最后一个表达式的时候，就需要用到return关键字。\n再来看第二个函数set_hunger，这里出现了 一堆 新概念，让我们来逐步了解一下这些概念。\n fun后面的ref关键字  这是一个 引用权能 。在这里，因为我们需要修改_hunger_level字段。\nhunger方法的接收者参考能力是什么？ 如果未指定，默认的接收者引用权能是box，这意味着“我只需要能读取，不需要修改”。\n如果我们将set_hunger方法中的ref关键字保留下来会怎样？ 编译器会给您一个错误。它会显示您正在尝试修改字段并抱怨它。\n 参数to后面的= 0  这是一个 默认参数 。当你调用这个函数时没有传入参数，就会默认为这个值，在这里它的默认值被设置为0。\n 函数实际返回了什么？  它返回修改前的 旧值 。\n等等，开什么玩笑？旧值？ 没错，在Pony中赋值操作是一个表达式，这意味着它有一个返回值，在很多数语言里赋值语句会返回_新值_，换句话说a=b在大多数语言里都会返回b，但是在Pony中返回a。\n…为什么？ 这被称为\"破坏性读取”，它使您可以使用功能安全类型系统来完成出色的工作，我们稍后再讨论。现在，我们只只需要知道可以使用它来实现_swap_操作。在其他语言里要交换a和b的值你通常需要这么做：\nvar temp = a a = b b = temp 用Pony这样就可以了：\na = b = a 销毁函数 销毁函数是一个特殊函数，函数名为_final，box。函数必须被定义为fun _final()。\n在GC收集对象之前，将调用对象的销毁函数。对象在销毁后成员函数依然可以被调用，但只能从另一个销毁函数内调用。另外需要注意一点：无法从销毁函数中发送消息。\n销毁函数通常用于清理以C代码分配的资源，例如文件句柄，网络套接字等。\n关于继承？ 在很多面向对象的语言中，一种类型可以继承另一种类型，例如在Java中某种东西可以“扩展”其他某种东西。Pony不这样做。相反，Pony的做法是 组合 而不是 继承 。换句话说，在Pony中你的逻辑需要去表达 has ，而不是 is 。\n另一方面，Pony具有强大的 trait（特征） 系统（类似于具有默认实现的Java 8 接口）和强大的 interface（接口） 系统（类似于Go语言的接口，也就是结构化类型）。\n稍后我们将详细讨论这些内容。\n命名规则 Pony中的所有命名，包括类型名，方法名和变量名等，都只能包含 ASCII字符。\n实际上，Pony代码的所有的元素都必须为ASCII，字符串文内容除外，字符串可以愉快地直接从源文件中接受任何类型的字节（无论是UTF-8编码还是ISO-8859-2并以其编码形式表示）。\nPony的类型，无论是class，actor，trait，interface，primitive还是类型别名，都必须以大写字母开头。在私有或特殊 methods （行为，构造函数和普通函数）的下划线之后，任何方法或变量（包括参数和字段）都必须以小写字母开头。在所有情况下，都不允许在一行中或名称末尾加下划线，但否则，字母和数字的任何组合都是合法的。\n实际上，数字也可以使用单个下划线作为分隔符！但是，只有有效的变量名才能以质数结尾。\n","summary":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\n类的组成部分 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.","title":"类（Classes）","uri":"https://damon-kwok.github.io/pony-tutorial/types/classes.html"},{"content":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface. Most functions on a Pointer[A] are private to maintain memory safety. \"\"\" new create() =\u003e \"\"\" A null pointer. \"\"\" compile_intrinsic new _alloc(len: USize) =\u003e \"\"\" Space for len instances of A. \"\"\" compile_intrinsic 这里有两个构造函数。第一个创建一个新的空Pointer，第二个创建分配了内存空间的Pointer。\n成员函数 和类一样，结构体也可以有函数。对Pony类成员函数的所有内容也适用于结构。\nWe’ll see structs again 在Pony与C代码的交互中，结构体扮演着重要的角色。我们将在教程的C-FFI部分中详细讲解结构体。现在，我们不需要过多关注结构体。\n","summary":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface.","title":"结构体（Structs）","uri":"https://damon-kwok.github.io/pony-tutorial/types/structs.html"},{"content":"Pony允许你编写代码时做一些简化，让代码更简洁、易读。使用语法糖是可选的，如果您愿意，你可以始终使用完整的书写方式。\nApply语法糖 许多Pony类都有一个名为apply的函数，该函数可以执行一些该类型最常见的操作。Pony允许你省略apply这个函数名，直接从对象调用。所以:\nvar foo = Foo.create() foo() 等同于：\nvar foo = Foo.create() foo.apply() 需要参数的话可以像调用普通方法那样去添加。\nvar foo = Foo.create() foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create() foo.apply(x, 37 where crash = false) 必须要提供参数吗? 是的，只有apply会为你自动添加，正确的参数数量和类型必须你自己提供。默认传参和命名传参的机制可以正常使用。\n如果apply会被自动添加，那我怎么调用其他函数？ 只有直接调用对象时才添加apply，其他时候不会。编译器能判断什么时候该添加apply。\nCreate语法糖 要实例化对象，你需要指定类型并调用构造函数。Pony允许你忽略构造函数，并将为您插入一个create()调用。所以:\nvar foo = Foo 等同于：\nvar foo = Foo.create() 通常，类型在表达式中是不被求值的，因此省略掉构造函数并不会造成歧义。记住，类型是很容易被识别的，因为它始终是以大写字母开头。\n如果create需要参数，可以直接在后面加括号传入。默认参数和命名传参机制都可以正常使用。\nvar foo = Foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create(x, 37 where crash = false) 如果我想使用一个名字不是create的构造函数怎么做? 不行，语法糖帮不了你，你必须自己把它写出来。\n如果我要调用的create没有参数，我可以加上括号吗? 不能加，调用Type()相当于在组合使用create和apply(参见下面)。要调用Type.create()只需使用Type。\ncreate和apply语法糖的组合使用 如果类型有一个不带参数的create构造函数，那么create和apply语法糖可以一起使用。只需调用类型，创建和应用的调用将被添加。对create的调用将不接受任何参数，而对apply的调用将接受提供的任何参数。\nvar foo = Foo() var bar = Bar(x, 37 where crash = false) 等同于：\nvar foo = Foo.create().apply() var bar = Bar.create().apply(x, 37 where crash = false) 如果create有默认参数怎么办？如果我想使用默认参数，是否能使用create-apply组合语法糖? 只有当create构造函数没有参数时，才可以使用组合的create-apply语法糖。如果有默认参数，则不能使用。\nUpdate语法糖 update语法糖允许任何类使用赋值的方式来更新数据。在很多语言都可以给集合中的元素赋值，例如，一个简单的C数组a[3] = x;。\n遇到左边是函数调用的赋值表达式，Pony会将其转换为对update的调用，而右边的值则是一个额外的参数。所以:\nfoo(37) = x 等同于：\nfoo.update(37 where value = x) 赋值右侧的值总是传递给一个名为value的参数。任何对象都可以简单地通过提供一个update函数和value参数来支持这种语法。\n我的update函数必须是整数型的参数吗? 不，你可以自定义参数类型，只要有一个名为value的参数。以下都可以:\nfoo1(2, 3) = x foo2() = x foo3(37, \"Hello\", 3.5 where a = 2, b = 3) = x 参数列表中value的位置有关系吗？ 虽然从严格意义上讲没什么关系，但把value作为最后一个参数是个好习惯。这样，所有其他参数就可以通过位置传参来指定。\n","summary":"Pony允许你编写代码时做一些简化，让代码更简洁、易读。使用语法糖是可选的，如果您愿意，你可以始终使用完整的书写方式。\nApply语法糖 许多Pony类都有一个名为apply的函数，该函数可以执行一些该类型最常见的操作。Pony允许你省略apply这个函数名，直接从对象调用。所以:\nvar foo = Foo.create() foo() 等同于：\nvar foo = Foo.create() foo.apply() 需要参数的话可以像调用普通方法那样去添加。\nvar foo = Foo.create() foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create() foo.apply(x, 37 where crash = false) 必须要提供参数吗? 是的，只有apply会为你自动添加，正确的参数数量和类型必须你自己提供。默认传参和命名传参的机制可以正常使用。\n如果apply会被自动添加，那我怎么调用其他函数？ 只有直接调用对象时才添加apply，其他时候不会。编译器能判断什么时候该添加apply。\nCreate语法糖 要实例化对象，你需要指定类型并调用构造函数。Pony允许你忽略构造函数，并将为您插入一个create()调用。所以:\nvar foo = Foo 等同于：\nvar foo = Foo.create() 通常，类型在表达式中是不被求值的，因此省略掉构造函数并不会造成歧义。记住，类型是很容易被识别的，因为它始终是以大写字母开头。\n如果create需要参数，可以直接在后面加括号传入。默认参数和命名传参机制都可以正常使用。\nvar foo = Foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create(x, 37 where crash = false) 如果我想使用一个名字不是create的构造函数怎么做?","title":"语法糖（Sugar）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/sugar.html"},{"content":"我们之前提到过，cffi可以用来打破Pony做出的几乎所有保证。这是因为，一旦调用了C语言，就会执行任意的机器码，这些代码会破坏内存地址、写入任何东西，而且通常表现得非常糟糕。\n边界信任 当我们谈论信任的时候，我们并不是指你相信的事情，因为你认为它们是完美的。相反，我们指的是那些你必须信任才能完成的事情，即使你知道它们是不完美的。\n在Pony中，当你使用C FFI时，你基本上是在声明你相信正在执行的C代码。这很好，因为你可能需要它来完成工作。但是信任别人的代码来使用cffi呢?你可能需要知道，但你肯定想知道它正在发生。\n安全包 处理这个问题的常规方法是确保您只使用了程序中需要使用的代码。很简单!不要使用一些随机的包从互联网上没有看到的代码，并确保它不会做令人讨厌的FFI的东西。\n但我们可以做得更好。\n在Pony中，你可以选择在‘ponyc’命令行上声明一组_safe_包，就像这样:\nponyc --safe=files:net:net/ssl my_project 这里，我们声明只有“文件”、“net”和“net/ssl”包才允许使用C FFI调用。我们已经建立了信任边界:任何其他试图使用C FFI调用的包都会导致编译时错误。\n","summary":"我们之前提到过，cffi可以用来打破Pony做出的几乎所有保证。这是因为，一旦调用了C语言，就会执行任意的机器码，这些代码会破坏内存地址、写入任何东西，而且通常表现得非常糟糕。\n边界信任 当我们谈论信任的时候，我们并不是指你相信的事情，因为你认为它们是完美的。相反，我们指的是那些你必须信任才能完成的事情，即使你知道它们是不完美的。\n在Pony中，当你使用C FFI时，你基本上是在声明你相信正在执行的C代码。这很好，因为你可能需要它来完成工作。但是信任别人的代码来使用cffi呢?你可能需要知道，但你肯定想知道它正在发生。\n安全包 处理这个问题的常规方法是确保您只使用了程序中需要使用的代码。很简单!不要使用一些随机的包从互联网上没有看到的代码，并确保它不会做令人讨厌的FFI的东西。\n但我们可以做得更好。\n在Pony中，你可以选择在‘ponyc’命令行上声明一组_safe_包，就像这样:\nponyc --safe=files:net:net/ssl my_project 这里，我们声明只有“文件”、“net”和“net/ssl”包才允许使用C FFI调用。我们已经建立了信任边界:任何其他试图使用C FFI调用的包都会导致编译时错误。","title":"边界信任（Trust Boundary）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/trust-boundary.html"},{"content":"中缀运算符（Infix Operators） 中缀运算符需要两个操作数，位于操作数之间。算术和比较运算符是最常见的中缀运算符：\n1 + 2 a \u003c b Pony的中缀运算符集和其他语言基本一致。\n运算符别名（Operator aliasing） Pony中的大多数中缀运算符都是函数的别名。左边的操作数是调用函数的接收器，右边的操作数作为参数传递。例如，下面的两个表达式是等效的：\nx + y x.add(y) +不是只能用于特性类型的特殊符号。任何类型都可以提供自己的add函数，然后可以根据需要对该类型使用+。\n在定义自己的add函数时，对参数类型或返回类型没有限制。 +的右侧必须与参数类型匹配，并且+表达式将具有add函数返回的类型。\n下面的代码是自定义+运算符的完整示例：\n// Define a suitable type class Pair var _x: U32 = 0 var _y: U32 = 0 new create(x: U32, y: U32) =\u003e _x = x _y = y // Define a + function fun add(other: Pair): Pair =\u003e Pair(_x + other._x, _y + other._y) // Now let's use it class Foo fun foo() =\u003e var x = Pair(1, 2) var y = Pair(3, 4) var z = x + y 使用类型联合体或f界多态性可以在某种程度上重载中缀运算符，但这不在本教程的讨论范围之内。有关更多信息，请参考Pony标准库。\n如果您不想，则不必担心任何这些。您可以像使用任何其他语言一样简单地将现有的中缀运算符用于数字，而不必为您自己的类型提供它们。\n中缀运算符函数别名的完整列表：\n    运算符 函数 描述 注意     + add() Addition    - sub() Subtraction    * mul() Multiplication    / div() Division    % rem() Remainder    %% mod() Modulo Starting with version 0.26.1   \u003c\u003c shl() Left bit shift    \u003e\u003e shr() Right bit shift    and op_and() And, both bitwise and logical    or op_or() Or, both bitwise and logical    xor op_xor() Xor, both bitwise and logical    == eq() Equality    != ne() Non-equality    \u003c lt() Less than    \u003c= le() Less than or equal    \u003e= ge() Greater than or equal    \u003e gt() Greater than    \u003e~ gt_unsafe() Unsafe greater than    +~ add_unsafe() Unsafe Addition    -~ sub_unsafe() Unsafe Subtraction    *~ mul_unsafe() Unsafe Multiplication    /~ div_unsafe() Unsafe Division    %~ rem_unsafe() Unsafe Remainder    %%~ mod_unsafe() Unsafe Modulo Starting with version 0.26.1   \u003c\u003c~ shl_unsafe() Unsafe left bit shift    \u003e\u003e~ shr_unsafe() Unsafe right bit shift    ==~ eq_unsafe() Unsafe equality    !=~ ne_unsafe() Unsafe non-equality    \u003c~ lt_unsafe() Unsafe less than    \u003c=~ le_unsafe() Unsafe less than or equal    \u003e=~ ge_unsafe() Unsafe greater than or equal    +? add_partial()? Partial Addition    -? sub_partial()? Partial Subtraction    *? mul_partial()? Partial Multiplication    /? div_partial()? Partial Division    %? rem_partial()? Partial Remainder    %%? mod_partial()? Partial Modulo Starting with version 0.26.1     短路求值（Short circuiting） 与Bool变量一起使用时，and和or运算符会采用使用 短路求值（short circuiting） 。第一个操作数始终会被求值，第二个操作数仅在对有影响结果时，才会被求值。\n对于and，如果第一个操作数是 false ，则不会对第二个操作数求值，因为它不会影响结果。\n对于or，如果第一个操作数是 true ，则不会对第二个操作数求值，因为它不会影响结果。\n这是编译器内置的特殊功能，不能与其他类型的运算符别名一起使用。\n一元运算符（Unary operators） 一元运算符的与中缀运算符的别名机制类似，但只有一个操作数。例如，以下表达式是等效的：\n-x x.neg() 一元运算符函数别名的完整列表：\n    运算符 函数 描述       | neg() | Arithmetic negation    not | op_not() | Not, both bitwise and logical -~ | neg_unsafe() | Unsafe arithmetic negation\n 运算符优先级（Precedence） 在Pony中，一元运算符的优先级总是比中缀运算符高：not a == b将被解释为（not a）== b而不是not（a == b）。\n在复杂表达式中使用中缀运算符时， 优先级 问题很关键。试着评估下面这句表达式的运算符优先级：\n1 + 2 * 3 // Compilation failed. 如果我们计算加法，得到的结果为9，如果计算乘法，得到的结果为7。在数学中有一套评估运算符优先级的规则，大多数编程语言都遵循这种方法。\n这样做的问题是程序员必须记住规则，通常人们对这样的事情不是很擅长。大多数人会记得在加法之前要进行乘法运算，但是左移与按位运算又如何呢？有时人们会忘记（或猜错），这会导致错误。更糟糕的是，这些错误通常很难发现。\nPony采取了不同的做法，去避免这个问题。 如果一个表达式中需要使用多个中缀运算符 必须 使用括号来消除歧义。如果您不这样做，编译时会报错。\n上面的示例在Pony中是非法的，正确的写法为：\n1 + (2 * 3) // 7 如果使用的是相同的运算符就可以省略括号：\n1 + 2 + 3 // 6 同时，一元运算符和中缀运算符的混合不需要额外的括号，因为一元运算符总是和操作数紧贴在一起，因此如果上面的示例使用的是负3是没问题的。但是如果用到不同的中缀运算符：\n1 + 2 * -3 // Compilation failed. 仍然需要括号来消除歧义，就像上面所做的一样，但是不需要负数一元运算（-）加括号：\n1 + (2 * -3) // -5 我们可以看到，将一元运算符应用在中缀运算之前更有意义，因为它仅作用于表达式中的单个数字，因此它永远不会模棱两可。\n一元运算符也可以应用于括号，在括号之外，所有中缀运算符之前，对括号中的运算结果进行操作：\n1 + -(2 * -3) // 7 ","summary":"中缀运算符（Infix Operators） 中缀运算符需要两个操作数，位于操作数之间。算术和比较运算符是最常见的中缀运算符：\n1 + 2 a \u003c b Pony的中缀运算符集和其他语言基本一致。\n运算符别名（Operator aliasing） Pony中的大多数中缀运算符都是函数的别名。左边的操作数是调用函数的接收器，右边的操作数作为参数传递。例如，下面的两个表达式是等效的：\nx + y x.add(y) +不是只能用于特性类型的特殊符号。任何类型都可以提供自己的add函数，然后可以根据需要对该类型使用+。\n在定义自己的add函数时，对参数类型或返回类型没有限制。 +的右侧必须与参数类型匹配，并且+表达式将具有add函数返回的类型。\n下面的代码是自定义+运算符的完整示例：\n// Define a suitable type class Pair var _x: U32 = 0 var _y: U32 = 0 new create(x: U32, y: U32) =\u003e _x = x _y = y // Define a + function fun add(other: Pair): Pair =\u003e Pair(_x + other._x, _y + other._y) // Now let's use it class Foo fun foo() =\u003e var x = Pair(1, 2) var y = Pair(3, 4) var z = x + y 使用类型联合体或f界多态性可以在某种程度上重载中缀运算符，但这不在本教程的讨论范围之内。有关更多信息，请参考Pony标准库。","title":"运算符（Operators）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/ops.html"}]