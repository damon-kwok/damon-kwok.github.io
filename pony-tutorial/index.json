[{"content":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.\nLet’s start with a simple one.\nleft side must be something that can be assigned to Suppose you wrote:\nactor Main let x: I64 = 0 new create(env: Env) =\u003e x = 12 The error message would be:\nError: .../a.pony:6:5: can't assign to a let or embed definition more than once x = 12 ^ Error: .../a.pony:6:7: left side must be something that can be assigned to x = 12 ^ What happened is that you declared x as a constant, by writing let x, and then tried to assign a new value to it, 12. To fix the error, replace let with var or reconsider what value you want x to have.\nThat one error resulted in two error messages. The first, pointing to the x, describes the specific problem, that x was defined with let. The second, pointing to the = describes a more general error, that whatever is on the left side of the assignment is not something that can be assigned to. You would get that same error message if you attempted to assign a value to a literal, like 3.\ncannot write to a field in a box function Suppose you create a class with a mutable field and added a method to change the field:\nclass Wombat var color: String = \"brown\" fun dye(new_color: String) =\u003e color = new_color The error message would be:\nError: .../a.pony:4:11: cannot write to a field in a box function. If you are trying to change state in a function use fun ref color = new_color ^ To understand this error message, you have to have some background. The field color is mutable since it is declared with var, but the method dye does not have an explicit receiver reference capability. The default receiver reference capability is box, which allows dye to be called on any mutable or immutable Wombat; the box reference capability says that the method may read from but not write to the receiver. As a result, it is illegal to attempt to modify the receiver in the method.\nTo fix the error, you would need to give the dye method a mutable reference capability, such as ref: fun ref dye(new_color: String) =\u003e ....\nreceiver type is not a subtype of target type Suppose you made a related, but slightly different error:\nclass Rainbow let colors: Array[String] = Array[String] fun add_stripe(color: String) =\u003e colors.push(color) In this example, rather than trying to change the value of a field, the code calls a method which attempts to modify the object referred to by the field.\nThe problem is very similar to that of the last section, but the error message is significantly more complicated:\nError: ../a.pony:4:16: receiver type is not a subtype of target type colors.push(color) ^ Info: .../a.pony:4:5: receiver type: this-\u003eArray[String val] ref colors.push(color) ^ .../ponyc/packages/builtin/array.pony:252:3: target type: Array[String val] ref fun ref push(value: A): Array[A]^ =\u003e ^ .../a.pony:2:15: Array[String val] box is not a subtype of Array[String val] ref: box is not a subtype of ref let colors: Array[String] = Array[String]() ^ Once again, Pony is trying to be helpful. The first few lines describe the error, in general terms that only a programming language maven would like: an incompatibility between the receiver type and the target type. However, Pony provides more information: the lines immediately after “Info:” tell you what it believes the receiver type to be and the next few lines describe what it believes the target type to be. Finally, the last few lines describe in detail what the problem is.\nUnfortunately, this message does not locate the error as clearly as the previous examples.\nBreaking it down, the issue seems to be with the call to push, with the receiver colors. The receiver type is this-\u003eArray[String val] ref; in other words, the view that this method has of a field whose type is Array[String val] ref. In the class Rainbow, the field colors is indeed declared with the type Array[String], and the default reference capability for Strings is val while the default reference capability for Array is ref.\nThe “target type” in this example is the type declaration for the method push of the class Array, with its type variable A replaced by String (again, with a default reference capability of val). The reference capability for the overall array, as required by the receiver reference capability of push, is ref. It seems that the receiver type and the target type should be pretty close.\nBut take another look at the final lines: what Pony thinks is the actual receiver type, Array[String val] box, is significantly different from what it thinks is the actual target type, Array[String val] ref. And a type with a reference capability of box, which is immutable, is indeed not a subtype of a type with a reference capability of ref, which is mutable.\nThe issue must lie with the one difference between the receiver type and the target type, which is the prefix “this-\u003e”. The type this-\u003eArray[String val] ref is a viewpoint adapted type, or arrow type, that describes the Array[String val] ref “as seen by the receiver”. The receiver, in this case, has the receiver reference capability of the method add_stripe, which is the default box. That is why the final type is Array[String val] box.\nThe fundamental error in this example is the same as the last: the default receiver reference capability for a method is box, which is immutable. This method, however, is attempting to modify the receiver, by adding another color stripe. That is not legal at all.\nAs an aside, while trying to figure out what is happening, you may have been misled by the declaration of the colors field, let colors.... That declaration makes the colors binding constant. As a result, you cannot assign a new array to the field. On the other hand, the array itself can be mutable or immutable. In this example, it is mutable, allowing push to be called on the colors field in the add_stripe method.\nA note on compiler versions The error messages shown in this section are from ponyc 0.2.1-1063-g6ae110f [release], the current head of the master branch at the time this is written. The messages from other versions of the compiler may be different, to a greater or lesser degree.\n","summary":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.","title":"A Short Guide to Pony Error Messages","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/error-messages.html"},{"content":"When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don’t know the precise reference capability of the origin.\nWhen that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -\u003e.\nUsing this-\u003e as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box. Sometimes, we want to be able to talk about a type to take this into account. For example:\nclass Wombat var _friend: Wombat fun friend(): this-\u003eWombat =\u003e _friend Here, we have a Wombat, and every Wombat has a friend that’s also a Wombat (lucky Wombat). In fact, it’s a Wombat ref, since ref is the default reference capability for a Wombat (since we didn’t specify one). We also have a function that returns that friend. It’s got a box receiver (because box is the default receiver reference capability for a function if we don’t specify it).\nSo the return type would normally be a Wombat box. Why’s that? Because, as we saw earlier, when we read a ref field from a box origin, we get a box. In this case, the origin is the receiver, which is a box.\nBut wait! What if we want a function that can return a Wombat ref when the receiver is a ref, a Wombat val when the receiver is a val, and a Wombat box when the receiver is a box? We don’t want to have to write the function three times.\nWe use this-\u003e! In this case, this-\u003eWombat. It means “a Wombat ref as seen by the receiver”.\nWe know at the call site what the real reference capability of the receiver is. So when the function is called, the compiler knows everything it needs to know to get this right.\nUsing a type parameter as a viewpoint We haven’t covered generics yet, so this may seem a little weird. We’ll cover this again when we talk about generics (i.e. parameterised types), but we’re mentioning it here for completeness.\nAnother time we don’t know the precise reference capability of something is if we are using a type parameter. Here’s an example from the standard library:\nclass ListValues[A, N: ListNode[A] box] is Iterator[N-\u003eA] Here, we have a ListValues type that has two type parameters, A and N. In addition, N has a constraint: it has to be a subtype of ListNode[A] box. That’s all fine and well, but we also say the ListValues[A, N] provides Iterator[N-\u003eA]. That’s the interesting bit: we provide an interface that let’s us iterate over values of the type N-\u003eA.\nThat means we’ll be returning objects of the type A, but the reference capability will be the same as an object of type N would see an object of type A.\nUsing box-\u003e as a viewpoint There’s one more way we use arrow types, and it’s also related to generics. Sometimes we want to talk about a type parameter as it is seen by some unknown type, as long as that type can read the type parameter.\nIn other words, the unknown type will be a subtype of box, but that’s all we know. Here’s an example from the standard library:\ninterface Comparable[A: Comparable[A] box] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) Here, we say that something is Comparable[A] if and only if it has functions eq and ne and those functions have a single parameter of type box-\u003eA and return a Bool. In other words, whatever A is bound to, we only need to be able to read it.\n","summary":"When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don’t know the precise reference capability of the origin.\nWhen that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -\u003e.\nUsing this-\u003e as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box.","title":"Arrow Types aka Viewpoints","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/arrow-types.html"},{"content":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible. This can be applied to types that are related through inheritance, as well as unions and intersections. This is done at runtime, and if it fails then an error is raised.\nLet’s look at an example. The json package provides a type called JsonDoc that can attempt to parse strings as fragments of JSON. The parsed value is stored in the data field of the object, and that field’s type is the union (F64 | I64 | Bool | None | String | JsonArray | JsonObject). So if there is a JsonDoc object referenced by jsonDoc then jsonDoc.parse(\"42\") will store an I64 equal to 42 in jsonDoc.data. If the programmer wants to treat jsonDoc.data as an I64 then they can get an I64 reference to the data by using jsonDoc.data as I64.\nIn the following program, the command line arguments are parsed as Json. A running sum is kept of all of the arguments that can be parsed as I64 numbers, and all other arguments are ignored.\nuse \"json\" actor Main new create(env: Env) =\u003e var jsonSum: I64 = 0 let jd: JsonDoc = JsonDoc for arg in env.args.slice(1).values() do try jd.parse(arg)? jsonSum = jsonSum + (jd.data as I64) end end env.out.print(jsonSum.string()) When run with the arguments 2 and 4 et 7 y 15, the program’s output is 28.\nThe same thing can be done with interfaces, using as to create a reference to a more specific interface or class. Let’s say, for example, that you have a library for doing things with furry, rodent-like creatures. It provides a Critter interface which programmers can then use to create specific types of critters.\ninterface Critter fun wash(): String The programmer uses this library to create a Wombat and a Capybara class. But the Capybara class provides a new method, swim(), that is not part of the Critter class. The programmer wants to store all of the critters in an array, in order to carry out actions on groups of critters. Now assume that when capybaras finish washing they want to go for a swim. The programmer can accomplish that by using as to attempt to use each Critter object in the Array[Critter] as a Capybara. If this fails because the Critter is not a Capybara, then an error is raised; the program can swallow this error and go on to the next item.\ninterface Critter fun wash(): String class Wombat is Critter fun wash(): String =\u003e \"I'm a clean wombat!\" class Capybara is Critter fun wash(): String =\u003e \"I feel squeaky clean!\" fun swim(): String =\u003e \"I'm swimming like a fish!\" actor Main new create(env: Env) =\u003e let critters = Array[Critter].\u003epush(Wombat).\u003epush(Capybara) for critter in critters.values() do env.out.print(critter.wash()) try env.out.print((critter as Capybara).swim()) end end Specify the type of items in an array literal The as operator can be used to tell the compiler what type to use for the items in an array literal. In many cases, the compiler can infer the type, but sometimes it is ambiguous.\nFor example, in the case of the following program, the method foo can take either an Array[U32] ref or an Array[U64] ref as an argument. If a literal array is passed as an argument to the method and no type is specified then the compiler cannot deduce the correct one because there are two equally valid ones.\nactor Main fun foo(xs: (Array[U32] ref | Array[U64] ref)): Bool =\u003e // do something boring here true new create(env: Env) =\u003e foo([as U32: 1; 2; 3]) // the compiler would complain about this: // foo([1; 2; 3]) The requested type must be a valid type for the items in the array. Since these types are checked at compile time they are guaranteed to work, so there is no need for the programmer to handle an error condition.\n","summary":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible.","title":"as操作符（As Operator）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/as.html"},{"content":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony. A Jump Consistent Hash, for example, could be provided in pure Pony as follows:\n// Jump consistent hashing in Pony, with an inline pseudo random generator fun jch(key: U64, buckets: I64): I32 =\u003e var k = key var b = I64(0) var j = I64(0) while j \u003c buckets do b = j k = (k * 2862933555777941757) + 1 j = ((b + 1).f64() * (U32(1 \u003c\u003c 31).f64() / ((key \u003e\u003e 33) + 1).f64())).i64() end b.i32() Let’s say we wish to compare the pure Pony performance to an existing C function with the following header:\n#ifndef __JCH_H_ #define __JCH_H_  extern \"C\" { int32_t jch_chash(uint64_t key, uint32_t num_buckets); } #endif Note the use of extern \"C\". If the library is built as C++ then we need to tell the compiler not to mangle the function name, otherwise, Pony won’t be able to find it. For libraries built as C, this is not needed, of course.\nThe implemented would be something like:\n#include \u003cstdint.h\u003e#include \u003climits.h\u003e#include \"math.h\" // A reasonably fast, good period, low memory use, xorshift64* based prng double lcg_next(uint64_t* x) { *x ^= *x \u003e\u003e 12; *x ^= *x \u003c\u003c 25; *x ^= *x \u003e\u003e 27; return (double)(*x * 2685821657736338717LL) / ULONG_MAX; } // Jump consistent hash int32_t jch_chash(uint64_t key, uint32_t num_buckets) { uint64_t seed = key; int b = -1; int32_t j = 0; do { b = j; double r = lcg_next(\u0026seed); j = floor((b + 1)/r); } while(j \u003c num_buckets); return (int32_t)b; } We need to compile the native code to a shared library. This example is for OSX. The exact details may vary on other platforms.\nclang -fPIC -Wall -Wextra -O3 -g -MM jch.c \u003ejch.d clang -fPIC -Wall -Wextra -O3 -g -c -o jch.o jch.c clang -shared -lm -o libjch.dylib jch.o The Pony code to use this new C library is just like the code we’ve already seen for using C libraries.\n\"\"\" This is an example of Pony integrating with native code via the built-in FFI support \"\"\" use \"lib:jch\" use \"collections\" use \"random\" use @jch_chash[I32](hash: U64, bucket_size: U32) actor Main var _env: Env new create(env: Env) =\u003e _env = env let bucket_size: U32 = 1000000 var random = MT for i in Range[U64](1, 20) do let r: U64 = random.next() let hash = @jch_chash(i, bucket_size) _env.out.print(i.string() + \": \" + hash.string()) end We can now use ponyc to compile a native executable integrating Pony and our C library. And that’s all we need to do.\n","summary":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony.","title":"C ABI","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/c-abi.html"},{"content":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.\nBare functions Classic Pony functions have a receiver, which acts as an implicit argument to the function. Because of this, classic functions can’t be used as callbacks with many C APIs. Instead, you can use bare functions, which are functions with no receiver.\nYou can define a bare function by prefixing the function name with the @ symbol.\nclass C fun @callback() =\u003e ... The function can then be passed as a callback to a C API with the addressof operator.\n@setup_callback(addressof C.callback) Note that it is possible to use an object reference instead of a type as the left-hand side of the method access.\nSince bare methods have no receiver, they cannot reference the this identifier in their body (either explicitly or implicitly through field access), cannot use this viewpoint adapted types, and cannot specify a receiver capability.\nBare lambdas Bare lambdas are special lambdas defining bare functions. A bare lambda or bare lambda type is specified using the same syntax as other lambda types, with the small variation that it is prefixed with the @ symbol. The underlying value of a bare lambda is equivalent to a C function pointer, which means that a bare lambda can be directly passed as a callback to a C function. The partial application of a bare method yields a bare lambda.\nlet callback = @{() =\u003e ... } @setup_callback(callback) Bare lambdas can also be used to define structures containing function pointers. For example:\nstruct S var fun_ptr: @{()} This Pony structure is equivalent to the following C structure:\nstruct S { void(*fun_ptr)(); }; In the same vein as bare functions, bare lambdas cannot specify captures, cannot use this neither as an identifier nor as a type, and cannot specify a receiver capability. In addition, a bare lambda object always has a val capability.\nClassic lambda types and bare lambda types can never be subtypes of each other.\nAn example Consider SQLite, mentioned earlier. When the client code calls sqlite3_exec, an SQL query is executed against a database, and the callback function is called for each row returned by the SQL statement. Here’s the signature for sqlite3_exec:\ntypedef int (*sqlite3_callback)(void*,int,char**, char**); ... SQLITE_API int SQLITE_STDCALL sqlite3_exec( sqlite3 *db, /* The database on which the SQL executes */ const char *zSql, /* The SQL to be executed */ sqlite3_callback xCallback, /* Invoke this callback routine */ void *pArg, /* First argument to xCallback() */ char **pzErrMsg /* Write error messages here */ ) { ... xCallback(pArg, nCol, azVals, azCols) ... } sqlite3_callback is the type of the callback function that will be called by sqlite3_exec for each row returned by the sql statement. The first argument to the callback function is the pointer pArg that was passed to sqlite3_exec, the second argument is the number of columns in the row being processed, the third argument is data for each column, and the fourth argument is the name of each column.\nHere’s the skeleton of some Pony code that uses sqlite3_exec to query an SQLite database, with examples of both the bare method way and the bare lambda way:\nclass SQLiteClient fun client_code() =\u003e ... @sqlite3_exec[I32](db, sql.cstring(), addressof this.method_callback, this, addressof zErrMsg) ... fun @method_callback(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... class SQLiteClient fun client_code() =\u003e ... let lambda_callback = @{(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... } @sqlite3_exec[I32](db, sql.cstring(), lambda_callback, this, addressof zErrMsg) ... Focusing on the callback-related parts, the callback function is passed using addressof this.method_callback (resp. by directly passing the bare lambda) as the third argument to sqlite3_exec. The fourth argument is this, which will end up being the first argument when the callback function is called. The callback function is called in sqlite3_exec by the call to xCallback.\n","summary":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.","title":"Callbacks","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/callbacks.html"},{"content":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call. Any time you see an @ in Pony there’s an FFI going on.\nThe other key difference is that the return type of the function is specified after the function name, in square brackets. This is because the compiler needs to know what type the value returned is (if any), but has no way to determine that, so it needs you to explicitly tell it.\nThere are a few unusual things going on with the arguments to this FFI call as well. For the second argument, for which we’re passing the value 1, we’ve had to specify that this is a U64. Again this is because the compiler needs to know what size argument to use, but has no way to determine this.\nSafely does it It is VERY important that when calling FFI functions you MUST get the parameter and return types right. The compiler has no way to know what the native code expects and will just believe whatever you do. Errors here can cause invalid data to be passed to the FFI function or returned to Pony, which can lead to program crashes.\nTo help avoid bugs here Pony allows you to specify the type signatures of FFI functions in advance. Whilst you must still get the types correct the arguments you provide at each FFI call site are checked against the declared signature. This means that you must get a type wrong, in the same way, in at least 2 places for a bug to exist. This won’t help if the argument types the native code expects are different to what you think they are, but it will protect you against trivial mistakes and simple typos.\nFFI signatures are declared using the use command. Here’s an example from the standard library:\nuse @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32, parg: Pointer[U8] tag) if windows use @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64, parg: Pointer[U8] tag) if not windows class SSLContext val new create() =\u003e // set SSL_OP_NO_SSLv2 @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8]) The @ symbol tells us that the use command is an FFI signature declaration. The types specified here are considered authoritative and any FFI calls that differ are considered to be an error.\nNote that we no longer need to specify the return type at the call site, since the signature declaration has already told us what it is. However, it is perfectly acceptable to specify it again if you want to.\nThe use @ command can take a condition just like other use commands. This is useful in this case, where the Windows version of SSL_CTX_ctrl has a slightly different signature to other platforms.\nC types Many C functions require types that don’t have an exact equivalent in Pony. A variety of features is provided for these.\nFor FFI functions that have no return value (ie they return void in C) the return value specified should be [None].\nIn Pony String is an object with a header and fields, but in C a char* is simply a pointer to character data. The .cstring() function on String provides us with a valid pointer to hand to C. Our fwrite example above makes use of this for the first argument.\nPony classes correspond directly to pointers to the class in C.\nFor C pointers to simple types, such as U64, the Pony Pointer[] polymorphic type should be used, with a tag reference capability. Pointer[U8] tag should be used for void*. This can be seen in our SSL_CTX_ctrl example above.\nTo pass pointers to values to C the addressof operator can be used (previously \u0026), just like taking an address in C. This is done in the standard library to pass the address of a U64 to an FFI function that takes a uint64_t* as an out parameter:\nvar len = U64(0) @pcre2_substring_length_bynumber_8[I32](_match, i.u32(), addressof len) Get and Pass Pointers to FFI To pass and receive pointers to c structs you need to declare pointer to primitives\nprimitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Read Struct Values from FFI A common pattern in C is to pass a struct pointer to a function, and that function will fill in various values in the struct. To do this in Pony, you make a struct and then use a NullablePointer:\nstruct Winsize var height: U16 = 0 var width: U16 = 0 new create() =\u003e None let size = Winsize @ioctl(0, 21523, NullablePointer[Winsize](size)) env.out.print(size.height.string()) FFI functions raising errors FFI functions can raise Pony errors. Functions in existing C libraries are very unlikely to do this, but support libraries specifically written for use with Pony may well do.\nFFI calls to functions that might raise an error must mark it as such by adding a ? after the arguments. For example:\n@os_send[U64](_event, data.cstring(), data.size()) ? // May raise an error If a signature declaration is used then that must be marked as possibly raising an error in the same way. The FFI call site must mark it as well.\nuse @os_send[U64](ev: Event, buf: Pointer[U8] tag, len: U64) ? @os_send(_event, data.cstring(), data.size())? // May raise an error ","summary":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call.","title":"Calling C from Pony","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/calling-c.html"},{"content":"","summary":"","title":"Categories","uri":"https://damon-kwok.github.io/pony-tutorial/categories.html"},{"content":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g. With -l you can generate a C library, lib\u003cdirectory\u003e.\n--debug will skip the LLVM optimizations passes. This should not be mixed up with make config=debug, the default make configuration target. config=debug will create DWARF symbols, and add slower assertions to ponyc, but not to the generated binaries. For those, you can omit DWARF symbols with the --strip or -s option.\n--path or -p take a : separated path list as the argument and adds those to the compile-time library paths for the linker to find source packages and the native libraries, static or dynamic, being linked at compile-time or via the FFI at run-time. The system adds several paths already, e.g. on windows it queries the registry to find the compiler run-time paths, you can also use use \"lib:path\" statements in the source code and as a final possibility, you can add -p paths. But if you want the generated binary to accept such a path to find a dynamic library on your client system, you need to handle that in your source code by yourself. See the options package for this.\n--output or -o takes a directory name where the final binary is created.\n--docs or -g creates a directory of the package with documentation in readthedocs.org format, i.e. markdown with nice navigation.\nLet’s study the documentation of the builtin stdlib:\npip install mkdocs ponyc packages/stdlib --docs \u0026\u0026 cd stdlib-docs \u0026\u0026 mkdocs serve And point your web browser to http://127.0.0.1:8000 serving a live-reloading local version of the docs.\nNote that there is no built-in debugger to interactively step through your program and interpret the results. But ponyc creates proper DWARF symbols and you can step through your programs with a conventional debugger, such as GDB or LLDB.\nRuntime options for Pony programs Besides using the cli package, there are also several built-in options for the generated binary (not for use with ponyc) starting with --pony*, see ponyc --help, to tweak runtime performance. You can override the number of initial threads, tune cycle detection (CD), the garbage collector and even turn off yield, which is not really recommended.\n","summary":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g.","title":"Compiler Arguments","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/compiler-args.html"},{"content":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero. That’s right,\nlet x = I64(1) / I64(0) results in 0 being assigned to x. Baffling right? Well, yes and no. From a mathematical standpoint, it is very much baffling. From a practical standpoint, it is very much not.\nWhile Pony has Partial division:\nlet x = try I64(1) /? I64(0) else // handle division by zero end Defining division as partial leads to code littered with trys attempting to deal with the possibility of division by zero. Even if you had asserted that your denominator was not zero, you’d still need to protect against divide by zero because, at this time, the compiler can’t detect that value dependend typing.\nPony also offers Unsafe Division, which declares division by zero as undefined, as in C:\n// the value of x is undefined let x = I64(1) /~ I64(0) But declaring this case as undefined does not help us out here. As a programmer you’d still need to guard that case in order to not poison your program with undefined values or risking terminating your program with a SIGFPE. So, in order to maintain a practical API and avoid undefined behaviour, normal division on integers in Pony is defined to be 0. To avoid 0s silently creeping through your divisions, use Partial or Checked Division.\nDivide by zero on floating points In conformance with IEEE 754, floating point division by zero results in inf or -inf, depending on the sign of the numerator.\nIf you can assert that your denominator cannot be 0, it is possible to use Unsafe Division to gain some performance:\nlet x = F64(1.5) /~ F64(0.5) ","summary":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero.","title":"Divide by Zero","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/divide-by-zero.html"},{"content":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().values() do end Read struct values from FFI If you have a C struct which returns a struct with data like this\ntypedef struct { uint8_t code; float x; float y; } EGLEvent; EGLEvent getEvent() { EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height}; return e; } the you can destructure it and get the values using a tuple\ntype EGLEvent is (U8, F32, F32) (var code, var x, var y) = @getEvent[EGLEvent]() Get and pass pointers to FFI primitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Pass an Array of values to FFI (TODO) primitive _EGLConfigHandle let a = Array[U16](8) a.push(0x3040) a.push(0x4) a.push(0x3033) a.push(0x4) a.push(0x3022) a.push(0x8) a.push(0x3023) a.push(0x8) a.push(0x3024) let config = Pointer[_EGLConfigHandle] if @eglChooseConfig[U32](e_dpy, a, config, U32(1), Pointer[U32]) == 0 then env.out.print(\"eglChooseConfig failed\") end How to access command line arguments actor Main new create(env: Env) =\u003e // The no of arguments env.out.print(env.args.size().string()) for value in env.args.values() do env.out.print(value) end // Access the arguments the first one will always be the application name try env.out.print(env.args(0)?) end How to use cli to parse command line arguments use \"cli\" actor Main new create(env: Env) =\u003e let command_spec = try CommandSpec.leaf( \"pony-embed\", \"sample program\", [ OptionSpec.string(\"output\", \"output filename\", 'o') ], [ ArgSpec.string(\"input\", \"source of input\" where default' = \"-\") ] )? .\u003e add_help()? else env.exitcode(1) return end let command = match CommandParser(command_spec).parse(env.args, env.vars) | let c: Command =\u003e c | let ch: CommandHelp =\u003e ch.print_help(env.out) env.exitcode(0) return | let se: SyntaxError =\u003e env.err.print(se.string()) env.exitcode(1) return end let input_source = command.arg(\"input\").string() let output_filename = command.option(\"output\").string() env.out.print(\"Loading data from \" + input_source + \". Writing output to \" + output_filename) // ... How to write tests Just create a test.pony file\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAddition) class iso _TestAddition is UnitTest \"\"\" Adding 2 numbers \"\"\" fun name(): String =\u003e \"u32/add\" fun apply(h: TestHelper): TestResult =\u003e h.expect_eq[U32](2 + 2, 4) Some assertions you can make with the TestHelper are\nfun tag log(msg: String, verbose: Bool = false) be fail() =\u003e be assert_failed(msg: String) =\u003e fun tag assert_true(actual: Bool, msg: String = \"\") ? fun tag expect_true(actual: Bool, msg: String = \"\"): Bool fun tag assert_false(actual: Bool, msg: String = \"\") ? fun tag expect_false(actual: Bool, msg: String = \"\"): Bool fun tag assert_error(test: ITest, msg: String = \"\") ? fun tag expect_error(test: ITest box, msg: String = \"\"): Bool fun tag assert_is (expect: Any, actual: Any, msg: String = \"\") ? fun tag expect_is (expect: Any, actual: Any, msg: String = \"\"): Bool fun tag assert_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\") ? fun tag expect_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\"): Bool Operator overloading (easy for copy and paste) fun add(other: A): A fun sub(other: A): A fun mul(other: A): A fun div(other: A): A fun rem(other: A): A fun mod(other: A): A fun eq(other: A): Bool fun ne(other: A): Bool fun lt(other: A): Bool fun le(other: A): Bool fun ge(other: A): Bool fun gt(other: A): Bool fun shl(other: A): A fun shr(other: A): A fun op_and(other:A): A fun op_or(other: A): A fun op_xor(othr: A): A Create empty functions in a class class Test fun alpha() =\u003e \"\"\" \"\"\" fun beta() =\u003e \"\"\" \"\"\" How to create Arrays with values Single values can be separated by semicolon or newline.\nlet dice: Array[U32] = [1; 2; 3 4 5 6 ] How to modify a lexically captured variable in a closure actor Main fun foo(n:U32): {ref(U32): U32} =\u003e var s: Array[U32] = Array[U32].init(n, 1) {ref(i:U32)(s): U32 =\u003e try s(0) = s(0) + i s(0) else 0 end } new create(env:Env) =\u003e var f = foo(5) env.out.print(f(10).string()) env.out.print(f(20).string()) ","summary":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().","title":"Examples","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/examples.html"},{"content":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver. The use of assignment expressions like x = 42 is quite rare so we don’t think many folks will be bitten by this. However, it’s definitely something you want to be aware of. Also remember that if fn were to be called, it would be called with 0 (the result of the assignment expression).\n","summary":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver.","title":"Function Call Side Effects","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/side-effect-ordering-in-function-call-expressions.html"},{"content":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up. This sucks if you want predictable completion of sections of code. Most of the time, your function will finish in less than a millisecond but every now and then, its paused during execution to GC. There are advantages to this approach. Whenever you run low on memory, the GC can attempt to free some memory and get you more. In general, this is how people expect Pony’s garbage collector to work. As you might guess though, it doesn’t work that way.\nGarbage Collection in Pony Garbage collection is never attempted on any actor while it is executing a behavior. This gives you very predictable performance when executing behaviors but also makes it easy to grab way more memory than you intend to. Let’s take a look at how that can happen via the “long-running behavior problem”.\nLong running behaviors and memory Here’s a typical “I’m learning Pony” program:\nactor Main new create(env: Env) for i in Range(1, 2_000_000) do ... something that uses up heap ... end This program will never garbage collect before exiting. create is run as a behavior on actors which means that no garbage collection will occur while it’s running. Long loops in behaviors are a good way to exhaust memory. Don’t do it. If you want to execute something in such a fashion, use a Timer.\n","summary":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up.","title":"Garbage Collection","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/garbage-collection.html"},{"content":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.\nPony-ORCA, yes the killer whale, is based on ideas from ownership and deferred, distributed, weighted reference counting. It adapts messaging systems of actors to keep the reference count consistent. The main challenges in concurrent garbage collection are the detection of cycles of sleeping actors in the actor’s graph, in the presence of the concurrent mutation of this graph. With message passing, you get deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph).\n  Soundness: the technique collects only dead actors.\n  Completeness: the technique collects all dead actors eventually.\n  Concurrency: the technique does not require a stop-the-world step, clocks, time stamps, versioning, thread coordination, actor introspection, shared memory, read/write barriers or cache coherency.\n  The type system ensures at compile time that your program can never have data races. It’s deadlock free… Because Pony has no locks!\nWhen an actor has completed local execution and has no pending messages on its queue, it is blocked. An actor is dead, if it is blocked and all actors that have a reference to it are blocked, transitively. A collection of dead actors depends on being able to collect closed cycles of blocked actors.\nThe Pony type system guarantees race and deadlock free concurrency and soundness by adhering to the following principles:\nPony-ORCA characteristics   An actor may perform garbage collection concurrently with other actors while they are executing any kind of behaviour.\n  An actor may decide whether to garbage collect an object solely based on its own local state, without consultation with or inspecting the state of any other actor.\n  No synchronization between actors is required during garbage collection, other than potential message sends.\n  An actor may garbage collect between its normal behaviours, i.e. it need not wait until its message queue is empty.\n  Pony-ORCA can be applied to several other programming languages, provided that they satisfy the following two requirements:\n  Actor behaviours are atomic.\n  Message delivery is causal. Causal: messages arrive before any messages they may have caused if they have the same destination. So there needs to be some kind of causal ordering guarantee, but fewer requirements than with comparable concurrent, fast garbage collectors.\n    ","summary":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.","title":"Garbage Collection with Pony-ORCA","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/garbage-collection.html"},{"content":"你已经成功的安装了Pony编译器，来试着编写第一个Pony程序：输出\"hello,world!\"。首先，创建一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 目录名称重要吗？ 重要。这将是程序编译后的文件名！默认情况下，编译程序生成的可执行文件将使用源码的目录名，想要的文件名需要在命令行上使用--bin-name或-b选项指。\n代码 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件名重要吗？ 对编译器来说不重要。 Pony只关心源文件的扩展名.pony，不关心文件名。但文件名对你来说很重要！给源文件起个好名字，可以方便以后定位代码。\n在文件中输入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 如果想在Docker中使用Pony，可以这么做：\n$ docker run -v Some_Absolute_Path/helloworld:/src/main ponylang/ponyc 注意，需要将目录路径替换成你自己的。\n你会发现，它在当前目录进行了构建，.，Pony对代码进行了优化，并创建了一些目标文件（如果你不知道那是什么，不用担心） ，然后将其链接到了一个可执行文件中。如果你是C/C++程序员，那对你来说可能是有意义的，否则你可以忽略它。\n构建过程中也进行链接吗？ 没错，Pony不需要额外的构建程序（例如make），自己能处理（包括在链接到C库时处理依赖项的顺序，后面章节会介绍）。\n运行程序 运行程序：\n$ ./helloworld Hello, world! 恭喜你，完成了第一个Pony程序！下节我们讲解代码的含义。\n","summary":"你已经成功的安装了Pony编译器，来试着编写第一个Pony程序：输出\"hello,world!\"。首先，创建一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 目录名称重要吗？ 重要。这将是程序编译后的文件名！默认情况下，编译程序生成的可执行文件将使用源码的目录名，想要的文件名需要在命令行上使用--bin-name或-b选项指。\n代码 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件名重要吗？ 对编译器来说不重要。 Pony只关心源文件的扩展名.pony，不关心文件名。但文件名对你来说很重要！给源文件起个好名字，可以方便以后定位代码。\n在文件中输入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 如果想在Docker中使用Pony，可以这么做：\n$ docker run -v Some_Absolute_Path/helloworld:/src/main ponylang/ponyc 注意，需要将目录路径替换成你自己的。\n你会发现，它在当前目录进行了构建，.，Pony对代码进行了优化，并创建了一些目标文件（如果你不知道那是什么，不用担心） ，然后将其链接到了一个可执行文件中。如果你是C/C++程序员，那对你来说可能是有意义的，否则你可以忽略它。\n构建过程中也进行链接吗？ 没错，Pony不需要额外的构建程序（例如make），自己能处理（包括在链接到C库时处理依赖项的顺序，后面章节会介绍）。\n运行程序 运行程序：\n$ ./helloworld Hello, world! 恭喜你，完成了第一个Pony程序！下节我们讲解代码的含义。","title":"Hello World","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/hello-world.html"},{"content":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.   do loop statement, or after a with statement   else conditional statement in if, for, while, repeat, try (as a catch block), match   elseif conditional statement, also used with ifdef   embed embed a class as a field of another class   end ending of: if then, ifdef, while do, for in, repeat until, try, object, lambda, recover, match   error raises an error   for loop statement   fun define a function, executed synchronously   if (1) conditional statement    (2) to define a guard in a pattern match   ifdef when defining a build flag at compile time: ponyc –D “foo”   in used in a for in - loop statement   interface used in structural subtyping   is (1) used in nominal subtyping    (2) in type aliasing    (3) identity comparison   isnt negative identity comparison   iso reference capability – read and write uniqueness   lambda to make a closure   let declaration of immutable variable: you can’t rebind this name to a new value   match pattern matching   new constructor   not logical negation   object to make an object literal   primitive declares a primitive type   recover removes the reference capability of a variable   ref reference capability – object (on which function is called) is mutable   repeat loop statement   return to return early from a function   tag reference capability – neither readable nor writeable, only object identity   then (1) in if conditional statement    (2) as a (finally) block in try   this the current object   trait used in nominal subtyping: class Foo is TraitName   trn reference capability – write uniqueness, no other actor can write to the object   try error handling   type to declare a type alias   until loop statement   use (1) using a package    (2) using an external library foo: use “lib:foo”    (3) declaration of an FFI signature    (4) add a search path for external libraries: use “path:/usr/local/lib”   var declaration of mutable variable: you can rebind this name to a new value   val reference capability – globally immutable object   where when specifying named arguments   while loop statement   with ensure disposal of an object    ","summary":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.","title":"Keywords","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/keywords.html"},{"content":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.\nCompatible type: Two types are compatible if there can be any single object which is an instance of both types. Note that a suitable type for the single object does not have to have been defined, as long as it could be. For example, any two traits are compatible because a class could be defined that provides both of them, even if such a class has not been defined. Conversely, no two classes can ever be compatible because no object can be an instance of both.\nCompound type: A type combining multiple other types, ie union, intersection, and tuple. Opposite of a single type.\nConcrete type: An actor, class or primitive.\nCurly brackets: { }. Synonymous with braces.\nDeclaration and definition: synonyms for each other, we do not draw the C distinction between forward declarations and full definitions.\nDefault method body: Method body defined in a trait and optionally used by concrete types.\nEntity: Top level definition within a file, ie alias, trait, actor, class, primitive.\nExplicit type: An actor, class or primitive.\nMember: Method or field.\nMethod: Something callable on a concrete type/object. Function, behaviour or constructor.\nOverride: When a concrete type has its own body for a method with a default body provided by a trait.\nParentheses: ( ). Synonymous with round brackets.\nProvide: An entity’s usage of traits and the methods they contain. Equivalent to implements or inherits from.\nRound brackets: ( ). Synonymous with parentheses.\nSingle type: Any type which is not defined as a collection of other types. Actors, classes, primitives, traits and structural types are all single types. Opposite of a compound type.\nSquare brackets: [ ]\nTrait clash: A trait clashes with another type if it contains a method with the same name, but incompatible signature as a method in the other type. A clashing trait is incompatible with the other type. Traits can clash with actors, classes, primitives, intersections, structural types and other traits.\n","summary":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.","title":"Lexicon","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/lexicon.html"},{"content":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified. This is particularly useful when the library has slightly different names on different platforms.\nHere’s a real example from the standard library:\nuse \"path:/usr/local/opt/libressl/lib\" if osx use \"lib:ssl\" if not windows use \"lib:crypto\" if not windows use \"lib:libssl-32\" if windows use \"lib:libcrypto-32\" if windows primitive _SSLInit \"\"\" This initialises SSL when the program begins. \"\"\" fun _init() =\u003e @SSL_load_error_strings[None]() @SSL_library_init[I32]() On Windows, we use the libraries “libssl-32” and “libcrypto-32” and on other platforms we use “ssl” and “crypto”. These contain the FFI functions SSL_library_init and SSL_load_error_strings (amongst others).\nBy default the Pony compiler will look for the libraries to link in the standard places, however, that is defined on the build platform. However, it may be necessary to look in extra places. The use \"path:...\" command allows this. The specified path is added to the library search paths for the remainder of the current file. The example above uses this to add the path “/usr/local/opt/libressl/lib” for OSX. This is required because the library is provided by brew, which installs things outside the standard library search paths.\nIf you are integrating with existing libraries, that is all you need to do.\n","summary":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified.","title":"Linking to C Libraries","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/linking-c.html"},{"content":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory). You can have millions of actors at the same time.  But Caveat Emptor But Pony can be used to create C libraries and Pony can use external C libraries via the FFI which does not have this luxury.\nSo you can use any external C library out there, but the question is if you need to and if you should.\nThe biggest problem is external heap memory, created by an external FFI call, or created to support an external call. But external stack space might also need some thoughts, esp. when being created from actors.\nPony does have finalisers (callbacks which are called by the garbage collector which may be used to free resources allocated by an FFI call); However, the garbage collector is not timely (as with pure reference counting), it is not triggered immediately when some object goes out of scope.\nA blocked actor will keep its memory allocated, only a dead actor will release it eventually.\nAnd, long-running actors Might cause unexpected out of memory errors, since the GC is not yet triggered on an out-of-memory segfault or stack exhaustion.\n…\n","summary":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory).","title":"Memory Allocation at Runtime","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/memory-allocation.html"},{"content":"Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.\nPassing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.\nBut what if we want to pass a mutable object from one actor to another? To do that, we need to be sure that the actor that is sending the mutable object also gives up the ability to both read from and write to that object.\nThis is exactly what iso does. It is read and write unique, there can only be one reference at a time that can be used for reading or writing. If you send an iso object to another actor, you will be giving up the ability to read from or write to that object.\nSo I should use iso when I want to pass a mutable object between actors? Yes! If you don’t need to pass it, you can just use ref instead.\nSharing If you want to share an object amongst actors, then we have to make one of the following guarantees:\n Either no actor can write to the object, in which case any actor can read from it, or Only one actor can write to the object, in which case other actors can neither read from or write to the object.  The first guarantee is exactly what val does. It is globally immutable, so we know that no actor can ever write to that object. As a result, you can freely send val objects to other actors, without needing to give up the ability to read from that object.\nSo I should use val when I want to share an immutable object amongst actors? Yes! If you don’t need to share it, you can just use ref instead, or box if you want it to be immutable.\nThe second guarantee is what tag does. Not the part about only one actor writing (that’s guaranteed by any mutable reference capability), but the part about not being able to read from or write to an object. That means you can freely pass tag objects to other actors, without needing to give up the ability to read from or write to that object.\nWhat’s the point in sending a tag reference to another actor if it can’t then read or write the fields? Because tag can be used to identify objects and sometimes that’s all you need. Also, if the object is an actor you can call behaviours on it even though you only have a tag.\nSo I should use tag when I want to share the identity of a mutable object amongst actors? Yes! Or, really, the identity of anything, whether it’s mutable, immutable, or even an actor.\nReference capabilities that can’t be sent You may have noticed we didn’t mention trn, ref, or box as things you can send to other actors. That’s because you can’t do it. They don’t make the guarantees we need in order to be safe.\nSo when should you use those reference capabilities?\n Use ref when you need to be able to change an object over time. On the other hand, if your program wouldn’t be any slower if you used an immutable type instead, you may want to use a val anyway. Use box when you don’t care whether the object is mutable or immutable. In other words, you want to be able to read it, but you don’t need to write to it or share it with other actors. Use trn when you want to be able to change an object for a while, but you also want to be able to make it globally immutable later.  ","summary":"Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.\nPassing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.","title":"Passing and Sharing References","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html"},{"content":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug\nThey can also use the operators and, or, xor and not. As with other expressions in Pony, parentheses must be used to indicate precedence if more than one of and, or and xor is used.\nAny use command whose condition evaluates to false is ignored.\n","summary":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug","title":"Platform-dependent code","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/platform-dependent-code.html"},{"content":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running). For example, if using bash, add the following to your ~/.bashrc:\nexport PONYPATH=$PONYPATH:$HOME/pony (Then run source ~/.bashrc to add this variable to a running session. New terminal session will automatically source ~/.bashrc.)\nWindows  Create folder at C:\\Users\\\u003cyourusername\u003e\\pony. Right click on “Start” and click on “Control Panel”. Select “System and Security”, then click on “System”. From the menu on the left, select the “Advanced systems settings”. Click the “Environment Variables” button at the bottom. Click “New” from the “User variables” section. Type PONYPATH into the “Variable name” field. Type %PONYPATH%;%USERPROFILE%\\pony into the “Variable value” field. Click OK.  You can also add to PONYPATH from the command prompt via:\nsetx PONYPATH %PONYPATH%;%USERPROFILE%\\pony ","summary":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running).","title":"PONYPATH","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/ponypath.html"},{"content":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:\n actor class struct primitive trait interface new fun be if (only as a condition, not as a guard) ifdef elseif else while repeat until for match | (only as a case in a match expression) recover object { (only as a lambda) with try then (only when part of a try block)  The effect of annotations Annotations are entirely implementation-specific. In other words, the Pony compiler (or any other tool that processes Pony programs) is free to take any action for any annotation that it encounters, including not doing anything at all. Annotations starting with ponyint are reserved by the compiler for internal use and shouldn’t be used by external tools.\nAnnotations in the Pony compiler The following annotations are recognised by the Pony compiler. Note that the Pony compiler will ignore annotations that it doesn’t recognise, as well as the annotations described here if they’re encountered in an unexpected place.\npacked Recognised on a a struct declaration. Removes padding in the associated struct, making it ABI-compatible with a packed C structure with compatible members (declared with the __attribute__((packed)) extension or the #pragma pack preprocessor directive in many C compilers).\nstruct \\packed\\ MyPackedStruct var x: U8 var y: U32 likely and unlikely Recognised on a conditional expression (if, while, until and | (as a pattern matching case)). Gives optimisation hints to the compiler on the likelihood of a given conditional expression.\nif \\likely\\ cond then foo end while \\unlikely\\ cond then bar end repeat baz until \\likely\\ cond end match obj | \\likely\\ expr =\u003e foo | \\unlikely\\ let capt: T =\u003e bar end ","summary":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:","title":"Program Annotations","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/annotations.html"},{"content":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows. Most recursive functions can be easily transformed into tail-recursive function which are less problematic. A tail-recursive function is a function in which the recursive call is the last instruction of the function. Here is an example with a factorial function:\nfun recursive_factorial(x: U32): U32 =\u003e if x == 0 then 1 else x * recursive_factorial(x - 1) end fun tail_recursive_factorial(x: U32, y: U32): U32 =\u003e if x == 0 then y else tail_recursive_factorial(x - 1, x * y) end The compiler can optimise a tail-recursive function to a loop, completely avoiding call stack growth. Note that this is an optimisation which is only performed in release builds (i.e. builds without the -d flag passed to ponyc.) If you need to avoid stack growth in debug builds as well then you have to write your function as a loop manually.\nIf the tail-recursive version of your algorithm isn’t practical to implement, there are other ways to control stack growth depending on your algorithm. For example, you can implement your algorithm using an explicit stack data structure instead of implicitly using the call stack to store data.\nNote that light recursion usually doesn’t cause problems. Unless your amount of recursive calls is in the hundreds, you’re unlikely to encounter this problem.\n","summary":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows.","title":"Recursion","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/recursion.html"},{"content":"At this point, it’s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It’s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you’ll get a better intuition with them.\nIn the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.\nIt is also the origin of the concept behind each capability in Pony, in the sense of how each capability denies certain properties to its reference – in other words, which guarantees a capability makes. We will explain what that actually means before presenting the matrix.\nLocal and global aliases Before anything else, we want to clarify what we mean by “local” and “global” aliases.\nA local alias is a reference to the same variable that exists in the same actor. Whenever you pass a value around, and it’s not the argument of an actor’s behavior, this is the kind of alias we are working with.\nOn the other hand, a global alias is a reference to the same variable that can exist in a different actor. That is, it describes the properties of how two or more actors could interact with the same reference.\nEach reference capability in Pony is actually a pair of local guarantees and global guarantees. For instance, ref doesn’t deny any read/write capabilities inside the actor, but denies other actors from reading or writing to that reference.\nYou may recall from the Reference Capability Guarantees section that mutable references cannot be safely shared between actors, while immutable references can be read by multiple actors. In general, global properties are always as restrictive or more restrictive than the local properties to that reference - what is denied globally must also be denied locally. For example, it’s not possible to write to an immutable reference in either a global or local alias. It’s also not possible to read from or write to an opaque reference, tag. Therefore, some combinations of local and global aliases are impossible, and have no designated capabilities.\nReference capability matrix Without further ado, here’s the reference capability matrix:\n      Deny global read/write aliases Deny global write aliases Don’t deny any global aliases     Deny local read/write aliases iso     Deny local write aliases trn val    Don’t deny any local aliases ref box tag     (Mutable) (Immutable) (Opaque)     In the context of the matrix, “denying a capability” means that any other alias to that reference is not allowed to do that action. For example, since trn denies other local write aliases (but allows reads), this is the only reference that allows writing to the object; and since it denies both read and write aliases to other actors, it’s safe to write inside this actor, thus being mutable. And since box does not break any guarantees that trn makes (local reads are allowed, but global writes are forbidden), we can create box aliases to a trn reference.\nYou’ll notice that the top-right side is empty. That’s because, as previously discussed, we cannot make any local guarantees that are more restrictive than the global guarantees, or we’d end up with invalid capabilities that could be written to in this actor but read somewehre else at the same time.\nThe matrix also helps visualizing other concepts previously discussed in this chapter:\n Sendable capabilities. If we want to send references to a different actor, we must make sure that the global and local aliases make the same guarantees. It’d be unsafe to send a trn to another actor, since we could possibly hold box references locally. Only iso, val, and tag have the same global and local restrictions – all of which are in the main diagonal of the matrix. Ephemeral subtyping. If we have an ephemeral capability (for instance, iso^ after consuming an isolated variable), we can be more permissive for the new alias, i.e. remove restrictions, such as allowing local aliases with read capabilities, and receive the reference into a trn^; or both read and write, which gives us ref. The same is true for more global alias, and we can get val, box, or tag. Visually, this would be equivalent to walking downwards and/or to-the-right starting from the capability in the matrix. Recovering capabilities. This is when we “lift” a capability, from a mutable reference to iso or an immutable reference to val. The matrix equivalent would be walking upwards starting from the capability – quite literally lifting in this case. Aliasing. With a bit more of imagination, it’s possible to picture aliasing iso and trn as reflecting them on the secondary diagonal of the matrix onto tag and box, respectively. The reason for that lies on which restrictions arise from the local guarantees. An iso doesn’t allow different aliases to read or write, which tag enforces; and trn doesn’t allow different aliases to write but allows them to do local reads, fitting box's restrictions.  We want to emphasize that trying to apply the reference capability matrix to some capabilities problems is not guaranteed to work (viewpoint adaptation is one example). The matrix is the original definition of the reference capabilities, presented here as a mnemonic device. Whenever you struggle with reference capabilities, we recommend that you reread the corresponding section of this chapter to understand why something is not allowed by the compiler.\n","summary":"At this point, it’s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It’s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you’ll get a better intuition with them.\nIn the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.","title":"Reference Capability Matrix","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-matrix.html"},{"content":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time. You do not want to do this. Do not call FFI code that doesn’t return in a reasonable amount of time.\nLong running behaviors Another way to monopolize a scheduler thread is to write a behavior that never exits or takes a really long time to exit.\nbe bad_citizen() =\u003e while true do _env.out.print(\"Never gonna give you up. Really gonna make you cry\") end That is some seriously bad citizen code that will hog a scheduler thread forever. Call that behavior a few times and your program will grind to a halt. If you find yourself writing code with loops that will run for a long time, stop and rethink your design. Take a look at the Timer class from the standard library. Combine that together with a counter in your class and you can execute the same behavior repeatedly while yielding your scheduler thread to other actors.\n","summary":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time.","title":"Scheduling","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/scheduling.html"},{"content":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object. A Serialised object can be created in one of two ways:\n calling the create(...) constructor with the SerialiseAuth authority and the object to serialize calling the input(...) constructor with the DeserialiseAuth authority and an Array[U8] that represents the object to deserialise This intermediate object can then be used to either: generate an Array[U8] that represents the object by calling the output(...) method with the OutputSerialisedAuth authority generate a deserialised object by calling the apply(...) method with the InputSerialisedAuth authority  This program serialises and deserialise an object, and checks that the fields of the original object are the same as the fields of the deserialised object.\nuse \"serialise\" class Foo is Equatable[Foo box] let _s: String let _u: U32 new create(s: String, u: U32) =\u003e _s = s _u = u fun eq(foo: Foo box): Bool =\u003e (_s == foo._s) and (_u == foo._u) actor Main new create(env: Env) =\u003e try let ambient = env.root as AmbientAuth // get serialization authorities let serialise = SerialiseAuth(ambient) let output = OutputSerialisedAuth(ambient) let deserialise = DeserialiseAuth(ambient) let input = InputSerialisedAuth(ambient) let foo1 = Foo(\"abc\", 123) // serialisation let sfoo = Serialised(serialise, foo1)? let bytes_foo: Array[U8] val = sfoo.output(output) env.out.print(\"serialised representation is \" + bytes_foo.size().string() + \" bytes long\") // deserialisation let dfoo = Serialised.input(input, bytes_foo) let foo2 = dfoo(deserialise)? as Foo env.out.print(\"(foo1 == foo2) is \" + (foo1 == foo2).string()) else env.err.print(\"there was an error\") end Caveats There are several things to keep in mind when using Pony’s serialisation system:\n Serialised objects will currently only work when passed between two running instances of the same Pony executable. You cannot pass objects between different Pony programs, nor can you pass them between different versions of the same program. Objects with embed fields will not be properly serialised. Objects with Pointer fields must use the custom serialisation mechanism or else the Pointer fields will be null when the object is deserialised. For information on how to handle these kinds of fields, please see the discussion of custom serialisation and deserialisation below.  Custom Serialisation and Deserialisation Pony objects can have Pointer fields that store pointers to memory that contains things that are opaque to Pony but that may be useful to code that is called via FFI. Because the objects that Pointer fields point to are opaque, Pony cannot serialise and deserialise them by itself. However, Pony’s serialisation system provides a way for the programmer to specify how the objects pointed to by these fields should be serialised and deserialised. This system is called custom serialisation.\nSince Pointer fields are opaque to Pony, it is assumed that the serialisation and deserialisation code will be written in another language that knows how to read the object referenced by the pointers.\nCustom Serialisation In order to serialise an object from a pointer field, Pony needs to know how much space to set aside for that object and how to write a representation of that object into the reserved space. The programmer must provide two methods on the object:\n fun _serialise_space(): USize – This method returns the number of bytes that must be reserved for the object. fun _serialise(bytes: Pointer[U8] tag) – This method receives a pointer to the memory that has been set aside for serialising the object. The programmer must not write more bytes than were returned by the _serialise_space method.  Custom Deserialisation Custom deserialisation is handled by a fun ref _deserialise(bytes: Pointer[U8] tag) method. This method receives a pointer to the character array that stores the serialised representation of the object (or objects) that the Pointer fields should point to. The programmer must copy out any bytes that will be used by the deserialised object.\nThe custom deserialization method is expected to modify the values of the objects Pointer fields, so the fields must be declared var so that they can be modified.\nConsiderations Fixed Versus Variable Object Sizes The programmer must write their custom serialisation and deserialisation code in such a way that it is aware of how many bytes are available in the byte arrays that are passed to the methods. If the objects are always of a fixed size then the functions can read and write than many bytes to the buffer. However, if the objects are of varying sizes (for example, if the object was a string), then the serialized representation must include information that the deserialisation code can use to ensure that it does not read beyond the end of the memory occupied by the object. The custom serialisation system does not provide a mechanism for doing this, so it is up to the program to choose a mechanism and implement it. In the case of a string, the serialisation format could consist of a 4-byte header that encodes the length of the string, followed by a string of the specified length. This additional four bytes must be included in the value returned by _serialise_space(). The deserialisation function would then start by reading the first four bytes of the array to obtain the size of the string and then read only that many bytes from the array.\nClasses With Multiple Pointer Fields If a class has more than one Pointer field then all of those fields must be handled by the custom serialisation and deserialisation methods for that class; there are not methods for each field. For example, if a class has three Pointer fields then the _serialise_space() method must return the total number of bytes required to serialise the objects from all three fields.\nExample Assume we have a Pony class with a field that is a pointer to a C string. We would like to be able to serialise and deserialise this object. In order to do that, the Pony class implements the methods _serialise_space(...), _serialise(...), and _deserialise(...). These methods, in turn, call C functions that calculate the number of bytes needed to serialise the string and serialise and deserialise it. In this example the serialised string is represented by a four-byte big-endian number that represents the length of the string, followed by the string itself without the terminating null. So if the C string is hello world\\0 then the serialised string is \\0x00\\0x00\\0x00\\0x0Bhello world (where the first four bytes of the serialised string are a big-endian representation of the number 0x0000000B, which is 11).\nuse \"serialise\" use \"lib:custser\" class CStringWrapper var _cstr: Pointer[U8] tag new create(cstr: Pointer[U8] tag) =\u003e _cstr = cstr fun _serialise_space(): USize =\u003e @serialise_space[USize](_cstr) fun _serialise(bytes: Pointer[U8] tag) =\u003e @serialise[None](bytes, _cstr) fun ref _deserialise(bytes: Pointer[U8] tag) =\u003e _cstr = @deserialise[Pointer[U8] tag](bytes) fun print() =\u003e @printf[I32](_cstr) actor Main new create(env: Env) =\u003e let csw = CStringWrapper(@get_string[Pointer[U8]]()) csw.print() try let ambient = env.root as AmbientAuth let serialise = SerialiseAuth(ambient) let deserialise = DeserialiseAuth(ambient) let sx = Serialised(serialise, csw)? let y = sx(deserialise)? as CStringWrapper y.print() else env.err.print(\"there was an error\") end // custser.c  #include \u003cstdlib.h\u003e#include \u003cstring.h\u003e extern char *get_string() { return \"hello world\\n\"; } extern size_t serialise_space(char *s) { // space for the size and the string (without the null)  return 4 + strlen(s); } extern void serialise(char *buff, char *s) { size_t sz = strlen(s); unsigned char *ubuff = (unsigned char *) buff; // write the size as a 32-bit big-endian integer  ubuff[0] = (sz \u003e\u003e 24) \u0026 0xFF; ubuff[1] = (sz \u003e\u003e 16) \u0026 0xFF; ubuff[2] = (sz \u003e\u003e 8) \u0026 0xFF; ubuff[3] = sz \u0026 0xFF; // copy the string  strncpy(buff + 4, s, sz); } extern char *deserialise(char *buff) { unsigned char *ubuff = (unsigned char *) buff; size_t sz = (ubuff[0] \u003c\u003c 24) + (ubuff[1] \u003c\u003c 16) + (ubuff[2] \u003c\u003c 8) + ubuff[3]; char *s = malloc(sizeof(char) * sz + 1); memcpy(s, buff + 4, sz); s[sz] = '\\0'; return s; } ","summary":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object.","title":"Serialisation","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/serialisation.html"},{"content":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .\u003e Chaining   ^ Ephemeral   @ FFI   \u0026 Intersection   =\u003e Match arrow   ~ Partial application   ? Partial function   ' Prime   \u003c: Subtype    Here is a more elaborate explanation of Pony’s use of special characters: (a line with (2) or (3) means an alternate usage of the symbol of the previous line)\n   Symbol Usage     , to separate parameters in a function signature, or the items of a tuple   . (1) to call a field or a function on a variable (field access or method call)    (2) to qualify a type/method with its package name   .\u003e to call a method on an object and return the receiver (chaining)   ' used as alternative name in parameters (prime)   \" to delineate a literal string   \"\"\" to delineate a documentation string   ( (1) start of line: start of a tuple    (2) middle of line: method call   () (1) parentheses, for function or behavior parameters    (2) making a tuple (values separated by ,)    (3) making an enumeration (values separated by |)   [ (1) start of line: start of an array literal    (2) middle of line: generic formal parameters   [] (1) to indicate a generic type, for example Range[U64]    (2) to indicate the return type of an FFI function call   {} a function type   : (1) after a variable: is followed by the type name    (2) to indicate a function return type    (3) a type constraint   ; only used to separate expressions on the same line   = (1) (destructive) assignment    (2) in: use alias = packname    (3) supply default argument for method    (4) supply default type for generics   ! (1) boolean negation    (2) a type that is an alias of another type   ? (1) partial functions    (2) a call to a C function that could raise an error   - (1) start of line: unary negation    (2) middle of line: subtraction   _ (1) to indicate a private variable, constructor, function, behavior    (2) to ignore a tuple item in a pattern match   ~ partial application   ^ an ephemeral type   | (1) separates the types in an enumeration (the value can be any of these types)    (2) starts a branch in a match   \u0026 (1) separates the types in a complex type (the value is of all of these types)    (2) intersection   @ FFI call   // comments   /* */ multi-line or block comments   =\u003e (1) start of a function body    (2) starts the code of a matching branch   -\u003e (1) arrow type    (2) viewpoint   ._i where i = 1,2,… means the ith item of a tuple   \u003c: “is a subtype of” or “can be substituted for”    ","summary":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .","title":"Symbol Lookup Cheatsheet","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/symbol-lookup-cheatsheet.html"},{"content":"","summary":"","title":"Tags","uri":"https://damon-kwok.github.io/pony-tutorial/tags.html"},{"content":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.\nWhen any assertion function fails the test is counted as a fail. However, tests can also indicate failure by raising an error in the test function.\nExample program To use PonyTest simply write a class for each test and a TestList type that tells the PonyTest object about the tests. Typically the TestList will be Main for the package.\nThe following is a complete program with 2 trivial tests.\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAdd) test(_TestSub) class iso _TestAdd is UnitTest fun name(): String =\u003e \"addition\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](4, 2 + 2) class iso _TestSub is UnitTest fun name(): String =\u003e \"subtraction\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](2, 4 - 2) The make() constructor is not needed for this example. However, it allows for easy aggregation of tests (see below) so it is recommended that all test Mains provide it.\nMain.create() is called only for program invocations on the current package. Main.make() is called during aggregation. If so desired extra code can be added to either of these constructors to perform additional tasks.\nTest names Tests are identified by names, which are used when printing test results and on the command line to select which tests to run. These names are independent of the names of the test classes in the Pony source code.\nArbitrary strings can be used for these names, but for large projects, it is strongly recommended to use a hierarchical naming scheme to make it easier to select groups of tests.\nAggregation Often it is desirable to run a collection of unit tests from multiple different source files. For example, if several packages within a bundle each have their own unit tests it may be useful to run all tests for the bundle together.\nThis can be achieved by writing an aggregate test list class, which calls the list function for each package. The following is an example that aggregates the tests from packages foo and bar.\nuse \"ponytest\" use foo = \"foo\" use bar = \"bar\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e foo.Main.make().tests(test) bar.Main.make().tests(test) Aggregate test classes may themselves be aggregated. Every test list class may contain any combination of its own tests and aggregated lists.\nLong tests Simple tests run within a single function. When that function exits, either returning or raising an error, the test is complete. This is not viable for tests that need to use actors.\nLong tests allow for delayed completion. Any test can call long_test() on its TestHelper to indicate that it needs to keep running. When the test is finally complete it calls complete() on its TestHelper.\nThe complete() function takes a Bool parameter to specify whether the test was a success. If any asserts fail then the test will be considered a failure regardless of the value of this parameter. However, complete() must still be called.\nSince failing tests may hang, a timeout must be specified for each long test. When the test function exits a timer is started with the specified timeout. If this timer fires before complete() is called the test is marked as a failure and the timeout is reported.\nOn a timeout, the timed_out() function is called on the unit test object. This should perform whatever test specific tidy up is required to allow the program to exit. There is no need to call complete() if a timeout occurs, although it is not an error to do so.\nNote that the timeout is only relevant when a test hangs and would otherwise prevent the test program from completing. Setting a very long timeout on tests that should not be able to hang is perfectly acceptable and will not make the test take any longer if successful.\nTimeouts should not be used as the standard method of detecting if a test has failed.\nExclusion groups By default, all tests are run concurrently. This may be a problem for some tests, eg if they manipulate an external file or use a system resource. To fix this issue any number of tests may be put into an exclusion group.\nNo tests that are in the same exclusion group will be run concurrently.\nExclusion groups are identified by name, arbitrary strings may be used. Multiple exclusion groups may be used and tests in different groups may run concurrently. Tests that do not specify an exclusion group may be run concurrently with any other tests.\nThe command line option “–sequential” prevents any tests from running concurrently, regardless of exclusion groups. This is intended for debugging rather than standard use.\nTear down Each unit test object may define a tear_down() function. This is called after the test has finished allowing the tearing down of any complex environment that had to be set up for the test.\nThe tear_down() function is called for each test regardless of whether it passed or failed. If a test times out tear_down() will be called after timed_out() returns.\nWhen a test is in an exclusion group, the tear_down() call is considered part of the tests run. The next test in the exclusion group will not start until after tear_down() returns on the current test.\nThe test’s TestHelper is handed to tear_down() and it is permitted to log messages and call assert functions during tear down.\nAdditional resources You can learn more about PonyTest specifics by checking out the API documentation. There’s also a testing section in the Pony Patterns book.\n","summary":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.","title":"Testing with Ponytest","uri":"https://damon-kwok.github.io/pony-tutorial/testing/ponytest.html"},{"content":"We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you’ve called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.\nTrust boundaries When we talk about trust, we don’t mean things you trust because you think they are perfect. Instead, we mean things you have to trust in order to get things done, even though you know they are imperfect.\nIn Pony, when you use the C FFI, you are basically declaring that you trust the C code that’s being executed. That’s fine, because you may need it to get work done. But what about trusting someone else’s code to use the C FFI? You may need to, but you definitely want to know that it’s happening.\nSafe packages The normal way to handle that is to be sure you’re using just the code you need to use in your program. Pretty simple! Don’t use some random package from the internet without looking at the code and making sure it doesn’t do nasty FFI stuff.\nBut we can do better than that.\nIn Pony, you can optionally declare a set of safe packages on the ponyc command line, like this:\nponyc --safe=files:net:net/ssl my_project Here, we are declaring that only the files, net and net/ssl packages are allowed to use C FFI calls. We’ve established our trust boundary: any other packages that try to use C FFI calls will result in a compile-time error.\n","summary":"We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you’ve called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.\nTrust boundaries When we talk about trust, we don’t mean things you trust because you think they are perfect. Instead, we mean things you have to trust in order to get things done, even though you know they are imperfect.","title":"Trust Boundary","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/trust-boundary.html"},{"content":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction). A ( at the beginning of a line starts a new expression (a tuple), whereas a ( in the middle of an expression is a method call. A [ at the beginning of a line starts a new expression (an array literal), whereas a [ in the middle of an expression is generic formal parameters.  That stuff may seem a little esoteric right now, but we’ll explain it all later. The - part should make sense though.\na - b That means “subtract b from a”.\na -b That means “first do a, then, in a new expression, do a unary negation of b”.\nSemicolons In Pony, you don’t end an expression with a ;, unlike C, C++, Java, C#, etc. In fact, you don’t need to end it at all! The compiler knows when an expression has finished, like Python or Ruby.\nHowever, sometimes it’s convenient to put more than one expression on the same line. When you want to do that, you must separate them with a ;.\nWhy? Can’t the compiler tell an expression has finished? Yes, it can. The compiler doesn’t really need the ;. However, it turns out the programmer does! By requiring a ; between expressions on the same line, the compiler can catch some pretty common syntax errors for you.\nDocstrings Including documentation in your code makes you awesome. If you do it, everyone will love you.\nPony makes it easy by allowing you to put a docstring on every type, field, or method. Just put a string literal right after declaring the type or field, or right after the =\u003e of a method, before writing the body. The compiler will know what to do with them.\nFor traits and interfaces that have methods without bodies, you can put the docstring after the method declaration, even though there is no =\u003e.\nBy convention, a docstring should be a triple-quoted string, and it should use Markdown for any formatting.\nactor Main \"\"\" This is documentation for my Main actor \"\"\" var count: USize = 0 \"\"\" This is documentation for my count field \"\"\" new create(env: Env) =\u003e \"\"\" This is documentation for my create method \"\"\" None trait Readable fun val read() \"\"\" This is documentation for my unimplemented read method \"\"\" Comments Use docstrings first! But if you need to put some comments in the implementation of your methods, perhaps to explain what’s happening on various lines, you can use C++ style comments. In Pony, block comments can be nested.\n// This is a line comment. /* This is a block comment. */ /* This block comment /* has another block comment */ inside of it. */ ","summary":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction).","title":"Whitespace","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/whitespace.html"},{"content":"你需要一个文本编辑器，还有Pony编译器。如果想偷点懒可以直接使用Pony的Playground。\nPony编译器 Pony编译器的：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，非解释型语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以直接运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整程序。\n所以你必须先构建程序，才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python3)，然后使用chmod添加运行权限，然后运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接输入ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果代码在其他目录里，把目录作为参数传入就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，后面会介绍。\n","summary":"你需要一个文本编辑器，还有Pony编译器。如果想偷点懒可以直接使用Pony的Playground。\nPony编译器 Pony编译器的：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，非解释型语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以直接运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整程序。\n所以你必须先构建程序，才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python3)，然后使用chmod添加运行权限，然后运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接输入ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果代码在其他目录里，把目录作为参数传入就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，后面会介绍。","title":"准备工作（What You Need）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/what-you-need.html"},{"content":"Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.\nIn most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what’s being assigned to it, and everything is fine.\nIn Pony, that works for some reference capabilities, but not all.\nAliasing and deny guarantees The reason for this is that the iso reference capability denies other iso variables that point to the same object. That is, you can only have one iso variable pointing to any given object. The same goes for trn.\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = a // Not allowed! Here we have some function that gets passed an isolated Wombat. If we try to alias a by assigning it to b, we’ll be breaking reference capability guarantees so the compiler will stop us.\nWhat can I alias an iso as? Since an iso says no other variable can be used by any actor to read from or write to that object, we can only create aliases to an iso that can neither read nor write. Fortunately, we’ve got a reference capability that does exactly that: tag. So we can do this and the compiler will be happy:\nfun test(a: Wombat iso) =\u003e var b: Wombat tag = a // Allowed! What about aliasing trn? Since a trn says no other variable can be used by any actor to write to that object, we need something that doesn’t allow writing but also doesn’t prevent our trn variable from writing. Fortunately, we’ve got a reference capability that does that too: box. So we can do this and the compiler will be happy:\nfun test(a: Wombat trn) =\u003e var b: Wombat box = a // Allowed! What about aliasing other stuff? For both iso and trn, the guarantees require that aliases must give up on some ability (reading and writing for iso, writing for trn). For the other capabilities (ref, val, box and tag), aliases allow for the same operations, so such a reference can just be aliased as itself.\nWhat counts as making an alias? There are three things that count as making an alias:\n When you assign a value to a variable or a field. When you pass a value as an argument to a method. When you call a method, an alias of the receiver of the call is created. It is accessible as this within the method body.  In all three cases, you are making a new name for the object. This might be the name of a local variable, the name of a field, or the name of a parameter to a method.\nEphemeral types In Pony, every expression has a type. So what’s the type of consume a? It’s not the same type as a, because it might not be possible to alias a. Instead, it’s an ephemeral type. That is, it’s a type for a value that currently has no name (it might have a name through some other alias, but not the one we just consumed or destructively read).\nTo show a type is ephemeral, we put a ^ at the end. For example:\nfun test(a: Wombat iso): Wombat iso^ =\u003e consume a Here, our function takes an isolated Wombat as a parameter and returns an ephemeral isolated Wombat.\nThis is useful for dealing with iso and trn types, and for generic types, but it’s also important for constructors. A constructor always returns an ephemeral type, because it’s a new object.\nAlias types For the same reason Pony has ephemeral types, it also has alias types. An alias type is a way of saying “whatever we can safely alias this thing as”. It’s only needed when dealing with generic types, which we’ll discuss later.\nWe indicate an alias type by putting a ! at the end. Here’s an example:\nfun test(a: A) =\u003e var b: A! = a Here, we’re using A as a type variable, which we’ll cover later. So A! means “an alias of whatever type A is”.\n","summary":"Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.\nIn most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what’s being assigned to it, and everything is fine.","title":"别名（Aliasing）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/aliasing.html"},{"content":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.\nA package is usually split into several source files, although it does not have to be. This is purely a convenience to allow better code organisation and the compiler treats all the code within a package as if it were from a single file.\nThe package is the privacy boundary for types and methods. That is:\n Private types (those whose name starts with an underscore) can be used only within the package in which they are defined. Private methods (those whose name starts with an underscore) can be called only from code within the package in which they are defined.  It follows that all code within a package is assumed to know and trust, all the rest of the code in the package.\nThere is no such concept as a sub-package in Pony. For example, the packages “foo/bar” and “foo/bar/wombat” will, presumably, perform related tasks but they are two independent packages. Package “foo/bar” does not contain package “foo/bar/wombat” and neither has access to the private elements of the other.\n","summary":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.","title":"包机制（Package System）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/package-system.html"},{"content":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same. They come at the beginning of Pony files and look like this:\nuse \"collections\" This will find all of the publicly visible types defined in the collections package and add them to the type namespace of the file containing the use command. These types are then available to use within that file, just as if they were defined locally.\nFor example, the standard library contains the package time. This contains the following definition (among others):\nprimitive Time fun now(): (I64, I64) To access the now function just add a use command:\nuse \"time\" class Foo fun f() =\u003e (var secs, var nsecs) = Time.now() Use names As we saw above the use command adds all the public types from a package into the namespace of the using file. This means that using a package may define type names that you want to use for your own types. Furthermore, if you use two packages within a file they may both define the same type name, causing a clash in your namespace. For example:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use \"packageB\" class Bar var _x: Foo The declarations of _x is an error because we don’t know which Foo is being referred to. Actually using ‘Foo’ is not even required, simply using both packageA and packageB is enough to cause an error here.\nTo avoid this problem the use command allows you to specify an alias. If you do this then only that alias is put into your namespace. The types from the used package can then be accessed using this alias as a qualifier. Our example now becomes:\n// In package A class Foo // In package B class Foo // In your code use a = \"packageA\" use b = \"packageB\" class Bar var _x: a.Foo // The Foo from package A var _y: b.Foo // The Foo from package B If you prefer you can give an alias to only one of the packages. Foo will then still be added to your namespace referring to the unaliased package:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use b = \"packageB\" class Bar var _x: Foo // The Foo from package A var _y: b.Foo // The Foo from package B Can I just specify the full package path and forget about the use command, like I do in Java and C#? No, you can’t do that in Pony. You can’t refer to one package based on a use command for another package and you can’t use types from a package without a use command for that package. Every package that you want to use must have its own use command.\nAre there limits on the names I can use for an alias? Use alias names have to start with a lower case letter. Other than that you can use whatever name you want, as long as you’re not using that name for any other purpose in your file.\nScheme indicators The string we give to a use command is known as the specifier. This consists of a scheme indicator and a locator, separated by a colon. The scheme indicator tells the use command what we want it to do, for example, the scheme indicator for including a package is “package”. If no colon is found within the specifier string then the use command assumes you meant “package”.\nThe following two use commands are exactly equivalent:\nuse \"foo\" use \"package:foo\" If you are using a locator string that includes a colon, for example, an absolute path in Windows, then you have to include the “package” scheme specifier:\nuse \"C:/foo/bar\" // Error, scheme \"C\" is unknown use \"package:C:/foo/bar\" // OK To allow use commands to be portable across operating systems, and to avoid confusion with escape characters, ‘/’ should always be used as the path separator in use commands, even on Windows.\n","summary":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same.","title":"包的使用方式（Use Statement）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/use-statement.html"},{"content":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.0 =\u003e \"float\" | \"2\" =\u003e \"string\" else \"something else\" end If you’re used to functional languages this should be very familiar.\nFor those readers more familiar with the C and Java family of languages, think of this like a switch statement. But you can switch on values other than just integers, like Strings. In fact, you can switch on any type that provides a comparison function, including your own classes. And you can also switch on the runtime type of an expression.\nA match starts with the keyword match, followed by the expression to match, which is known as the match operand. In this example, the operand is just the variable x, but it can be any expression.\nMost of the match expression consists of a series of cases that we match against. Each case consists of a pipe symbol (‘|’), the pattern to match against, an arrow (‘=\u003e’) and the expression to evaluate if the case matches.\nWe go through the cases one by one until we find one that matches. (Actually, in practice the compiler is a lot more intelligent than that and uses a combination of sequential checks and jump tables to be as efficient as possible.)\nNote that each match case has an expression to evaluate and these are all independent. There is no “fall through” between cases as there is in languages such as C.\nIf the value produced by the match expression isn’t used then the cases can omit the arrow and expression to evaluate. This can be useful for excluding specific cases before a more general case.\nElse cases As with all Pony control structures, the else case for a match expression is used if we have no other value, i.e. if none of our cases match. The else case, if there is one, must come at the end of the match, after all of the specific cases.\nIf the value the match expression results in is used then you need to have an else case, except in cases where the compiler recognizes that the match is exhaustive and that the else case can never actually be reached. If you omit it a default will be added which evaluates to None.\nThe compiler recognizes a match as exhaustive when the union of the types for all patterns that match on type alone is a supertype of the matched expression type. In other words, when your cases cover all possible types for the matched expression, the compiler will not add an implicit else None to your match statement.\nMatching on values The simplest match expression just matches on value.\nfun f(x: U32): String =\u003e match x | 1 =\u003e \"one\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | 5 =\u003e \"not four\" else \"something else\" end For value matching the pattern is simply the value we want to match to, just like a C switch statement. The case with the same value as the operand wins and we use its expression.\nThe compiler calls the eq() function on the operand, passing the pattern as the argument. This means that you can use your own types as match operands and patterns, as long as you define an eq() function.\nclass Foo var _x: U32 new create(x: U32) =\u003e _x = x fun eq(that: Foo): Bool =\u003e _x == that._x actor Main fun f(x: Foo): String =\u003e match x | Foo(1) =\u003e \"one\" | Foo(2) =\u003e \"two\" | Foo(3) =\u003e \"three\" | Foo(5) =\u003e \"not four\" else \"something else\" end Matching on type and value Matching on value is fine if the match operand and case patterns have all the same type. However, match can cope with multiple different types. Each case pattern is first checked to see if it is the same type as the runtime type of the operand. Only then will the values be compared.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | \"5\" =\u003e \"not four\" else \"something else\" end In many languages using runtime type information is very expensive and so it is generally avoided whenever possible.\nIn Pony it’s cheap. Really cheap. Pony’s “whole program” approach to compilation means the compiler can work out as much as possible at compile time. The runtime cost of each type check is generally a single pointer comparison. Plus of course, any checks which can be fully determined at compile time are. So for upcasts there’s no runtime cost at all.\nWhen are case patterns for value matching evaluated? Each case pattern expression that matches the type of the match operand, needs to be evaluated each time the match expression is evaluated until one case matches (further case patterns are ignored). This can lead to creating lots of objects unintentionally for the sole purpose of checking for equality. If case patterns actually only need to differentiate by type, Captures should be used instead, these boil down to simple type checks at runtime.\nAt first sight it is easy to confuse a value matching pattern for a type check. Consider the following example:\nclass Foo is Equatable[Foo] actor Main fun f(x: (Foo | None)): String =\u003e match x | Foo =\u003e \"foo\" | None =\u003e \"bar\" else \"\" end new create(env: Env) =\u003e f(Foo) Both case patterns actually do not check for the match operand x being an instance of Foo or None, but check for equality with the instance created by evaluating the case pattern (each time). None is a primitive and thus there is only one instance at all, in which case this value pattern kind of does the expected thing, but not quite. If None had a custom eq function that would not use identity equality, this could lead to surprising results.\nRemember to always use Captures if all you need is to differentiate by type. Only use value matching if you need a full blown equality check, be it for structural equality or identity equality.\nCaptures Sometimes you want to be able to match the type, for any value of that type. For this, you use a capture. This defines a local variable, valid only within the case, containing the value of the operand. If the operand is not of the specified type then the case doesn’t match.\nCaptures look just like variable declarations within the pattern. Like normal variables, they can be declared as var or let. If you’re not going to reassign them within the case expression it is good practice to use let.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | let u: U32 =\u003e \"other integer\" | let s: String =\u003e s end Can I omit the type from a capture, like I can from a local variable? Unfortunately no. Since we match on type and value the compiler has to know what type the pattern is, so it can’t be inferred.\nImplicit matching on capabilities in the context of union types In union types, when we pattern match on individual classes or traits, we also implicitly pattern match on the corresponding capabilities. In the example provided below, if _x has static type (A iso | B ref | None) and dynamically matches A, then we also know that it must be an A iso.\nclass A fun ref sendable() =\u003e None class B fun ref update() =\u003e None actor Main var _x: (A iso | B ref | None) new create(env: Env) =\u003e _x = None be f(a': A iso) =\u003e match (_x = None) // type of this expression: (A iso^ | B ref | None) | let a: A iso =\u003e f(consume a) | let b: B ref =\u003e b.update() end Note that using a match expression to differentiate solely based on capabilities at runtime is not possible, that is:\nclass A fun ref sendable() =\u003e None actor Main var _x: (A iso | A ref | None) new create(env: Env) =\u003e _x = None be f() =\u003e match (_x = None) | let a1: A iso =\u003e None | let a2: A ref =\u003e None end does not typecheck.\nMatching tuples If you want to match on more than one operand at once then you can simply use a tuple. Cases will only match if all the tuple elements match.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, let u: U32) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) =\u003e s + \" other integer\" else \"something else\" end Do I have to specify all the elements in a tuple? No, you don’t. Any tuple elements in a pattern can be marked as “don’t care” by using an underscore ('_'). The first and fourth cases in our example don’t actually care about the U32 element, so we can ignore it.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, _) =\u003e s + \" other integer\" else \"something else\" end Guards In addition to matching on types and values, each case in a match can also have a guard condition. This is simply an expression, evaluated after type and value matching has occurred, that must give the value true for the case to match. If the guard is false then the case doesn’t match and we move onto the next in the usual way.\nGuards are introduced with the if keyword (was where until 0.2.1).\nA guard expression may use any captured variables from that case, which allows for handling ranges and complex functions.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) if u \u003e 14 =\u003e s + \" other big integer\" | (let s: String, _) =\u003e s + \" other small integer\" else \"something else\" end ","summary":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.","title":"匹配表达式（Match Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/match.html"},{"content":"有时候，能够内联地写一个完整的对象是非常方便的。在Pony中，这被称为匿名对象，它做的事情和JavaScript中的匿名对象差不多：它可以生成一个可以立即使用的对象。\n但是Pony是静态类型的，所以一个匿名对象也会创建一个匿名类，这个匿名对象会满足这个匿名类。这类似于Java和C#中的匿名类。在Pony中，匿名类型可以提供任意数量的特征和接口。\n匿名类和匿名对象是什么？（What’s this look like, then?） 匿名类表达式与类（class）的定义基本相同，object表达式构建了一个匿名类并返回它的的实例，这个实例被称为匿名对象。匿名类和普通类有一些细微的区别，下面是一个简单的例子:\nobject fun apply(): String =\u003e \"hi\" end 很简单明了。让我们对其进行扩展，提供一个Hashable特征的实现，以便编译器能够确保匿名类型满足该接口。也可以用相同的方法来提供其他特征。\nobject is Hashable fun apply(): String =\u003e \"hi\" fun hash(): USize =\u003e this().hash() end 我们不能给匿名对象指定构造函数，因为它本身 就是 一个构造函数。那么我们如何分配字段呢？直接声明就行了。例如:\nuse \"collections\" class Foo fun foo(str: String): Hashable =\u003e object is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 在匿名对象所在的作用域中声明和初始化局部变量，等同于在类的构造函数中定义和初始化字段， 匿名类的所有的成员汉书都可以 捕获（capturing） 这些变量当做字段去实用。这非常有趣！它让我们有任意复杂的可以有多个入口点(例如，你可以在一个闭包上调用函数)的。\n默认情况下，带有字段的匿名对象将以ref（引用权能的一种权限类型）方式返回，除非你通过在object关键字后显示的指定一个引用权能的类型来声明权限。例如，一个带有sendable权限的对象可以在需要时可以声明为iso:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 我们还可以通过在匿名对象中使用词法作用域来隐式捕获值。有时，那些不是局部变量、不是字段、也不是函数参数的值被称为 free variables 。通过在函数中使用它们，我们将对它们进行覆盖——也就是捕获它们。上面的代码可以写没有字段s：\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable fun apply(): String =\u003e str fun hash(): USize =\u003e str.hash() end 闭包（Lambdas） 复杂的匿名对象很有用，但有时我们只想要一个简单的匿名函数。在Pony中，你可以使用闭包（lambdas）。lambda是一个一个函数(被隐式的命名为apply)，写在花括号{}当中:\n{(s: String): String =\u003e \"lambda: \" + s } 等同于：\nobject fun apply(s: String): String =\u003e \"lambda: \" + s end lambda对象的引用权能可以通过在右花括号后声明:\n{(s: String): String =\u003e \"lambda: \" + s } iso 等同于:\nobject iso fun apply(s: String): String =\u003e \"lambda: \" + s end Lambdas可用于从作用域捕获变量，其方式与匿名对象捕获字段的方式相同。通过在参数之后添加第二个参数列表来实现：\nclass Foo new create(env:Env) =\u003e foo({(s: String)(env) =\u003e env.out.print(s) }) fun foo(f: {(String)}) =\u003e f(\"Hello World\") 也可以使用 捕获列表（capture list） 来设置别名。捕获列表在参数之后的第二个括号中：\nnew create(env:Env) =\u003e foo({(s: String)(myenv = env) =\u003e myenv.out.print(s) }) lambda的类型也使用花括号声明。在花括号中，函数形参类型在圆括号中指定，后面跟着一个可选的冒号和返回类型。上面的示例使用{(String)}作为lambda函数的形参类型，该函数接受String作为参数，无返回值。\n如果没有为lambda对象指定引用权能声明，则引用权能的类型将从lambda的结构中推断出来。如果lambda没有捕获到可用权限类型，则默认为val。如果它确实捕获了引用权限，那么默认情况下它将是ref。下面是一个vallambda对象的例子:\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[U32] l.\u003epush(10).\u003epush(20).\u003epush(30).push(40) let r = reduce(l, 0, {(a:U32, b:U32): U32 =\u003e a + b }) env.out.print(\"Result: \" + r.string()) fun reduce(l: List[U32], acc: U32, f: {(U32, U32): U32} val): U32 =\u003e try let acc' = f(acc, l.shift()?) reduce(l, acc', f) else acc end 本例中的reduce方法要求f参数的lambda类型需要val的引用权能。作为参数传入的lambda对象不需要声明显式的引用权能，因为val会被捕获到。\n如前所述，lambda使用apply方法来处理匿名对象。apply方法的引用权能默认为box，跟其他方法一样。在捕获这个的lambda时，如果函数需要修改捕获的任何变量或对其调用ref方法，则需要修改为ref。方法的引用权能(与上面描述的对象引用权能相比)是通过将该权限放在圆括号中的参数列表之前来定义的。\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[String] l.\u003epush(\"hello\").push(\"world\") var count = U32(0) for_each(l, {ref(s:String) =\u003e env.out.print(s) count = count + 1 }) // Displays '0' as the count env.out.print(\"Count: \" + count.string()) fun for_each(l: List[String], f: {ref(String)} ref) =\u003e try f(l.shift()?) for_each(l, f) end 此示例将由lambda表达式生成的apply函数的类型声明为ref。for_each方法中f参数的lambda类型声明也明为ref。lambda类型的引用权能也必须是ref，以便能够调用该方法。lambda对象不需要声明显式引用权能，因为ref会被lambda捕获。\n上面的例子还要注意到一点，捕获的引用的一个微妙的事实。乍一看，你可能会认为count会随着f的应用而增加。但是，在lambda或匿名对象内部count = count + 1永远不会影响到作用域外的值。如果count是一个具有允许修改的引用功能的对象，例如可以私用count.increment()来修改捕获的引用。就会影响到作用域外部count的值。\n匿名Actor（Actor literals） 通常，匿名对象是匿名类的实例。要使它成为匿名Actor的实例，只需在定义中包含一个或多个行为。\nobject be apply() =\u003e env.out.print(\"hi\") end 匿名actor实例总是作为tag（引用权能的一种类型）返回。\n匿名基元类（Primitive literals） 当匿名类型没有字段和行为(例如，声明为lambda的匿名对象)时，编译器将其生成为匿名基元类，除非显式地提供了非val引用功能。基元类就意味着不需要额外的内存分配来生成该类型的实例。\n换句话说，在Pony中，不包含任何字段的lambda没有内存分配开销。这点很棒。\n匿名基元类总是以val的形式返回。\n","summary":"有时候，能够内联地写一个完整的对象是非常方便的。在Pony中，这被称为匿名对象，它做的事情和JavaScript中的匿名对象差不多：它可以生成一个可以立即使用的对象。\n但是Pony是静态类型的，所以一个匿名对象也会创建一个匿名类，这个匿名对象会满足这个匿名类。这类似于Java和C#中的匿名类。在Pony中，匿名类型可以提供任意数量的特征和接口。\n匿名类和匿名对象是什么？（What’s this look like, then?） 匿名类表达式与类（class）的定义基本相同，object表达式构建了一个匿名类并返回它的的实例，这个实例被称为匿名对象。匿名类和普通类有一些细微的区别，下面是一个简单的例子:\nobject fun apply(): String =\u003e \"hi\" end 很简单明了。让我们对其进行扩展，提供一个Hashable特征的实现，以便编译器能够确保匿名类型满足该接口。也可以用相同的方法来提供其他特征。\nobject is Hashable fun apply(): String =\u003e \"hi\" fun hash(): USize =\u003e this().hash() end 我们不能给匿名对象指定构造函数，因为它本身 就是 一个构造函数。那么我们如何分配字段呢？直接声明就行了。例如:\nuse \"collections\" class Foo fun foo(str: String): Hashable =\u003e object is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end 在匿名对象所在的作用域中声明和初始化局部变量，等同于在类的构造函数中定义和初始化字段， 匿名类的所有的成员汉书都可以 捕获（capturing） 这些变量当做字段去实用。这非常有趣！它让我们有任意复杂的可以有多个入口点(例如，你可以在一个闭包上调用函数)的。\n默认情况下，带有字段的匿名对象将以ref（引用权能的一种权限类型）方式返回，除非你通过在object关键字后显示的指定一个引用权能的类型来声明权限。例如，一个带有sendable权限的对象可以在需要时可以声明为iso:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.","title":"匿名对象（Object Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/object-literals.html"},{"content":"Pony和其他编程语言一样，可以使用变量存储数据。不同种类的变量有不同的生命周期和使用场景。\n局部变量 Pony中的局部变量与其他语言类似，可以在执行计算时存储临时值。局部变量位于代码块中（它们是该代码块的 local ），并在每次进入代码块时自动创建，并在代码块结束时销毁。\n定义局部变量，可以使用关键字var（也可以使用let，但是我们稍后再讲）。在var后面紧跟着的时变量的名称，变量名后面加上一个：可以设置（可选）变量的类型。例如：\nvar x: String = \"Hello\" var y = \"Hello\" 上面示例中，创建了一个字符串类型的变量x，并赋值为\"Hello\"。\n定义变量时可以不用给变量赋初始值：可以稍后再赋值。但是如果使用没有赋值的变量，编译器会报一个变量还未初始化的错误： uninitialized variable 。\n所有变量要指定类型，但是如果在声明时提供了初始值，就可以省略类型，编译器会根据初始值自动推导出变量的类型。\n下面示例中x，y和z定义方式是等价的。\nvar x: String = \"Hello\" var y = \"Hello\" var z: String z = \"Hello\" 可以同时省略变量的类型和初始值吗？ 不行。这样的话编译器无法确定变量的类型。\n所有局部变量名称均以小写字母开头。如果需要，可以用一个（或多个）引号'结尾，当您规避变量重名问题时，会很有用。例如，有一个名为time的变量，另一个变量名可以用time'。\n变量所在的代码块称为 作用域（scope） 。作用域的范围取决于定义的位置。例如，在if语句的then表达式中定义的变量的作用域就是该then表达式。虽然我们还没有讲到if语句，不过它与其他种语言中的用法是相似的。\nif a \u003e b then var x = \"a is bigger\" env.out.print(x) // OK end env.out.print(x) // Illegal 变量定义后仅在作用域结束前有效。对于变量x，它的有效范围是then表达式到结尾的的end之间：在那之后，就无法再使用它了。\nvar和let 局部变量用var或let声明。使用var表示这个变量可以反复赋值。使用let表示这个是常量只能赋值一次，无法被修改。\nvar x: U32 = 3 let y: U32 = 4 x = 5 // OK y = 6 // Error, y is let 使用let时必须初始化。\nlet x: U32 = 3 // Ok let y: U32 // Error, can't declare a let local without assigning to it y = 6 // Error, can't reassign to a let local 注意，使用let声明的变量只有重新赋值受到限制，并且不影响其引用的对象的可变性。这是引用权能中的内容，本教程后面的章节将对此进行说明。\n变量不一定要用let声明，但是如果永远不会更改变量引用的内容，使用let是个好主义。这也是一种类型注释，指示所引用的内容不能更改。\n字段 在Pony中，字段是对象中的变量。跟其他面向对象语言中的字段没有两样。\n字段与它所在的对象具有相同的生命周期，而不是被限制范围。它们在对象的构造函数内初始化，并与对象一起销毁。\n如果字段名称以“_”开头，表示 私有（private） 。这表示只有该字段所在的类型才能访问该字段。否则，该字段为 公有（public） ，可以从外部访问。\n和局部变量一样，字段也可以用var或let定义。但是字段分配与变量的初始化方式有所不同。无论字段的类型（var还是let），都需要遵守下面的约定：\n1.必须在其定义中分配一个初始值（或第2条） 2.必须在构造方法中分配一个初始值。\n在下面的示例中，类Wombat的两个字段在定义时进行了初始值：\nclass Wombat let name: String = \"Fantastibat\" var _hunger_level: U32 = 0 也可以在构造函数中初始化这些字段：\nclass Wombat let name: String var _hunger_level: U32 new create(hunger: U32) =\u003e name = \"Fantastibat\" _hunger_level = hunger 如果在定义时和构造函数中都没有初始化字段，就会导致编译错误。对于var和let声明的字段都是如此。\n注意，字段必须直接初始化。下面示例其他函数中初始化字段，导致了编译错误，即便该字段是var类型也不可以：\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' set_hunger_level(level) // Error: field _hunger_level left undefined in constructor fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level 在后面的方法章节中，我们会讲到一个类可以有多个构造函数。现在，请记住，如果没有在定义时对字段初始化，就必须在该字段所属类的所有构造函数中进行赋值。\n使用var声明的字段可以多次赋值。使用let声明的字段只能被初始化一次。\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' _hunger_level = level fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level // Ok, _hunger_level is of var type fun ref set_name(name' : String) =\u003e name = name' // Error, can't assign to a let definition more than once 可以在类成员函数中声明字段吗？ 当然不行。如果var或let关键字出现在fun或be声明之后，它们将被视为方法中的局部变量，而不是类型声明中的字段。字段必须出现在类型声明中的所有方法之前。\nEmbedded Fields Unlike local variables, some types of fields can be declared using embed. Specifically, only classes or structs can be embedded - interfaces, traits, primitives and numeric types cannot. A field declared using embed is similar to one declared using let, but at the implementation level, the memory for the embedded class is laid out directly within the outer class. Contrast this with let or var, where the implementation uses pointers to reference the field class. Embedded fields can be passed to other functions in exactly the same way as let or var fields. Embedded fields must be initialised from a constructor expression.\nWhy would I use embed? embed avoids a pointer indirection when accessing a field and a separate memory allocation when creating that field. By default, it is advised to use embed if possible. However, since an embedded field is allocated alongside its parent object, exterior references to the field forbids garbage collection of the parent, which can result in higher memory usage if a field outlives its parent. Use let if this is a concern for you.\n全局变量 很多编程语言都允许全局变量，可以从代码中的任何位置对其进行访问。这是个糟糕的做法！Pony中没有全局变量。\n隐藏（Shadowing） 有些编程语言（类如Rust、Reason）允许你声明一个与现有变量同名的变量，替代旧的。这个方式还被美其名曰 隐藏（shadowing） ，这容易引发bug，Pony中不允许这么做。如果你不小心在Pony中隐藏了变量，编译时会报错。\n如果您需要一个 同名变量 ，可以用前面提到的方式：使用'符号。\n","summary":"Pony和其他编程语言一样，可以使用变量存储数据。不同种类的变量有不同的生命周期和使用场景。\n局部变量 Pony中的局部变量与其他语言类似，可以在执行计算时存储临时值。局部变量位于代码块中（它们是该代码块的 local ），并在每次进入代码块时自动创建，并在代码块结束时销毁。\n定义局部变量，可以使用关键字var（也可以使用let，但是我们稍后再讲）。在var后面紧跟着的时变量的名称，变量名后面加上一个：可以设置（可选）变量的类型。例如：\nvar x: String = \"Hello\" var y = \"Hello\" 上面示例中，创建了一个字符串类型的变量x，并赋值为\"Hello\"。\n定义变量时可以不用给变量赋初始值：可以稍后再赋值。但是如果使用没有赋值的变量，编译器会报一个变量还未初始化的错误： uninitialized variable 。\n所有变量要指定类型，但是如果在声明时提供了初始值，就可以省略类型，编译器会根据初始值自动推导出变量的类型。\n下面示例中x，y和z定义方式是等价的。\nvar x: String = \"Hello\" var y = \"Hello\" var z: String z = \"Hello\" 可以同时省略变量的类型和初始值吗？ 不行。这样的话编译器无法确定变量的类型。\n所有局部变量名称均以小写字母开头。如果需要，可以用一个（或多个）引号'结尾，当您规避变量重名问题时，会很有用。例如，有一个名为time的变量，另一个变量名可以用time'。\n变量所在的代码块称为 作用域（scope） 。作用域的范围取决于定义的位置。例如，在if语句的then表达式中定义的变量的作用域就是该then表达式。虽然我们还没有讲到if语句，不过它与其他种语言中的用法是相似的。\nif a \u003e b then var x = \"a is bigger\" env.out.print(x) // OK end env.out.print(x) // Illegal 变量定义后仅在作用域结束前有效。对于变量x，它的有效范围是then表达式到结尾的的end之间：在那之后，就无法再使用它了。\nvar和let 局部变量用var或let声明。使用var表示这个变量可以反复赋值。使用let表示这个是常量只能赋值一次，无法被修改。\nvar x: U32 = 3 let y: U32 = 4 x = 5 // OK y = 6 // Error, y is let 使用let时必须初始化。","title":"变量（Variables）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/variables.html"},{"content":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段就天然具备不可变性不会产生副作用。只有一个实例的意味着 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\n基元类 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n 作为\"标记值”。例如，Pony经常使用None基元类来表示某事物没有值。当然，它其实具有一个值，并且该值就是None的实例。 作为\"枚举\"类型。通过创建 primitive 类型的 union ，可以使用类型安全的枚举。稍后我们将介绍 union 类型。 作为\"函数集合”。由于基元类也可以有成员函数，因此可以用基元类来做函数分类。例如，标准库中的路径处理相关的函数都被放在Path中（Path就是一个基元类）。  // 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.out.print(\"Is door open? \" + isDoorOpen.string()) env.out.print(\"2 + 3 = \" + BasicMath.add(2,3).string()) 基元类非常强大，尤其是作为枚举使用时。与其他语言中的枚举不同，Pony中枚举的每个值都是一个完整类型，因此可以将数据和函数附加到枚举值上。\n内置基元类 primitive 关键字还用于引入某些内置的\"machine word\"类型。除了具有与之关联的值外，这些还类似于用户定义的原语。这些是：\n Bool 。这是一个1位值，true或false。 ISize，ILong，I8，I16，I32，I6​​4，I128 。有符号整数。 USize，ULong，U8，U16，U32，U64，U128 。无符号整数。 F32，F64 。浮点数。  ISize / USize 对应于本机类型size_t的位宽，该位宽因平台而异。 ILong / ULong 类似地对应于本机类型 long的位宽，该位宽也因平台而异。在所有Pony支持的平台上，本机int的位宽均相同，您可以使用 I32 / U32 来实现。\n基元类的初始化和销毁 基元类有两个特殊的成员函数，_init和_final。在任何actor开始之前都会调用_init。在所有参与者都终止之后，将调用_final。这两个函数不带参数。不同的基元类的_init和_final函数始终按顺序执行。\n一个常见的用例是初始化和清理C语言的库，而不用承担actor不当使用的风险。\n","summary":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段就天然具备不可变性不会产生副作用。只有一个实例的意味着 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\n基元类 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n 作为\"标记值”。例如，Pony经常使用None基元类来表示某事物没有值。当然，它其实具有一个值，并且该值就是None的实例。 作为\"枚举\"类型。通过创建 primitive 类型的 union ，可以使用类型安全的枚举。稍后我们将介绍 union 类型。 作为\"函数集合”。由于基元类也可以有成员函数，因此可以用基元类来做函数分类。例如，标准库中的路径处理相关的函数都被放在Path中（Path就是一个基元类）。  // 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.","title":"基元类（Primitives）","uri":"https://damon-kwok.github.io/pony-tutorial/types/primitives.html"},{"content":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\n每一种编程语言都会有字面量对数据的类型进行描述，Pony也不例外。\nPony表达式中常用的字面量有：布尔、数值、字符、字符串、数组。\nBool型 布尔类型有两个可选值：true 和 false。\n数字型 数字型字面量包括：有符号整数、无符号整数和浮点数。\n在大多数情况下，Pony可以从上下文中推导出具体的数据类型（这包括，分配给字段或局部变量或作为方法/行为调用的参数）。\n可以使用以下一种数字类型的构造函数来帮助编译器确定字面量的具体类型：\n U8, U16, U32, U64, U128, USize, ULong I8, I16, I32, I64, I128, ISize, ILong F32, F64  let my_explicit_unsigned: U32 = 42_000 let my_constructor_unsigned = U8(1) let my_constructor_float = F64(1.234) 整数可以以十进制，十六进制或二进制形式给出：\nlet my_decimal_int: I32 = 1024 //十进制 let my_hexadecimal_int: I32 = 0x400\t//十六进制 let my_binary_int: I32 = 0b10000000000\t//二进制 浮点文字以标准浮点或科学计数法表示：\nlet my_double_precision_float: F64 = 0.009999999776482582092285156250 //标准浮点数 let my_scientific_float: F32 = 42.12e-4 //科学计数法 字符型 字符使用单引号'包裹。\n字符和字符串有很大区别，它表示的是一个有符号数字。一个字节即是一个U8。但是它们可以被转换为任意整数类型：\nlet big_a: U8 = 'A' // 65 let hex_escaped_big_a: U8 = '\\x41' // 65 let newline: U32 = '\\n' // 10 下面是Pony支持的字符转义：\n \\x4F hex escape sequence with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\'  多重字符（Multibyte Character literals） Pony的字符字面量可以包含多个字符。生成的整数值是逐字节构造的，每个字符代表生成的整数中的单个字节，最后一个字符是最低有效字节：\nlet multiByte: U64 = 'ABCD' // 0x41424344 字符串 字符串使用\"或\"\"\"包裹。可以包含任意类型的字节或转义字符：\n \\u00FE unicode escape sequence with 4 hex digits encoding one code point \\u10FFFE unicode escape sequence with 6 hex digits encoding one code point \\x4F hex escape sequence for unicode letters with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\\"  每个转义序列编码一个完整字符，而不是字节。\nuse \"format\" actor Main new create(env: Env) =\u003e let pony = \"🐎\" let pony_hex_escaped = \"p\\xF6n\\xFF\" let pony_unicode_escape = \"\\U01F40E\" env.out.print(pony + \" \" + pony_hex_escaped + \" \" + pony_unicode_escape) for b in pony.values() do env.out.print(Format.int[U8](b, FormatHex)) end Pony字符串支持多行定义：\nlet stacked_ponies = \" 🐎 🐎 🐎 \" 字符串和编码 字符串的文字如果从其源代码文件中定义。那么，它们的实际值取决于其源码文件的编码格式。\n请看下面的示例：\nlet u_umlaut = \"ü\" 如果文件编码格式是 UTF-8 那么u_umlaut 的值是: \\xc3\\xbc。如果文件编码格式是ISO-8559-1 (Latin-1) 它的值就是 \\xfc。\n多行字符串（Triple quoted Strings） 要在字符串中嵌入多行文本，请将字符串使用三引号引起来的。\nlet triple_quoted_string_docs = \"\"\" Triple quoted strings are the way to go for long multiline text. They are extensively used as docstrings which are turned into api documentation. They get some special treatment, in order to keep Pony code readable: * The string literal starts on the line after the opening triple quote. * Common indentation is removed from the string literal so it can be conveniently aligned with the enclosing indentation e.g. each line of this literal will get its first two whitespaces removed * Whitespace after the opening and before the closing triple quote will be removed as well. The first line will be completely removed if it only contains whitespace. e.g. this strings first character is `T` not `\\n`. \"\"\" 字符串示例： 如果您的Pony程序中有多出使用相同的单字符字符串时，所有这些字符串都将转换为同一个实例。它们始终相等。\nlet pony = \"🐎\" let another_pony = \"🐎\" if pony is another_pony then // True, therefore this line will run. end 数组（Array Literals） 数组的值需要用方括号括起来。数组的元素可以是任何类型的表达式。元素之间用分号;或换行符分隔：\nlet my_literal_array = [ \"first\"; \"second\" \"third one on a new line\" ] 类型接口（Type inference） 如果没有指定数组的类型，数组表达式的返回类型默认为Array [T] ref，并且，将T（元素的类型）推导为所有元素类型的并集：\nlet my_heterogenous_array = [ U64(42) \"42\" U64.min_value() ] 在上面的示例中，由于数组包含String和U64元素，因此生成的数组类型为Array [(U64 | String)] ref。\n如果将分配给数组的元素是其他类型，Pony将会强制转换为数组的定义类型（译者注：不用担心，如果传入的类型无法被转换编译时就会报错）：\nlet my_stringable_array: Array[Stringable] ref = [ U64(0xA) \"0xA\" ] 这里，my_stringable_array被强制转换为Array [Stringable] ref。之所以能编译通过，是因为String和U64都实现了Stringable特征。\n通过在数组上指定类型说明符val，可以与[ref]不同的引用权能（Reference Capability）的数组：\nlet my_immutable_array: Array[Stringable] val = [ U64(0xBEEF) \"0xBEEF\" ] 你可以创建任何引用权能（Reference Capability）的数组类型。\nas表达式 也有可能使用as表达式来提示数组元素的类型。提示表达式需要在方括号后添加，还要加上冒号：\nlet my_as_array = [ as Stringable: U64(0xFFEF) \"0xFFEF\" U64(1 + 1) ] 这个as表达式，约束此数组类型为：Array [Stringable] ref。\n如果在左侧指定了类型，则需要数组元素与as表达式中的类型完全匹配。\n数组和引用 用字面量构造一个数组会创建对其元素的新引用。因此，为了确保100%的正确性，会将数组元素推导为实际元素类型的别名。如果所有元素的类型均为T，则将数组的北行会被推导为Array [T!] ref，即类型别名为T的数组。\n要使用具有多种引用权能的数组（例如val和ref引用权能类型）可以参考下（构造函数和所有权转让章节）。\n","summary":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\n每一种编程语言都会有字面量对数据的类型进行描述，Pony也不例外。\nPony表达式中常用的字面量有：布尔、数值、字符、字符串、数组。\nBool型 布尔类型有两个可选值：true 和 false。\n数字型 数字型字面量包括：有符号整数、无符号整数和浮点数。\n在大多数情况下，Pony可以从上下文中推导出具体的数据类型（这包括，分配给字段或局部变量或作为方法/行为调用的参数）。\n可以使用以下一种数字类型的构造函数来帮助编译器确定字面量的具体类型：\n U8, U16, U32, U64, U128, USize, ULong I8, I16, I32, I64, I128, ISize, ILong F32, F64  let my_explicit_unsigned: U32 = 42_000 let my_constructor_unsigned = U8(1) let my_constructor_float = F64(1.234) 整数可以以十进制，十六进制或二进制形式给出：\nlet my_decimal_int: I32 = 1024 //十进制 let my_hexadecimal_int: I32 = 0x400\t//十六进制 let my_binary_int: I32 = 0b10000000000\t//二进制 浮点文字以标准浮点或科学计数法表示：","title":"字面量（Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/literals.html"},{"content":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n A capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.\n So what’s that token? It’s an address. A pointer. A reference. It’s just… an object.\nHow is that unforgeable? Since Pony has no pointer arithmetic and is both type-safe and memory-safe, object references can’t be “invented” (i.e. forged) by the program. You can only get one by constructing an object or being passed an object.\nWhat about the C FFI? Using the C FFI can break this guarantee. We’ll talk about the C FFI trust boundary later, and how to control it.\nWhat about global variables? They’re bad! Because you can get them without either constructing them or being passed them.\nGlobal variables are a form of what is called ambient authority. Another form of ambient authority is unfettered access to the file system.\nPony has no global variables and no global functions. That doesn’t mean all ambient authority is magically gone - we still need to be careful about the file system, for example. Having no globals is necessary, but not sufficient, to eliminate ambient authority.\nHow does this help? Instead of having permissions lists, access control lists, or other forms of security, the object-capabilities model means that if you have a reference to an object, you can do things with that object. Simple and effective.\nThere’s a great paper on how the object-capability model works, and it’s pretty easy reading:\n权能梦碎——对象权能模型跌落神坛\nCapabilities and concurrency The object-capability model on its own does not address concurrency. It makes clear what will happen if there is simultaneous access to an object, but it does not prescribe a single method of controlling this.\nCombining capabilities with the actor-model is a good start, and has been done before in languages such as E and Joule.\nPony does this and also uses a system of reference capabilities in the type system.\n","summary":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n A capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.\n So what’s that token? It’s an address. A pointer. A reference. It’s just… an object.\nHow is that unforgeable? Since Pony has no pointer arithmetic and is both type-safe and memory-safe, object references can’t be “invented” (i.e. forged) by the program.","title":"对象权能模型（Object Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/object-capabilities.html"},{"content":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 和 函数 的区别：函数是 同步执行 的，行为是 异步执行 的。当您调用一个函数时，该函数将立即执行，并且立即就可以得到返回值。函数就像其他面向对象语言中的方法调用一样。\n行为被调用后 不会 立即执行。相反，该行为的将在未来的某个时间执行。\n行为看起来很像一个函数，但它不是用关键字fun定义的，而是用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何权能接收器上调用行为），但不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None（None基元类的实例），就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) 在这个例子里，我们定义了一个可以异步进餐的土拨鼠。\n消息处理 如果您熟悉基于actor模型的语言（例如Erlang），那么你对\"消息传递\"的概念一定很熟悉了。actor之间就是这样交流的。Pony中的行为等价于Erlang中的消息。当您调用actor的行为时，相当于在向其发送消息。\n如果您不熟悉消息传递，也不必担心。所有内容将在下面说明。\n并发 由于行为是异步执行的，因此可以同时运行很多个行为，这在Pony程序中的很常见。Pony程序在运行的时候会启动一个调度器，默认情况下，该调度器的线程数等于您计算机上的CPU内核数。每个调度器的线程随时待命执行actor的行为，因此Pony程序是原生并发的。\n执行次序 Actor自身是有序的，（译者注：一个actor同一时间只会归属于一个调度器线程），并且每个actor一次只能执行一个行为。编写actor的代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，actor运行的时候只会按照顺序执行操作。在下面的示例中，Main actor调用了一个行为call_me_later，该行为 异步执行 ，因此我们无需等待它运行就可以继续。然后，我们运行方法 env.out.print，它也是 异步执行的 ，并将文本输出到控制台。现在，我们已经了解了Main actor的工作机制，尝试运行下程序吧。\nactor Main new create(env: Env) =\u003e call_me_later(env) env.out.print(\"This is printed first\") be call_me_later(env: Env) =\u003e env.out.print(\"This is printed last\") 所有代码都在同一个actor中运行，并且对其他行为env.out.print的调用也都是顺序的，因此始终会先输出\"This is printed first\"后输出\"This is printed last\"。\n为什么这些代码时安全的？ 得益于Pony的 权能安全的类型系统 。之前在讨论函数接收器引用权能的时候，我们已经简单的介绍了引用权能。它们是对类型的注释，这些注释使得Pony在处理并行问题上没有任何运行时开销。\n稍后我们将深入介绍引用权能。\nActor的开销非常低 如果您以前做过并发编程，你一定很清楚线程的开销非常昂贵。上下文切换可能会导致一系列问题，每个线程都需要一个堆栈（这会占用很多内存），并且您需要大量的锁和其他机制来辅助编写线程安全的代码。\n但是actor的开销可以忽略不计。与类对象相比，actor的额外开销大约为256个字节的内存。注意是字节，而不是千字节！而且没有锁，也没有上下文切换。除了少数几个额外的内存字节外，没有执行的actor不会消耗资源。\n一个程序中使用成千上万的actor对Pony来说是再正常不过的事。\nActor finalisers 和类一样，actor也有销毁函数。销毁函数的定义也是（fun _final（））。类的销毁函数的所有保证和限制也对actor有效。另外，actor的销毁函数被调用后，就不会再收到任何消息。\n","summary":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 和 函数 的区别：函数是 同步执行 的，行为是 异步执行 的。当您调用一个函数时，该函数将立即执行，并且立即就可以得到返回值。函数就像其他面向对象语言中的方法调用一样。\n行为被调用后 不会 立即执行。相反，该行为的将在未来的某个时间执行。\n行为看起来很像一个函数，但它不是用关键字fun定义的，而是用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何权能接收器上调用行为），但不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None（None基元类的实例），就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) 在这个例子里，我们定义了一个可以异步进餐的土拨鼠。\n消息处理 如果您熟悉基于actor模型的语言（例如Erlang），那么你对\"消息传递\"的概念一定很熟悉了。actor之间就是这样交流的。Pony中的行为等价于Erlang中的消息。当您调用actor的行为时，相当于在向其发送消息。\n如果您不熟悉消息传递，也不必担心。所有内容将在下面说明。\n并发 由于行为是异步执行的，因此可以同时运行很多个行为，这在Pony程序中的很常见。Pony程序在运行的时候会启动一个调度器，默认情况下，该调度器的线程数等于您计算机上的CPU内核数。每个调度器的线程随时待命执行actor的行为，因此Pony程序是原生并发的。\n执行次序 Actor自身是有序的，（译者注：一个actor同一时间只会归属于一个调度器线程），并且每个actor一次只能执行一个行为。编写actor的代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，actor运行的时候只会按照顺序执行操作。在下面的示例中，Main actor调用了一个行为call_me_later，该行为 异步执行 ，因此我们无需等待它运行就可以继续。然后，我们运行方法 env.out.print，它也是 异步执行的 ，并将文本输出到控制台。现在，我们已经了解了Main actor的工作机制，尝试运行下程序吧。\nactor Main new create(env: Env) =\u003e call_me_later(env) env.","title":"并发单元（Actors）","uri":"https://damon-kwok.github.io/pony-tutorial/types/actors.html"},{"content":"我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来，逐行解释它们的含义：\n第一行 actor Main 这是一个类型声明。actor关键字表示定义了一个并发执行单元，暂时你只要了解到这是Pony声明Main函数的做法，等同于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲到。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Main actor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。new关键字表示它可以被实例化，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。可以用不同的构造函数创建不同的实例。这里我们用的是默认构造函数create。\n接下来，构造函数的参数。构造函数定义了一个env参数，类型为Env。\nPony的参数类型在参数名之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、TypeScript、ActionScript、Haxe等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout （可以在控制台上输出一些内容）。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号是C/C++的风格的定义方式（支持字符转译）。三引号\"\"\"可以定义Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony中没有全局变量，需要通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名为Main的actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。下一节讲解Pony的类型系统。\n","summary":"我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来，逐行解释它们的含义：\n第一行 actor Main 这是一个类型声明。actor关键字表示定义了一个并发执行单元，暂时你只要了解到这是Pony声明Main函数的做法，等同于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲到。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Main actor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。new关键字表示它可以被实例化，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。可以用不同的构造函数创建不同的实例。这里我们用的是默认构造函数create。\n接下来，构造函数的参数。构造函数定义了一个env参数，类型为Env。\nPony的参数类型在参数名之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、TypeScript、ActionScript、Haxe等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout （可以在控制台上输出一些内容）。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号是C/C++的风格的定义方式（支持字符转译）。三引号\"\"\"可以定义Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony中没有全局变量，需要通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名为Main的actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。下一节讲解Pony的类型系统。","title":"庖丁解牛","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/how-it-works.html"},{"content":"你可能熟悉Python、Ruby、Java、C++等语言中的异常处理方式，Pony中有所不同，Pony提供了一个更简单的机制来帮助处理异常。Pony触发异常的方式与其他语言有一些重要的语义区别，Pony用error（还有as）关键字和偏函数(Partial functions)来触发异常。让我们看看Pony是如何处理异常的，然后和你习惯的语言对比一下有什么不同。\n异常的触发和处理(Raising and handling errors) 使用error可以触发一个异常。可以任何时候都可以使用error。此时后续代码会停止执行，调用链被解除，逻辑跳寻找并转到异常处理代码块中继续执行。异常处理机制是在编译时会进行检查，确保在运行时不会导致整个程序崩溃。\n异常处理程序是使用try-else语法声明的。\ntry callA() if not callB() then error end callC() else callD() end 在上面的代码中，callA()总是会被执行，callB()也会被执行。如果callB()的返回值为true，那么我们将按照正常方式继续执行callC()，那么callD()将不会被执行。\n但是，如果callB()返回false，则会触发一个异常。此时，执行将停止，寻找并执行最近的异常处理程序。在本例中，else中的callD()将被执行。\n在这两种情况下，程序都将继续执行try end后面的逻辑。\n必须提供一个异常处理程序吗? 不需要。try可以单独工作。如果不提供else，则不会执行任何异常处理操作,直接转转到try表达式之后继续执行。\n如果有一些可能会触发异常的逻辑，但你不需要在发生后做出处理(比如:一个文件存在的话就读取它的内容)，可以把这段逻辑里面放在一个try中,不需要提供else。\ntry // Do something that may raise an error end __异常处理逻辑中需要做些什么? __ 无所谓。如果您提供了一个异常处理程序，那么它必须包含一些代码，具体执行些什么逻辑取决于你自己。\n一个try代码块的返回值是什么?try的返回值是try的最后一个表达式的值，如果出现过程中出现了异常，就使用else子句中的最后一个表达式的值。如果出现了一个异常，并且没有提供else子句，那么返回值将是None。\n偏函数(Partial functions) Pony并不要求像前面的例子那样立即处理所有的异常。函数执行时可能触发异常，而这些异常可以由调用它们的代码处理。这些被称为偏函数(Partial functions)(这是一个数学术语，意思是对于所有可能的输入(即参数)没有定义返回值的函数)。偏函数必须在函数签名(定义返回类型)之后和调用位置(右括号之后)加上?。\n下面示例，如果输入为负数，那么接受有符号整数的阶乘函数就会出错。这个函数只在有效的输入时才会正确执行。\nfun factorial(x: I32): I32 ? =\u003e if x \u003c 0 then error end if x == 0 then 1 else x * factorial(x - 1)? end 在Pony会发生异常的逻辑(error表达式，偏函数的调用，或者某些内置的机制（比如as）)，都必须实用try代码块，或者放在偏函数中。编译时对此进行检查，以确保异常的触发不会导致程序崩溃。\n在Pony的0.16.0版本之前，偏函数的调用位置不需要标记?，在阅读代码时会有点费解。之后的版本为偏函数作出清楚的标记，代码更易读，可以清晰的了解逻辑会跳转到最近的异常处理代码块中执行，条例更加清晰明确。\n部分构造函数和行为(Partial constructors and behaviours) 类的构造函数也可以标记为偏函数。如果在类的构造函数中触发异常，则认为构造失败，正在构造的对象被丢弃，而且不会返回给调用者。\n当调用actor构造函数时，将创建actor并立即返回对它的引用。但是，actor的构造函数代码将在稍后的某个时间异步执行。如果在actor构造函数内触发一个异常，那么向调用者报告这个异常就晚了。因此，actor的构造函数不能被设置为偏函数。\n行为也是异步执行的，因此行为也不被标记为偏函数。\nTry-then表达式 除了else表达式外，try还可以使用then表达式。它会在try和else之后执行，不管是否触发异常一定会被执行。我们对前面的示例做一下扩展:\ntry callA() if not callB() then error end callC() else callD() then callE() end callE()始终会被执行。如果callB()返回true，那么执行的序列是callA()， callB()， callC()， callE()。如果callB()返回false，那么执行的序列是callA()， callB()， callD()， callE()。\n必须在使用了else处理程序后,才能用then表达式吗? 不需要。如果你喜欢的话，你可以直接使用try-then,省略掉else。\nthen代码块真的总是被执行吗，如果在try里面直接retuan呢? 放心，当try表达式无论以何种方式完成时，你的then表达式一定会被执行。唯一的例外情况的是，如果try永远无法完成(陷入一个死循环)，电脑被人拔掉电源，或者进程被终止(那你的then就有可能不会被执行…)。\nWith表达式 with表达式可用于对象不再需要时,执行一些处理操作。常见的情况是数据库连接在使用后需要关闭，以避免服务器上的资源浪费。例如:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj end obj.dispose()会自动在with表达式内的代码成功完成或触发异常时被调用。一个对象要使用with表达式，需要必须提供一个dispose()方法:\nclass SomeObjectThatNeedsDisposing // constructor, other functions fun dispose() =\u003e // release resources 可以with提供else选项，它只在触发了异常的情况下被调用:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj else // only run if an error has occurred end with可以一次设置多个对象进行处理:\nwith obj = SomeObjectThatNeedsDisposing(), other = SomeOtherDisposableObject() do // use obj end with的返回值是代码块中的最后一个表达式的值，或者是else代码块中的最后一个表达式的值(如果有一个表达式并且发生了异常)。\n触发异常的关键字 除了error表达式或调用偏函数外，触发异常还可以使用as表达式。比如，将给定的值转换为指定的类型,如果不能转换，就会触发异常。所以as命令只能在try代码块或偏函数中使用。\n与其他语言中的异常处理进行比较 Pony的异常处理与C++、Java、C#、Python和Ruby中的异常处理非常类似。主要的区别在于，Pony的异常不需要与类型或实例相关联。这就像抛出固定错误号的C++异常一样。throw 3;。这种方式简化了程序员的异常处理逻辑，也可以拥有更好的运行时性能。\ntry表达式中的else处理程序就像C++中的catch(...)，Java或C#中的catch(Exception e)， Python中的except:或Ruby中的rescue。因为异常没有类型，所以处理程序不需要指定类型，也就不需要一个try代码块中对应多个异常处理程序。\ntry表达式中的then代码块就像Java、C#或Python中的finally和Ruby中的ensure一样。\n如果需要，异常处理逻辑可以通过使用error表达式再次执行。\n","summary":"你可能熟悉Python、Ruby、Java、C++等语言中的异常处理方式，Pony中有所不同，Pony提供了一个更简单的机制来帮助处理异常。Pony触发异常的方式与其他语言有一些重要的语义区别，Pony用error（还有as）关键字和偏函数(Partial functions)来触发异常。让我们看看Pony是如何处理异常的，然后和你习惯的语言对比一下有什么不同。\n异常的触发和处理(Raising and handling errors) 使用error可以触发一个异常。可以任何时候都可以使用error。此时后续代码会停止执行，调用链被解除，逻辑跳寻找并转到异常处理代码块中继续执行。异常处理机制是在编译时会进行检查，确保在运行时不会导致整个程序崩溃。\n异常处理程序是使用try-else语法声明的。\ntry callA() if not callB() then error end callC() else callD() end 在上面的代码中，callA()总是会被执行，callB()也会被执行。如果callB()的返回值为true，那么我们将按照正常方式继续执行callC()，那么callD()将不会被执行。\n但是，如果callB()返回false，则会触发一个异常。此时，执行将停止，寻找并执行最近的异常处理程序。在本例中，else中的callD()将被执行。\n在这两种情况下，程序都将继续执行try end后面的逻辑。\n必须提供一个异常处理程序吗? 不需要。try可以单独工作。如果不提供else，则不会执行任何异常处理操作,直接转转到try表达式之后继续执行。\n如果有一些可能会触发异常的逻辑，但你不需要在发生后做出处理(比如:一个文件存在的话就读取它的内容)，可以把这段逻辑里面放在一个try中,不需要提供else。\ntry // Do something that may raise an error end __异常处理逻辑中需要做些什么? __ 无所谓。如果您提供了一个异常处理程序，那么它必须包含一些代码，具体执行些什么逻辑取决于你自己。\n一个try代码块的返回值是什么?try的返回值是try的最后一个表达式的值，如果出现过程中出现了异常，就使用else子句中的最后一个表达式的值。如果出现了一个异常，并且没有提供else子句，那么返回值将是None。\n偏函数(Partial functions) Pony并不要求像前面的例子那样立即处理所有的异常。函数执行时可能触发异常，而这些异常可以由调用它们的代码处理。这些被称为偏函数(Partial functions)(这是一个数学术语，意思是对于所有可能的输入(即参数)没有定义返回值的函数)。偏函数必须在函数签名(定义返回类型)之后和调用位置(右括号之后)加上?。\n下面示例，如果输入为负数，那么接受有符号整数的阶乘函数就会出错。这个函数只在有效的输入时才会正确执行。\nfun factorial(x: I32): I32 ? =\u003e if x \u003c 0 then error end if x == 0 then 1 else x * factorial(x - 1)?","title":"异常处理（Errors）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/errors.html"},{"content":"Since types are guarantees, it’s useful to talk about what guarantees a reference capability makes.\nWhat is denied We’re going to talk about reference capability guarantees in terms of what’s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?\nWe need to distinguish between the actor that contains the variable in question and other actors.\nThis is important because data reads and writes from other actors may occur concurrently. If two actors can both read the same data and one of them changes it then it will change under the feet of the other actor. This leads to data-races and the need for locks. By ensuring this situation can never occur, Pony eliminates the need for locks.\nAll code within any one actor always executes sequentially. This means that data accesses from multiple variables within a single actor do not suffer from data-races.\nMutable reference capabilities The mutable reference capabilities are iso, trn and ref. These reference capabilities are mutable because they can be used to both read from and write to an object.\n If an actor has an iso variable, no other variable can be used by any actor to read from or write to that object. This means an iso variable is the only variable anywhere in the program that can read from or write to that object. It is read and write unique. If an actor has a trn variable, no other variable can be used by any actor to write to that object, and no other variable can be used by other actors to read from or write to that object. This means a trn variable is the only variable anywhere in the program that can write to that object, but other variables held by the same actor may be able to read from it. It is write unique. If an actor has a ref variable, no other variable can be used by other actors to read from or write to that object. This means that other variables can be used to read from and write to the object, but only from within the same actor.  Why can they be used to write? Because they all stop other actors from reading from or writing to the object. Since we know no other actor will be reading, it’s safe for us to write to the object, without having to worry about data-races. And since we know no other actor will be writing, it’s safe for us to read from the object, too.\nImmutable reference capabilities The immutable reference capabilities are val and box. These reference capabilities are immutable because they can be used to read from an object, but not to write to it.\n If an actor has a val variable, no other variable can be used by any actor to write to that object. This means that the object can’t ever change. It is globally immutable. If an actor has a box variable, no other variable can be used by other actors to write to that object. This means that other actors may be able to read the object and other variables in the same actor may be able to write to it (although not both). In either case, it is safe for us to read. The object is locally immutable.  Why can they be used to read but not write? Because these reference capabilities only stop other actors from writing to the object. That means there is no guarantee that other actors aren’t reading from the object, which means it’s not safe for us to write to it. It’s safe for more than one actor to read from an object at the same time though, so we’re allowed to do that.\nOpaque reference capabilities There’s only one opaque reference capability, which is tag. A tag variable makes no guarantees about other variables at all. As a result, it can’t be used to either read from or write to the object; hence the name opaque.\nIt’s still useful though: you can do identity comparison with it, you can call behaviours on it, and you can call functions on it that only need a tag receiver.\nWhy can’t tag be used to read or write? Because tag doesn’t stop other actors from writing to the object. That means if we tried to read, we would have no guarantee that there wasn’t some other actor writing to the object, so we might get a race condition.\n","summary":"Since types are guarantees, it’s useful to talk about what guarantees a reference capability makes.\nWhat is denied We’re going to talk about reference capability guarantees in terms of what’s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?\nWe need to distinguish between the actor that contains the variable in question and other actors.\nThis is important because data reads and writes from other actors may occur concurrently.","title":"引用权能保证（Reference Capability Guarantees）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/guarantees.html"},{"content":"如果对象具有权能，我们该怎么来控制？比如如何表示该对象的 访问权限（access rights） ？\nPony中，可以用引用权能（reference capabilities）来处理。\n权限只是权能的一部分 如果在UNIX系统中打开一个文件，会返回一个文件描述符，该文件描述符只是一个文件指向标识——并不是一个权能（描述符只体现了能没有体现权,描述符使可以访问文件，但是访问权呢？）。完整的权能：需要获得权限，然后指定文件路径和打开模式。例如:\nchmod u+w /etc/passwd int fd = open(\"/etc/passwd\", O_RDWR); 现在我们拥有了/etc/passwd文件的读写权，然后使用O_RDWR模式打开们见得到了一个文件描述符。访问授权、打开模式、文件描述符共同构成了一个权能。\n在Pony中，所有被引用的数据都有一个类型和一个引用权能（reference capabilities）。实际上，引用权能（reference capabilities）是其类型的一部分。这允许你指定哪些对象可以与其他actor共享，并允许编译器检查你的逻辑是并发安全的。\n基本概念（Basic concepts） 在引用权能（reference capabilities）变得有意义之前，您需要理解一些简单的概念。我们已经讨论过其中的一些，有些可能对你来说已经很明显了，但是在这里值得回顾一下。\n共享可变数据非常困难\n并发性的问题根源来自于共享可变数据。如果两个线程可以同时访问同一个数据，那么它们可能会同时修改它。这最多可能导致两个线程拥有不同版本的数据。在最坏的情况下，更新可能会交互不良，导致数据被垃圾覆盖。避免这些问题的常规做法是使用锁来防止同时发生数据更新。这会导致巨大的性能开销（上下文切换），并且一不小心就会导致bug。\n不可变数据可以安全地共享\n任何不可变的数据(即不会被修改数据)都可以安全地并发使用。因为它们永远不会更新，正是更新导致了并发性问题。\n被隔离的数据是安全的\n如果一个数据块只有一个对它的引用，那么我们称它为 被隔离的数据(isolated) 。因为只有一个对它的引用，所以不会被被多个线程共享，也就不存在并发问题。被隔离的数据可以在多个线程之间传递。只要同一时间只存在一个对它的引用，那么数据就是安全的，不会出现并发问题。\n被隔离的数据有可以是复合类型\n一个被隔离的数据（isolated）可以是一个字节，也可以是一个大型数据结构，并且在该结构中的各个对象之间有多个引用。对于隔离的数据来说，重要的是整个程序中只有一个单一的引用。我们讨论了数据结构的隔离边界。对结构进行隔离:\n 外部必须只能有一个指向内部对象的引用。 外部可以有任意数量的引用，但它们都不能指向外部的对象。  每个actor都只会在一个线程中运行\nactor内部的代码永远不会并发运行。在actor中，数据更新不会导致并发问题。只有当我们希望在actor之间共享数据时，才会遇到问题。\n好吧，看来同时安全地共享数据确实很棘手，来看看引用权能（reference capabilities）是怎么做到的。\n通过只共享不可变的数据和只交换被隔离的数据，我们可以拥有没有锁的安全并发程序。问题是要正确地做到这一点是非常困难的。如果您不小心挂起了对某些已提交的独立数据的引用，或者将已共享的内容更改为不可变的，那么一切都会出错。你需要的是编译器强迫你去实现你的承诺。小马引用权能（reference capabilities）允许编译器这样做。\n类型限定符（Type qualifiers） 如果你使用过C/C++，您可能熟悉const，它是一个 类型限定符（type qualifier） ，告诉编译器不允许程序员修改某些东西。\nA reference capability is a form of type qualifier and provides a lot more guarantees than const does! 引用权能（reference capabilities）是 type qualifier 的一种形式，它提供了比const多得多的保证!\n在Pony中，所有的类型都有一个引用权能（reference capabilities）作为类型限定符。这个规则只适用于变量（局部变量、字段、参数等），而不是类型。换句话说，当你定义一个类Wombat时，你不会为这个类的所有实例使用某个引用权能（reference capabilities）。相反，Wombat的每个字段都有自己的引用权能（reference capabilities）。\n例如，在某些语言中，必须定义一个表示可变字符串(String)的类型和另一个表示不可变字符串的类型。例如，在Java中，有一个String和一个StringBuilder。在Pony中，一个String类就够了，定义可变字符串：String ref和不可变字符串：String val。\n引用权能（reference capabilities）列表 Pony有六种引用权能（reference capabilities），它们都有严格的定义和使用规则。我们稍后会讲到，现在先来看看它们的名字和用途:\n被隔离的数据（Isolated），关键字为iso。这是为了引用隔离的数据结构。如果你有一个“iso”变量，那么你就知道没有其他变量可以访问这些数据。所以你可以随心所欲地改变它，把它给另一个演员。\n不可变数据（Value）,关键字为val。这是用于引用不可变的数据结构。如果你有一个“val”变量，那么你就知道没有人可以改变数据。所以你可以读它，并与其他演员分享。\n可变数据（Reference），关键字为ref。这是为了引用非独立的可变数据结构，换句话说，就是“正常”数据。如果你有一个ref变量，那么你可以读和写的数据，无论你喜欢，你可以有多个变量，可以访问相同的数据。但是你不能和其他演员分享。\n只读引用（Box） ，关键字为box，这是为了引用对您来说是只读的数据。这些数据可能是不可变数据，并与其他actor共享，或者在您的actor中使用它的其他变量可以更改数据。无论哪种方式，box变量都可以用来安全地读取数据。这听起来可能有点无意义，但它允许您编写既可以用于val变量又可以用于ref变量的代码，只要它不写入对象即可。\n可传输数据（Transition）,关键字为trn。这用于您希望写入的数据结构，同时为它们保存只读(box)变量。如果您愿意，您还可以稍后将trn变量转换为val变量，这将阻止任何人更改数据，并允许与其他actor共享数据。\n标识（Tag） 关键字为tag。它仅用于定义标识符。不能对tag变量进行读写。但是tag可以存储和比较，可以方便的用以对象标识检查，另外tag变量可以与其他actor共享。\n注意，如果您有一个变量引用一个actor，那么您可以向该actor发送消息，而不用关心该变量具有什么引用权能（reference capabilities）。\n引用权能如何使用（How to write a reference capability） 引用权能（reference capabilities）限定符放在类型后。举个例子:\nString iso // An isolated string String trn // A transition string String ref // A string reference String val // A string value String box // A string box String tag // A string tag 当类型没有指定引用权能（reference capabilities）时，它意味着什么?__意味着你使用了该类型的 默认 引用权能（reference capabilities），默认引用权能是和类型一起定义的。下面是来自标准库的一个例子:\nclass val String 当我们使用一个字符串时，我们通常指的是一个不可变的字符串值，因此我们将val作为String的默认引用权能（reference capabilities）(但不一定是String构造函数，请参阅下面)。例如，当我们没有在下面的代码中指定引用权能时，编译器会使用默认引用权能（reference capabilities）``val:\nlet a: String val = \"Hello, world!\" let b: String = \"I'm a wombat!\" // Also a String val 所以定义一个类型时，必须指定一个引用权能（reference capabilities）吗？ 有特殊需求时才需要制定，大多数类型都会使用合理的默认值。类使用ref，基元类使用val(即不可变的引用)，以及actor使用tag。\n如何创建具有不同引用权能的对象 在编写构造函数时，该构造函数默认将创建一个具有ref或tag功能的新对象。actor的构造函数总是创建一个tag。对于class默认为ref，但是你可以使用其他引用权能创建。来看一个例子:\nclass Foo let x: U32 new val create(x': U32) =\u003e x = x' 当你调用Foo。create(1)时，你会得到一个Foo val而不是Foo ref。\n但是如果你想同时创建val和ref的Foo实例呢？你可以这样做：\nclass Foo let x: U32 new val create_val(x': U32) =\u003e x = x' new ref create_ref(x': U32) =\u003e x = x' 但是，这不是最佳做法。最好的做法是使用Pony的权能借用功能，我们将在后面的权能借用一节中介绍。\n","summary":"如果对象具有权能，我们该怎么来控制？比如如何表示该对象的 访问权限（access rights） ？\nPony中，可以用引用权能（reference capabilities）来处理。\n权限只是权能的一部分 如果在UNIX系统中打开一个文件，会返回一个文件描述符，该文件描述符只是一个文件指向标识——并不是一个权能（描述符只体现了能没有体现权,描述符使可以访问文件，但是访问权呢？）。完整的权能：需要获得权限，然后指定文件路径和打开模式。例如:\nchmod u+w /etc/passwd int fd = open(\"/etc/passwd\", O_RDWR); 现在我们拥有了/etc/passwd文件的读写权，然后使用O_RDWR模式打开们见得到了一个文件描述符。访问授权、打开模式、文件描述符共同构成了一个权能。\n在Pony中，所有被引用的数据都有一个类型和一个引用权能（reference capabilities）。实际上，引用权能（reference capabilities）是其类型的一部分。这允许你指定哪些对象可以与其他actor共享，并允许编译器检查你的逻辑是并发安全的。\n基本概念（Basic concepts） 在引用权能（reference capabilities）变得有意义之前，您需要理解一些简单的概念。我们已经讨论过其中的一些，有些可能对你来说已经很明显了，但是在这里值得回顾一下。\n共享可变数据非常困难\n并发性的问题根源来自于共享可变数据。如果两个线程可以同时访问同一个数据，那么它们可能会同时修改它。这最多可能导致两个线程拥有不同版本的数据。在最坏的情况下，更新可能会交互不良，导致数据被垃圾覆盖。避免这些问题的常规做法是使用锁来防止同时发生数据更新。这会导致巨大的性能开销（上下文切换），并且一不小心就会导致bug。\n不可变数据可以安全地共享\n任何不可变的数据(即不会被修改数据)都可以安全地并发使用。因为它们永远不会更新，正是更新导致了并发性问题。\n被隔离的数据是安全的\n如果一个数据块只有一个对它的引用，那么我们称它为 被隔离的数据(isolated) 。因为只有一个对它的引用，所以不会被被多个线程共享，也就不存在并发问题。被隔离的数据可以在多个线程之间传递。只要同一时间只存在一个对它的引用，那么数据就是安全的，不会出现并发问题。\n被隔离的数据有可以是复合类型\n一个被隔离的数据（isolated）可以是一个字节，也可以是一个大型数据结构，并且在该结构中的各个对象之间有多个引用。对于隔离的数据来说，重要的是整个程序中只有一个单一的引用。我们讨论了数据结构的隔离边界。对结构进行隔离:\n 外部必须只能有一个指向内部对象的引用。 外部可以有任意数量的引用，但它们都不能指向外部的对象。  每个actor都只会在一个线程中运行\nactor内部的代码永远不会并发运行。在actor中，数据更新不会导致并发问题。只有当我们希望在actor之间共享数据时，才会遇到问题。\n好吧，看来同时安全地共享数据确实很棘手，来看看引用权能（reference capabilities）是怎么做到的。\n通过只共享不可变的数据和只交换被隔离的数据，我们可以拥有没有锁的安全并发程序。问题是要正确地做到这一点是非常困难的。如果您不小心挂起了对某些已提交的独立数据的引用，或者将已共享的内容更改为不可变的，那么一切都会出错。你需要的是编译器强迫你去实现你的承诺。小马引用权能（reference capabilities）允许编译器这样做。\n类型限定符（Type qualifiers） 如果你使用过C/C++，您可能熟悉const，它是一个 类型限定符（type qualifier） ，告诉编译器不允许程序员修改某些东西。\nA reference capability is a form of type qualifier and provides a lot more guarantees than const does! 引用权能（reference capabilities）是 type qualifier 的一种形式，它提供了比const多得多的保证!","title":"引用权能（Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html"},{"content":"在Pony中，所有的执行逻辑（代码）都被放在方法中。方法有三种：函数、构造函数和行为。所有的方法都要写在类型定义中（例如：类、基元类、actor等），不存在全局函数或全局行为。\n行为用于处理发送给参与者的异步消息，我们在类型系统章节中已经讲解过行为。\n可以像Python那样在任何方法之外添加一些代码吗？ 不行。所有的Pony代码都必须在一个方法中。\n函数（Functions） Pony的函数与其他语言中的函数（或方法）非常相似。它们可以具有0个或多个参数，以及0个或1个返回值（如果需要像Go语言的多返回值可以使用元组）。如果省略了返回类型，则该函数的返回值将为None。\nclass C fun add(x: U32, y: U32): U32 =\u003e x + y fun nop() =\u003e add(1, 2) // Pointless, we ignore the result 函数参数（如果有）在函数名称后的括号中指定。即便没有任何参数的函数定义时，括号也不能省略。\n每个参数都有一个名称和类型。在我们的示例函数中，add函数有两个参数x和y，它们都是U32类型。传递给函数调用的值（示例中为1和 2）称为实参（arguments），并且在进行调用时会对其求值并分配给形参（parameters）。形参虽然没有明确给出声明的方式，但实际上它们被声明为let。\n形参后面的的是返回类型。如果不需要返回值，可以省略。\n返回值后面是=\u003e，最后是函数体。返回值是函数体表达式的执行结果（请记住，所有内容都是表达式），也就是函数中最后一条表达式的值。\n如果想从函数中提前返回，可以使用return表达式。如果函数具有返回类型，需要为return提供一个值。如果该函数没有返回类型，单独用return就行。\n可以按参数类型重载函数吗？ 不行，同一个类型中不允许出现重名的方法。\n构造函数（Constructors） 跟其他语言一样，Pony的构造函数也是用于初始化对象。不同的是，Pony构造函数可以自定义函数名字，也可以使用任意数量和类型的参数。Pony的默认构造函数（所有的类型定义都一样）为create。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x 构造函数的作用，是为了在创建对象时初始化对象内部状态。Pony中构造函数必须对所有字段做出初始化。\n可以从构造函数中提前返回吗？ 是的。使用不带值的return命令。但是要确保return前所有字段都已经进行了初始化。\n方法调用（Calling） 方法的调用与其他语言一样，通过在方法名称后的括号内提供参数来调用。即使没有参数需要传递，也需要括号。\nclass Foo fun hello(name: String): String =\u003e \"hello \" + name fun f() =\u003e let a = hello(\"Fred\") 要实例化一个类型，需要调用这个类型的构造函数。指定类型，后跟一个点，然后是要调用的构造函数名：\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = Foo.from_int(3) 调用对象的函数：对象名后跟一个点，然后是要调用的函数名。如果省略了要调用的对象，则使用当前对象（即this）。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x fun get(): U32 =\u003e _x class Bar fun f() =\u003e var a: Foo = Foo.from_int(3) var b: U32 = a.get() var c: U32 = g(b) fun g(x: U32): U32 =\u003e x + 1 构造函数也可以直接调用。相当于用this在调用，创建的对象类型就是当前类型。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = a.from_int(3) 我们甚至可以在赋值表达式中用另一个实例名来调用构造函数（上面的示例中）。\nclass Bar fun f() =\u003e var a: Foo = a.create() 来一个更骚的操作，上面例子中，我们用var a声明了一个Foo类型，然后直接使用a调用Foo的构造函数create()创建实例赋值给a。\n参数默认值（Default arguments） 在定义方法时，可以为参数提供默认值。调用者可以选择使用默认值，或者提供自己的值。参数的默认值在形参名后面用=指定。\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create() // Contains (0, 0) var b: Coord = Coord.create(3) // Contains (3, 0) var c: Coord = Coord.create(3, 4) // Contains (3, 4) 我必须为所有的参数提供默认值吗? 不需要，可以自己决定为哪些参数设置默认值。\n参数命名（Named arguments） 到目前为止，在调用方法时，我们总是按顺序给出所有参数。这被称为使用 位置传参或顺序传参（positional arguments） 。但是，我们也可以通过指定参数的名称来指定传参顺序。这被称为 命名传参或动态传参（named arguments）。\n要使用命名传参的方式调用方法，需要使用where关键字，然后是形参名和值。\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create(3, 4) // Contains (3, 4) var b: Coord = Coord.create(where y = 4, x = 3) // Contains (3, 4) 注意，上面示例中的b实例的创建，演示了如何使用where的用法。\n我需要为每个参数都指定一个where吗? 不需要。方法调用时只需要一个where。\n在方法的调用中可以同时使用命名传参和位置传参。从需要的位置开始，使用where关键字就可以了。但是要注意，每个参数只能指定一次。\n默认参数也可以与位置传参和命名传参结合使用——只需要忽略传递默认参数即可。\nclass Foo fun f(a: U32 = 1, b: U32 = 2, c: U32 = 3, d: U32 = 4, e: U32 = 5): U32 =\u003e 0 fun g() =\u003e f(6, 7 where d = 8) // Equivalent to: f(6, 7, 3, 8, 5) 使用位置传参调用方法是，是否忽略第一个参数? 不行。如果使用位置传参，没有设置默认值的参数必须放在前面。（注意：位置传参方式配合默认参数使用时，如果为方法的某个参数设置了默认值，后续的参数都必须给出默认值）。\n连续调用Chaining 方法链接允许您将对对象的调用链接起来，而不需要方法返回其接收器。调用一个方法并链接接收器的语法是object.\u003emethod()，它大致相当于(object.method() ; object)。连续调用方法时会丢弃它的正常返回值：\nprimitive Printer fun print_two_strings(out: StdStream, s1: String, s2: String) =\u003e out.\u003eprint(s1).\u003eprint(s2) // 等同于： out.print(s1) out.print(s2) out 注意，如果最后一次调用的返回值很重要的话，可以把.\u003e换成.。\ninterface Factory fun add_option(o: Option) fun make_object(): Object primitive Foo fun object_wrong(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).\u003emake_object() // 错误! 这个表达式返回的是`Facyory` fun object_right(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).make_object() // 正确。 这个表达式返回了一个`Object` 匿名方法（Anonymous methods） Pony中可以使用匿名方法（或者叫Lambdas）。看一下示例:\nuse \"collections\" actor Main new create(env: Env) =\u003e let list_of_numbers = List[U32].from([1; 2; 3; 4]) let is_odd = {(n: U32): Bool =\u003e (n % 2) == 1} let list_of_odd_numbers = list_of_numbers.filter(is_odd) for odd_number in list_of_odd_numbers.values() do env.out.print(odd_number.string()) end 在Object Literals section中有更详细的介绍。\n私有方法（Privacy） 在Pony中，方法名只能以小写字母或下划线后跟小写字母开头。下划线开头的方法是私有的。它们只能被当前包中的代码调用。非下划线开头的方法是公有的，可以在外部(其他包)调用。\n我可以用2个(或更多)下划线来开始我的方法名吗? 不行。如果第一个字符是下划线，那么第二个字符必须是小写字母。\n调用优先级(Precedence) 我们之前已经讨论过运算符符优先级，在Pony中，方法调用和字段访问的优先级比所有的运算符都要高。\n我们来总结回顾一下,在复杂的表达式中:\n 方法调用和字段访问的优先级高于任何运算符符。 一元运算符具有比中缀运算符更高的优先级。 在复杂表达式中混合中缀运算符时，我们必须使用括号来显式地指定前缀。  ","summary":"在Pony中，所有的执行逻辑（代码）都被放在方法中。方法有三种：函数、构造函数和行为。所有的方法都要写在类型定义中（例如：类、基元类、actor等），不存在全局函数或全局行为。\n行为用于处理发送给参与者的异步消息，我们在类型系统章节中已经讲解过行为。\n可以像Python那样在任何方法之外添加一些代码吗？ 不行。所有的Pony代码都必须在一个方法中。\n函数（Functions） Pony的函数与其他语言中的函数（或方法）非常相似。它们可以具有0个或多个参数，以及0个或1个返回值（如果需要像Go语言的多返回值可以使用元组）。如果省略了返回类型，则该函数的返回值将为None。\nclass C fun add(x: U32, y: U32): U32 =\u003e x + y fun nop() =\u003e add(1, 2) // Pointless, we ignore the result 函数参数（如果有）在函数名称后的括号中指定。即便没有任何参数的函数定义时，括号也不能省略。\n每个参数都有一个名称和类型。在我们的示例函数中，add函数有两个参数x和y，它们都是U32类型。传递给函数调用的值（示例中为1和 2）称为实参（arguments），并且在进行调用时会对其求值并分配给形参（parameters）。形参虽然没有明确给出声明的方式，但实际上它们被声明为let。\n形参后面的的是返回类型。如果不需要返回值，可以省略。\n返回值后面是=\u003e，最后是函数体。返回值是函数体表达式的执行结果（请记住，所有内容都是表达式），也就是函数中最后一条表达式的值。\n如果想从函数中提前返回，可以使用return表达式。如果函数具有返回类型，需要为return提供一个值。如果该函数没有返回类型，单独用return就行。\n可以按参数类型重载函数吗？ 不行，同一个类型中不允许出现重名的方法。\n构造函数（Constructors） 跟其他语言一样，Pony的构造函数也是用于初始化对象。不同的是，Pony构造函数可以自定义函数名字，也可以使用任意数量和类型的参数。Pony的默认构造函数（所有的类型定义都一样）为create。\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x 构造函数的作用，是为了在创建对象时初始化对象内部状态。Pony中构造函数必须对所有字段做出初始化。\n可以从构造函数中提前返回吗？ 是的。使用不带值的return命令。但是要确保return前所有字段都已经进行了初始化。\n方法调用（Calling） 方法的调用与其他语言一样，通过在方法名称后的括号内提供参数来调用。即使没有参数需要传递，也需要括号。\nclass Foo fun hello(name: String): String =\u003e \"hello \" + name fun f() =\u003e let a = hello(\"Fred\") 要实例化一个类型，需要调用这个类型的构造函数。指定类型，后跟一个点，然后是要调用的构造函数名：","title":"方法（Methods）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/methods.html"},{"content":"A recover expression lets you “lift” the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.\nWhy is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:\n Creating a cyclic immutable data structure. That is, you can create a complex mutable data structure inside a recover expression, “lift” the resulting ref to a val. “Borrow” an iso as a ref, do a series of complex mutable operations on it, and return it as an iso again. “Extract” a mutable field from an iso and return it as an iso.  What does this look like? The recover expression wraps a list of expressions and is terminated by an end, like this:\nrecover Array[String].create() end This expression returns an Array[String] iso, instead of the usual Array[String] ref you would get. The reason it is iso and not any of the other mutable reference capabilities is because there is a default reference capability when you don’t specify one. The default for any mutable reference capability is iso and the default for any immutable reference capability is val.\nHere’s a more complicated example from the standard library:\nrecover var s = String((prec + 1).max(width.max(31))) var value = x try if value == 0 then s.push(table(0)?) else while value != 0 do let index = ((value = value / base) - (value * base)) s.push(table(index.usize())?) end end end _extend_digits(s, prec') s.append(typestring) s.append(prestring) _pad(s, width, align, fill) s end That’s from format/_FormatInt. It creates a String ref, does a bunch of stuff with it, and finally returns it as a String iso.\nYou can also give an explicit reference capability:\nlet key = recover val line.substring(0, i).\u003estrip() end That’s from net/http/_PayloadBuilder. We get a substring of line, which is a String iso^, then we call strip on it, which returns itself. But since strip is a ref function, it returns itself as a String ref^ - so we use a recover val to end up with a String val.\nHow does this work? Inside the recover expression, your code only has access to sendable values from the enclosing lexical scope. In other words, you can only use iso, val and tag things from outside the recover expression.\nThis means that when the recover expression finishes, any aliases to the result of the expression other than iso, val and tag ones won’t exist anymore. That makes it safe to “lift” the reference capability of the result of the expression.\nIf the recover expression could access non-sendable values from the enclosing lexical scope, “lifting” the reference capability of the result wouldn’t be safe. Some of those values could “leak” into an iso or val result, and result in data races.\nAutomatic receiver recovery When you have an iso or trn receiver, you normally can’t call ref methods on it. That’s because the receiver is also an argument to a method, which means both the method body and the caller have access to the receiver at the same time. And that means we have to alias the receiver when we call a method on it. The alias of an iso is a tag (which isn’t a subtype of ref) and the alias of a trn is a box (also not a subtype of ref).\nBut we can get around this! If all the arguments to the method (other than the receiver, which is the implicit argument being recovered) at the call-site are sendable, and the return type of the method is either sendable or isn’t used at the call-site, then we can “automatically recover” the receiver. That just means we don’t have to alias the receiver - and that means we can call ref methods on an iso or trn, since iso and trn are both subtypes of ref.\nNotice that this technique looks mostly at the call-site, rather than at the definition of the method being called. That makes it more flexible. For example, if the method being called wants a ref argument, and we pass it an iso argument, that’s sendable at the call-site, so we can still do automatic receiver recovery.\nThis may sound a little complicated, but in practice, it means you can write code that treats an iso mostly like a ref, and the compiler will complain when it’s wrong. For example:\nlet s = recover String end s.append(\"hi\") Here, we create a String iso and then append some text to it. The append method takes a ref receiver and a box parameter. We can automatically recover the iso receiver since we pass a val parameter, so everything is fine.\n","summary":"A recover expression lets you “lift” the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.\nWhy is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:","title":"权能借用（Recovering Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html"},{"content":"Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.\nSimple substitution First, let’s cover substitution without worrying about ephemeral types (^) or alias types (!). The \u003c: symbol means “is a subtype of” or alternatively “can be substituted for”.\n iso \u003c: trn. An iso is read and write unique, and a trn is just write unique, so it’s safe to substitute an iso for a trn. trn \u003c: ref. A trn is mutable and also write unique. A ref is mutable but makes no uniqueness guarantees. It’s safe to substitute a trn for a ref. trn \u003c: val. This one is interesting. A trn is write unique and a val is globally immutable, so why is it safe to substitute a trn for a val? The key is that, in order to do so, you have to give up the trn you have. If you give up the only variable that can write to an object, you know that no variable can write to it. That means it’s safe to consider it globally immutable. ref \u003c: box. A ref guarantees no other actor can read from or write to the object. A box just guarantees no other actor can write to the object, so it’s safe to substitute a ref for a box. val \u003c: box. A val guarantees no actor, not even this one, can write to the object. A box just guarantees no other actor can write to the object, so it’s safe to substitute a val for a box. box \u003c: tag. A box guarantees no other actor can write to the object, and a tag makes no guarantees at all, so it’s safe to substitute a box for a tag.  Subtyping is transitive. That means that since iso \u003c: trn and trn \u003c: ref and ref \u003c: box, we also get iso \u003c: box.\nAliased substitution Now let’s consider what happens when we have an alias of a reference capability. For example, if we have some iso and we alias it (without doing a consume or a destructive read), the type we get is iso!, not iso.\n iso! \u003c: tag. This is a pretty big change. Instead of being a subtype of everything like iso, the only thing an iso! is a subtype of is tag. This is because the iso still exists, and is still read and write unique. Any alias can neither read from nor write to the object. That means an iso! can only be a subtype of tag. trn! \u003c: box. This is a change too, but not as big a change. Since trn is only write unique, it’s ok for aliases to read from the object, but it’s not ok for aliases to write to the object. That means we could have box or val aliases - except val guarantees that no alias can write to the object! Since our trn still exists and can write to the object, a val alias would break the guarantees that val makes. So a trn! can only be a subtype of box (and, transitively, tag as well). ref! \u003c: ref. Since a ref only guarantees that other actors can neither read from nor write to the object, it’s ok to make more ref aliases within the same actor. val! \u003c: val. Since a val only guarantees that no actor can write to the object, its ok to make more val aliases since they can’t write to the object either. box! \u003c: box. A box only guarantees that other actors can’t write to the object. Both val and ref make that guarantee too, so why can box only alias as box? It’s because we can’t make more guarantees when we alias something. That means box can only alias as box. tag! \u003c: tag. A tag doesn’t make any guarantees at all. Just like with a box, we can’t make more guarantees when we make a new alias, so a tag can only alias as a tag.  Ephemeral substitution The last case to consider is when we have an ephemeral reference capability. For example, if we have some iso and we consume it or do a destructive read, the type we get is iso^, not iso.\n iso^ \u003c: iso. This is pretty simple. When we give an iso^ a name, by assigning it to something or passing it as an argument to a method, it loses the ^ and becomes a plain old iso. We know we gave up our previous iso, so it’s safe to have a new one. trn^ \u003c: trn. This works exactly like iso^. The guarantee is weaker (write uniqueness instead of read and write uniqueness), but it works the same way. ref^ \u003c: ref^ and ref^ \u003c: ref and ref \u003c: ref^. Here, we have another case. Not only is a ref^ a subtype of a ref, it’s also a subtype of a ref^. What’s going on here? The reason is that an ephemeral reference capability is a way of saying “a reference capability that, when aliased, results in the base reference capability”. Since a ref can be aliased as a ref, that means ref and ref^ are completely interchangeable. val^, box^, tag^. These all work the same way as ref, that is, they are interchangeable with the base reference capability. It’s for the same reason: all of these reference capabilities can be aliased as themselves.  Why do ref^, val^, box^, and tag^ exist if they are interchangeable with their base reference capabilities? It’s for two reasons: reference capability recovery and generics. We’ll cover both of those later.\n","summary":"Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.\nSimple substitution First, let’s cover substitution without worrying about ephemeral types (^) or alias types (!). The \u003c: symbol means “is a subtype of” or alternatively “can be substituted for”.\n iso \u003c: trn. An iso is read and write unique, and a trn is just write unique, so it’s safe to substitute an iso for a trn.","title":"权能包含关系（Capability Subtyping）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html"},{"content":"When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.\nThis is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.\nViewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation. That is, the origin has a viewpoint, and can “see” its fields only from that viewpoint.\nLet’s start with a table. This shows how fields of each capability “look” to origins of each capability.\n    ▷ iso field trn field ref field val field box field tag field     iso origin iso tag tag val tag tag   trn origin iso trn box val box tag   ref origin iso trn ref val box tag   val origin val val val val val tag   box origin tag box box val box tag   tag origin n/a n/a n/a n/a n/a n/a     For example, if you have a trn origin and you read a ref field, you get a box result:\nclass Foo var x: String ref class Bar fun f() =\u003e var y: Foo trn = get_foo_trn() var z: String box = y.x Explaining why That table will seem totally natural to you, eventually. But probably not yet. To help it seem natural, let’s walk through each cell in the table and explain why it is the way it is.\nReading from an iso variable Anything read through an iso origin has to maintain the isolation guarantee that the origin has. The key thing to remember is that the iso can be sent to another actor and it can also become any other reference capability. So when we read a field, we need to get a result that won’t ever break the isolation guarantees that the origin makes, that is, read and write uniqueness.\nAn iso field makes the same guarantees as an iso origin, so that’s fine to read. A val field is globally immutable, which means it’s always ok to read it, no matter what the origin is (well, other than tag).\nEverything else, though, can break our isolation guarantees. That’s why other reference capabilities are seen as tag: it’s the only type that is neither readable nor writable.\nReading from a trn variable This is like iso, but with a weaker guarantee (write uniqueness as opposed to read and write uniqueness). That makes a big difference since now we can return something readable when we enforce our guarantees.\nAn iso field makes stronger guarantees than a trn origin, and a trn field makes the same guarantees, so they’re fine to read. A val field is globally immutable, so that’s fine too. A box field is readable, and we only guarantee write uniqueness, so that’s fine too.\nA ref field, though, would allow writing. So instead we return a box.\nReading from a ref variable A ref origin doesn’t modify its fields at all. This is because a ref origin doesn’t make any guarantees that are incompatible with its fields.\nReading from a val variable A val origin is deeply and globally immutable, so all of its fields are also val. The only exception is a tag field. Since we can’t read from it, we also can’t guarantee that nobody can write to it, so it stays tag.\nReading from a box variable A box variable is locally immutable. This means it’s possible that it may be mutated through some other variable (a trn or a ref), but it’s also possible that our box variable is an alias of some val variable.\nWhen we read a field, we need to return a reference capability that is compatible with the field but is also locally immutable.\nAn iso field is returned as a tag because no locally immutable reference capability can maintain its isolation guarantees. A val field is returned as a val because global immutability is a stronger guarantee than local immutability. A box field makes the same local immutability guarantee as its origin, so that’s also fine.\nFor trn and ref we need to return a locally immutable reference capability that doesn’t violate any guarantees the field makes. In both cases, we can return box.\nReading from a tag variable This one is easy: tag variables are opaque! They can’t be read from.\nWriting to the field of an object Like reading the field of an object, writing to a field depends on the reference capability of the object reference being stored and the reference capability of the origin object containing the field. The reference capability of the object being stored must not violate the guarantees made by the origin object’s reference capability. For example, a val object reference can be stored in an iso origin. This is because the val reference capability guarantees that no alias to that object exists which could violate the guarantees that the iso capability makes.\nHere’s a simplified version of the table above that shows which reference capabilities can be stored in the field of an origin object.\n    ◁ iso object trn object ref object val object box object tag object     iso origin ✔   ✔  ✔   trn origin ✔ ✔  ✔  ✔   ref origin ✔ ✔ ✔ ✔ ✔ ✔   val origin         box origin         tag origin           The bottom half of this chart is empty, since only origins with a mutable capability can have their fields modified.\n","summary":"When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.\nThis is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.\nViewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation.","title":"权能合并（Combining Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html"},{"content":"柯里化（Partial Application）允许我们对构造函数、函数或行为设置 部分 参数，然后返回一个新函数，以便后面再填充其余的参数。\n一个简单的例子 这里有一个简单的例子，创建一个回调函数。例如:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) 这是一个有点傻的示例，但希望，思路是清楚的。我们在foo上柯里化了addmul函数，把接收者绑定到foo上，把add参数绑定为3。我们得到一个返回值它是一个匿名对象：f，它有一个apply方法，接受一个mul参数。当它被调用时，它执行foo.addmul (3,mul)。\n我们也可以绑定所有的参数：\nlet f = foo~addmul(3, 4) f() 也不提绑定任何实参：\nlet f = foo~addmul() f(3, 4) 命名传参（之前讲过的无序传参方式） 命名传参的方式允许柯里化（Partial Application）以任意顺序绑定参数，而不只是从左到右。例如:\nlet f = foo~addmul(where mul = 4) f(3) 在这里，我们绑定了mul参数，但未绑定add。\n对柯里化函数进行柯里化（Partially applying a partial application） 由于柯里化（Partial Application）会返回一个一个带有apply方法的匿名对象，所以我们对它的返回值再次进行柯里化！\nlet f = foo~addmul() let f2 = f~apply(where mul = 4) f2(3) 柯里化的返回值是一个匿名对象（Partial application is an object literal） 底层实现上，柯里化（Partial Application）会自动封装为一个匿名对象。它捕获从作用域中捕获字段，并有一个apply方法，该方法接受一些参数。这一切都是是在编译阶段，将柯里化的抽象语法树翻译为匿名对象来实现的。\n这意味着柯里化（Partial Application）将生成一个匿名类并返回一个ref权限的匿名对象。如果你需要其他引用权能，可以将柯里化（Partial Application）封装在一个recover表达式中。\n","summary":"柯里化（Partial Application）允许我们对构造函数、函数或行为设置 部分 参数，然后返回一个新函数，以便后面再填充其余的参数。\n一个简单的例子 这里有一个简单的例子，创建一个回调函数。例如:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) 这是一个有点傻的示例，但希望，思路是清楚的。我们在foo上柯里化了addmul函数，把接收者绑定到foo上，把add参数绑定为3。我们得到一个返回值它是一个匿名对象：f，它有一个apply方法，接受一个mul参数。当它被调用时，它执行foo.addmul (3,mul)。\n我们也可以绑定所有的参数：\nlet f = foo~addmul(3, 4) f() 也不提绑定任何实参：\nlet f = foo~addmul() f(3, 4) 命名传参（之前讲过的无序传参方式） 命名传参的方式允许柯里化（Partial Application）以任意顺序绑定参数，而不只是从左到右。例如:\nlet f = foo~addmul(where mul = 4) f(3) 在这里，我们绑定了mul参数，但未绑定add。","title":"柯里化（Partial Application）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/partial-application.html"},{"content":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them. All Pony source files have an implicit use \"builtin\" command. This means all the types defined in the package builtin are automatically available in the type namespace of all Pony source files.\nDocumentation for the standard library is available online\n","summary":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them.","title":"标准库（Standard Library）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/standard-library.html"},{"content":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, ! and much more.\n","summary":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, !","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/appendices.html"},{"content":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features. Calling well written, bug-free, C code will have no ill effects on your program. However, calling buggy or malicious C code or calling C incorrectly can cause your Pony program to go wrong, including corrupting data and crashing. Consequently, all of the Pony guarantees regarding not crashing, memory safety and concurrent correctness can be voided by calling FFI functions.\n","summary":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi.html"},{"content":"本章介绍Pony语言的各种表达方式。从变量到流程控制等内容。\n","summary":"本章介绍Pony语言的各种表达方式。从变量到流程控制等内容。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions.html"},{"content":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters. The parameters for a generic class are types. Parameters are introduced to a class using square brackets.\nTake the following example of a non-generic class:\nclass Foo var _c: U32 new create(c: U32) =\u003e _c = c fun get(): U32 =\u003e _c fun ref set(c: U32) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) This class only works for the type U32, a 32 bit unsigned integer. We can make this work over other types by making the type a parameter to the class. For this example it looks like:\nclass Foo[A: Any val] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) let b = Foo[F32](1.5) env.out.print(b.get().string()) let c = Foo[String](\"Hello\") env.out.print(c.get().string()) The first thing to note here is that the Foo class now takes a type parameter in square brackets, [A: Any val]. That syntax for the type parameter is:\nName: Constraint ReferenceCapability  In this case, the name is A, the constraint is Any and the reference capability is val. Any is used to mean that the type can be any type - it is not constrained. The remainder of the class definition replaces U32 with the type name A.\nThe user of the class must provide a type when referencing the class name. This is done when creating it:\nlet a = Foo[U32](42) let b = Foo[F32](1.5) let c = Foo[String](\"Hello\") That tells the compiler what specific class to create, replacing A with the type provided. For example, a Foo[String] usage becomes equivalent to:\nclass FooString var _c: String val new create(c: String val) =\u003e _c = c fun get(): String val =\u003e _c fun ref set(c: String val) =\u003e _c = c Generic Methods Methods can be generic too. They are defined in the same way as normal methods but have type parameters inside square brackets after the method name:\nprimitive Foo fun bar[A: Stringable val](a: A): String =\u003e a.string() actor Main new create(env:Env) =\u003e let a = Foo.bar[U32](10) env.out.print(a.string()) let b = Foo.bar[String](\"Hello\") env.out.print(b.string()) This example shows a constraint other than Any. The Stringable type is any type with a string() method to convert to a String.\nThese examples show the basic idea behind generics and how to use them. Real world usage gets quite a bit more complex and the following sections will dive deeper into how to use them.\n","summary":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/generics.html"},{"content":"本章将带你开始使用Pony，安装编译器运行第一个程序。\n在本教程的学习过程中，你可能会遇到已经熟悉的概念，想跳过这些章节完全没问题。\n不过，如果你第一次接触Pony肯定会遇到陌生的概念，如果想使用Pony，你需要特别！特别！！注意：引用权能章节。引用权能 是Pony的核心，凭借着特立独行的思想使Pony在现代编程语言的中脱颖而出。\n在本教程从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其介绍。阅读过程中，强烈建议你将教程中的代码在自己的编辑器中敲一遍。注意，当你冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全文，得先彻底理解 引用权能 。学习过程中配合编译器一起使用，可以验证教程中代码示例，加深理解。\n或许你正急着阅读后面的章节，稍微花点时间读完入门章节，了解下社区为你提供了哪些帮助，可以少走一些弯路。学习Pony会改变你对并发问题的看法。\n","summary":"本章将带你开始使用Pony，安装编译器运行第一个程序。\n在本教程的学习过程中，你可能会遇到已经熟悉的概念，想跳过这些章节完全没问题。\n不过，如果你第一次接触Pony肯定会遇到陌生的概念，如果想使用Pony，你需要特别！特别！！注意：引用权能章节。引用权能 是Pony的核心，凭借着特立独行的思想使Pony在现代编程语言的中脱颖而出。\n在本教程从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其介绍。阅读过程中，强烈建议你将教程中的代码在自己的编辑器中敲一遍。注意，当你冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全文，得先彻底理解 引用权能 。学习过程中配合编译器一起使用，可以验证教程中代码示例，加深理解。\n或许你正急着阅读后面的章节，稍微花点时间读完入门章节，了解下社区为你提供了哪些帮助，可以少走一些弯路。学习Pony会改变你对并发问题的看法。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started.html"},{"content":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results. Probably the best way to approach this chapter is to imagine each section has a giant flashing “DO NOT DO THIS” sign.\n","summary":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas.html"},{"content":"If you are reading this tutorial in order, you’ve just finished the reference capabilities chapter and your brain probably hurts. We’re sorry about that. Hopefully object capabilities, while a new concept, are less mind bending.\nWe touched on object capabilities previously in the tutorial, this chapter will dig in more. So, what is an object capability?\nA capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network. This is called an object capability. Object capabilities have appeared in a number of programming languages including E.\n","summary":"If you are reading this tutorial in order, you’ve just finished the reference capabilities chapter and your brain probably hurts. We’re sorry about that. Hopefully object capabilities, while a new concept, are less mind bending.\nWe touched on object capabilities previously in the tutorial, this chapter will dig in more. So, what is an object capability?\nA capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities.html"},{"content":"","summary":"","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/packages.html"},{"content":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.\n","summary":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching.html"},{"content":"We’ve covered the basics of Pony’s type system and then expressions, this chapter about reference capabilities will cover another feature of Pony’s type system. There aren’t currently any mainstream programming languages that feature reference capabilities. What is a reference capability?\nWell, a reference capability is built on the idea of “a capability”. A capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network. This usage of capability is called an object capability and is discussed in the next chapter.\nPony also features a different kind of capability, called a “reference capability”. Where object capabilities are about being granted the ability to do things with objects, reference capabilities are about denying you the ability to do things with memory references. For example, “you can have access to this memory BUT ONLY for reading it. You can not write to it”. That’s a reference capability and it’s denying you access to do things.\nReference capabilities are core to what makes Pony special. You might remember in the introduction to this tutorial what we said about Pony:\n It’s type safe. Really type safe. There’s a mathematical proof and everything. It’s memory safe. Ok, this comes with type safe, but it’s still interesting. There are no dangling pointers, no buffer overruns, heck, the language doesn’t even have the concept of null! It’s exception safe. There are no runtime exceptions. All exceptions have defined semantics, and they are always handled. It’s data-race-free. Pony doesn’t have locks or atomic operations or anything like that. Instead, the type system ensures at compile time that your concurrent program can never have data races. So you can write highly concurrent code and never get it wrong. It’s deadlock free. This one is easy because Pony has no locks at all! So they definitely don’t deadlock, because they don’t exist.  Reference capabilities are what make all that awesome possible.\nCode examples in this chapter might be kind of sparse, because we’re largely dealing with higher-level concepts. Try to read through the chapter at least once before starting to put the ideas into practice. By the time you finish this chapter, you should start to have a handle on what reference capabilities are and how you can use them. Don’t worry if you struggle with them at first. For most people, it’s a new way of thinking about your code and takes a while to grasp. If you get stuck trying to get your capabilities right, definitely reach out for help. Once you’ve used them for a couple weeks, problems with capabilities start to melt away, but before that can be a real struggle. Don’t worry, we all went through that struggle. In fact, there’s a section of the Pony website dedicated to resources that can help in learning reference capabilities. And by all means, reach out to the Pony community for help. We are here to help you get over the reference capabilities learning curve. It’s not easy. We know that. It’s a new way of thinking for folks, so do please reach out. We’re waiting to hear from you.\nScared? Don’t be. Ready? Good. Let’s get started.\n","summary":"We’ve covered the basics of Pony’s type system and then expressions, this chapter about reference capabilities will cover another feature of Pony’s type system. There aren’t currently any mainstream programming languages that feature reference capabilities. What is a reference capability?\nWell, a reference capability is built on the idea of “a capability”. A capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities.html"},{"content":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.\n","summary":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/testing.html"},{"content":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。\n","summary":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/types.html"},{"content":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony. In particular, materials to help you grapple with reference capabilities.\n“Learn” on Ponylang.io\nPlanet Pony We don’t have an automatic blog aggregator but wish we did. In the meantime, we have a hand-curated list of videos, blog posts etc that would be of interest to members of the Pony community. Just beware when you are checking out older posts, it’s quite possible that their examples no longer compile as Pony development is currently moving very quickly.\nPlanet Pony\nPony Patterns Pony Patterns\n标准库文档 标准库文档\nPonylang Zulip Pony Zulip\nPony Virtual Users’ Group The Pony Virtual Users’ Group has occassional presentations that you can attend “in person” or catch later via the recorded video. Join our Zulip community to stay up to date on upcoming meetings. All the previous videos are available via Sean T Allen’s Vimeo account.\nA final word We’re immensely happy that you have taken the time to start learning Pony. It’s still a new and immature language with plenty of sharp pointy edges. You are going to get frustrated at times. Don’t worry, it has happened to all of us. Drop by one of our support channels and someone will try to lend a hand. We want you to succeed. The more people who succeed with Pony, the more the community grows and the better it is for all of us.\nWelcome to the community! Have fun!\n","summary":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/where-next.html"},{"content":"Pony有两种形式的平等:结构平等和身份平等。\n类型比较（Identity equality） Pony中的类型检查是通过is关键字来完成的。is可以判断两个类型是否相同。\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP! TRUE! end 结构化比较（Structural equality） Pony的结构化比较是通过中缀运算符==来完成的。它可以判断同的数据是否具有相同的值。如果被比较结果为true，可以认为它们具有相同的值。\n可以通过实现fun eq(that: box-\u003eFoo): Bool来自定义对比逻辑。注意，因为==是一个中缀操作符，eq必须定义在左边的操作数上，而右边的操作数必须是Foo类型。\nclass Foo let _a: String new create(a: String) =\u003e _a = a fun eq(that: box-\u003eFoo): Bool =\u003e this._a == that._a actor Main new create(e: Env) =\u003e let a = Foo(\"hi\") let b = Foo(\"bye\") let c = Foo(\"hi\") if a == b then // won't print e.out.print(\"1\") end if a == c then // will print e.out.print(\"2\") end if a is c then // won't print e.out.print(\"3\") end 如果没有定义自己的eq，Pony将会提供一个默认实现，该实现只是简单的对比类型是否相同。\ninterface Equatable[A: Equatable[A] #read] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) 基元类的类型比较（Primitives and equality） 你可能还记得在第二章：基元类中讲过，除了两个重要的区别之外，基元类与类有两个重要区别:\n 基元类没有字段。 所有用户自定义的基元类只会有一个实例。  这意味着，同类型的基元类实例在结构上总是相等的，并且是完全相等。例如，所有的None都是同一个实例。\nif None is None then // this is always true end if None == None then // this is also always true end ","summary":"Pony有两种形式的平等:结构平等和身份平等。\n类型比较（Identity equality） Pony中的类型检查是通过is关键字来完成的。is可以判断两个类型是否相同。\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP! TRUE! end 结构化比较（Structural equality） Pony的结构化比较是通过中缀运算符==来完成的。它可以判断同的数据是否具有相同的值。如果被比较结果为true，可以认为它们具有相同的值。\n可以通过实现fun eq(that: box-\u003eFoo): Bool来自定义对比逻辑。注意，因为==是一个中缀操作符，eq必须定义在左边的操作数上，而右边的操作数必须是Foo类型。\nclass Foo let _a: String new create(a: String) =\u003e _a = a fun eq(that: box-\u003eFoo): Bool =\u003e this.","title":"比较（Equality in Pony）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/equality.html"},{"content":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:\n// Note - this won't compile class Foo[A] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) Unfortunately, this doesn’t compile. For a generic class to compile it must be compilable for all possible types and reference capabilities that satisfy the constraints in the type parameter. In this case, that’s any type with any reference capability. The class works for the specific reference capability of val as we saw earlier, but how well does it work for ref? Let’s expand it and see:\n// Note - this also won't compile class Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): String ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) This does not compile. The compiler complains that get() doesn’t actually return a String ref, but this-\u003eString ref. We obviously need to simply change the type signature to fix this, but what is going on here? this-\u003eString ref is an arrow type. An arrow type with “this-\u003e” states to use the capability of the actual receiver (ref in our case), not the capability of the method (which defaults to box here). According to viewpoint adaption this will be ref-\u003eref which is ref. Without this arrow type we would only see the field _c as box because we are in a box method.\nSo let’s apply what we just learned:\nclass Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): this-\u003eString ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) That compiles and runs, so ref is valid now. The real test though is iso. Let’s convert the class to iso and walk through what is needed to get it to compile. We’ll then revisit our generic class to get it working:\nAn iso specific class // Note - this won't compile class Foo var _c: String iso new create(c: String iso) =\u003e _c = c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) This fails to compile. The first error is:\nmain.pony:5:8: right side must be a subtype of left side _c = c ^ Info: main.pony:4:17: String iso! is not a subtype of String iso: iso! is not a subtype of iso new create(c: String iso) =\u003e ^ The error is telling us that we are aliasing the String iso - The ! in iso! means it is an alias of an existing iso. Looking at the code shows the problem:\nnew create(c: String iso) =\u003e _c = c We have c as an iso and are trying to assign it to _c. This creates two aliases to the same object, something that iso does not allow. To fix it for the iso case we have to consume the parameter. The correct constructor should be:\nnew create(c: String iso) =\u003e _c = consume c A similar issue exists with the set method. Here we also need to consume the variable c that is passed in:\nfun set(c: String iso) =\u003e _c = consume c Now we have a version of Foo that is working correctly for iso. Note how applying the arrow type to the get method also works for iso. But here the result is a different one, by applying viewpoint adaptation we get from ref-\u003eiso (with ref being the capability of the receiver, the Foo object referenced by a) to iso. Through the magic of automatic receiver recovery we can call the string method on it:\nclass Foo var _c: String iso new create(c: String iso) =\u003e _c = consume c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) A capability generic class Now that we have iso working we know how to write a generic class that works for iso and it will work for other capabilities too:\nclass Foo[A] var _c: A new create(c: A) =\u003e _c = consume c fun get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo[String iso](\"Hello\".clone()) env.out.print(a.get().string()) let b = Foo[String ref](recover ref \"World\".clone() end) env.out.print(b.get().string()) let c = Foo[U8](42) env.out.print(c.get().string()) It’s quite a bit of work to get a generic class or method to work across all capability types, in particular for iso. There are ways of restricting the generic to subsets of capabilities and that’s the topic of the next section.\n","summary":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:","title":"泛型和引用权能（Generics and Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generics-and-reference-capabilities.html"},{"content":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic. The valid qualifiers are:\n   ▷ Capabilities allowed Description     #read ref, val, box Anything you can read from   #send iso, val, tag Anything you can send to an actor   #share val, tag Anything you can send to more than one actor   #any iso, trn, ref, val, box, tag Default of a constraint   #alias ref, val, box, tag Set of capabilities that alias as themselves (used by compiler)    In the previous section, we went through extra work to support iso. If there’s no requirement for iso support we can use #read and support ref, val, and box:\nclass Foo[A: Any #read] var _c: A new create(c: A) =\u003e _c = c fun ref get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[String ref](recover ref \"hello\".clone() end) env.out.print(a.get().string()) let b = Foo[String val](\"World\") env.out.print(b.get().string()) ","summary":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic.","title":"泛型约束（Constraints）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generic-constraints.html"},{"content":"在程序开发过程中，你需要能够对条件做出判断，对集合进行遍历，或者重复执行一些逻辑。因此，流程控制必不可少。Pony具有你在其他语言中所熟悉的流程控制控制，例如if，while和for，但是在Pony中，它们的工作方式略有不同。\n条件判断（Conditionals） if是最简单的流程控制控制。它仅在条件为真时才允许您执行某些操作。在Pony中的用法：\nif a \u003e b then env.out.print(\"a is bigger\") end 可以像在C语言中那样使用整数和指针作为条件吗？ 不行。在Pony中，if条件必须是布尔类型，即条件的返回值值始终为true或false。如果要判断数字a是否不为0，则需要明确的使用a！= 0。这个限制让Pony程序避免了潜在的类型错误。\n需要在条件失败时的执行一些逻辑，只需添加一个else：\nif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"a is not bigger\") end 通常，您想要检测和处理多种条件，可以嵌套if语句，但这有点丑陋：\nif a == b then env.out.print(\"they are the same\") else if a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end end 作为替代方案，Pony提供了结合了else和if的elseif关键字。这与其他语言中else if相同，并且每个if可以有任意数量的elseif：\nif a == b then env.out.print(\"they are the same\") elseif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end 为什么不能像在C语言中那样用else if？为什么要用新的关键字？ C和其他类似语言中的if和else之间的关系是模棱两可的。例如：\n// C code if(a) if(b) printf(\"a and b\\n\"); else printf(\"not a\\n\"); 上面的示例中，else到底归属于第一个还是第二个if有点让人困惑。实际上，else归属与if(b)，显然示例里面else语句本意是想归属于if(a)。Pony通过以不同的方式处理if和else来避免此类错误，那就是elseif。\n一切皆表达式（Everything is an expression） Pony的流程控制与其他语言的最大区别在于，在Pony中，一切都是表达式。在C++和Java这样的语言中，if是语句，而不是表达式。这意味着您不能在表达式中包含if，而必须有一个单独的条件运算符？（三目运算符 a ? b : c）。\n在Pony中，不存在语句的概念，只有表达式，所有东西都有返回一个值。if表达式是一个求值过程。for循环表达式也（稍后再讨论）也是如此。\n这意味着您可以在计算中直接使用if：\nx = 1 + if lots then 100 else 2 end 通过变量 lots ，为 x 赋值为3或101。\n如果if的then和else分支产生不同的类型，则if返回两者的 联合类型（union） 。\nvar x: (String | Bool) = if friendly then \"Hello\" else false end 但是if表达式没有else呢？ 任何不存在的else分支都会默认返回None（None是基元类的实例）。\nvar x: (String | None) = if friendly then \"Hello\" end if表达式的规则也适用于循环。我们看一下Pony的循环是什么样的：\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end x 会被赋值为Sarah，它是循环列表中的最后一个元素。如果循环直接跳出了（0次迭代），那么__x__ 的值就是else表达式的返回值。如果没有else块，则该值为None。\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name else \"no names!\" end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end _x 的值在这里是\"no names!\"。\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end 最后，x 的值是None。\nLoops表达式（Loops） if允许您选择要执行的操作，但是不止一次想要循环就可以执行其他操作。\nWhile表达式（While） Pony的while循环与其他语言非常相似。条件表达式将被求值，如果为真，将执行一次循环内的代码，完成后，我们将再次评估条件，并继续进行直到条件不成立为止。\n这是一个打印数字1到10的示例：\nvar count: U32 = 1 while count \u003c= 10 do env.out.print(count.string()) count = count + 1 end 就像if表达式，while也是表达式一样。返回值是最后循环执行时的表达式返回值。在这个例子中，当count递增到11时，也就是count = count + 1的返回值值。Pony会将最后一次正确执行循环的 旧值（old） 返回，最终while循环将返回10。\n但是如果while在第一次判断就为假，那不久就不会执行循环吗？ 在Pony中，while表达式也可以有一个else块，在没有提供else表达式时，Pony的else块会提供一个默认值None。注意：只有在第一次评估就为false时（也就是while循环体没机会执行时），才会返回else表达式的值。\n所以这就像Python中while循环中的else块吗？ 这是非常不同的。在Python中，else在while完成时运行。在Pony中，else仅在while没有机会运行时才执行。\n中止循环（Break） 有时，您希望在循环中途停止并跳出。 Pony为此使用了关键字break，它与C ++，C＃和Python等语言中的关键字非常相似。\nbreak会立即从它所在的最里面的循环中退出。由于循环必须返回一个值，break可以采用一个表达式。这是可选的，如果错过了，则返回else块中的值。\n让我们举个例子。假设您要浏览从某处获取的名称列表，查找Jack或Jill。如果这两个都没有出现，则只使用您的姓氏，如果根本不使用任何名字，则使用Herbert。\nvar name = while moreNames() do var name' = getName() if name' == \"Jack\" or name' == \"Jill\" then break name' end name' else \"Herbert\" end 因此，首先我们要询问是否还有其他名字。如果有的话，我们得到这个名字，看看它是Jack还是Jill，如果符合条件，将跳出循环，将找到的名字递回。如果没有，我们再试一次。\nname行出现在循环的末尾，因此如果找不到Jack或Jill，返回值最后一次迭代的名字。\n如果一开始就发现根本没有可用名，则返回else块提供的Herbert值。\n可以从多层嵌套的循环中直接跳出吗？就像Java的break那样 没有，Pony不支持。这是糟糕的逻辑表达方式，当你遇到需要从多层嵌套循环中直接跳出的情况，你应该重构你的代码或使用辅助函数。\nContinue表达式 有时，您希望在一次循环迭代中中途停止，然后进行下一次循环。像其他语言一样，Pony为此使用了continue关键字。\ncontinue将停止执行它所在的最内层循环的当前迭代，并评估条件以准备进行下一次迭代。\n如果在循环的最后一次迭代中continue被触发了，那么我们循环就不会有返回值。在这种情况下，将返回else表达式的值。与if表达式一样，如果未提供else表达式，则返回None。\nPony的continue可以直接跳到一个外部嵌套循环中继续执行吗？就像Java的continue。 不行，Pony不支持。如果需要跳转到外层循环继续执行，说明你的逻辑应该重构了。\nFor表达式 在Pony中需要便利集合，可以使用for表达式。当与集合一起使用时，这非常类似于C＃中的foreach，Python中的for..in和Java中的for。它与C和C++中的for非常不同。\nPony的for循环使用迭代器遍历集合。在每次迭代中，都会询问迭代器是否还有要处理的元素。\n例如，打印出数组中的所有字符串：\nfor name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do env.out.print(name) end 注意在数组上调用values()，是因为循环需一个迭代器。\n迭代器没有特定的类型需求，但需要提供以下接口方法：\nfun has_next(): Bool fun next(): T? 其中T是集合中对象的类型。除非您需要编写自己的迭代器，否则无需担心。要使用现有的集合（例如标准库中提供的集合），您只需使用for即可。如果你编写了自己的迭代器，请使用结构化多态的方式满足接口需求，你的迭代器无需特定的类型声明。\n您可以认为上述示例等效于：\nlet iterator = [\"Bob\"; \"Fred\"; \"Sarah\"].values() while iterator.has_next() do let name = iterator.next()? env.out.print(name) end 请注意，变量 name 使用 let 声明，所以不能在循环内为其重新赋值。\n我可以使用break并继续使用for循环吗？ 可以的，for循环可以附加else表达式，并且可以像while一样使用break和continue。\n重复执行表达式（Repeat） Pony提供的最后一个循环表达式是repeat``until。在这里，我们评估循环中的表达式，然后评估条件表达式，看看是否完成或应该再次处理。\n这与C++，C＃和Java中的do``while类似，不同之处在于终止条件是相反的，即那些语言在条件表达式为false时终止循环，而Pony在条件表达式为true时终止循环。\nPony中的while和repeat的区别是：\n repeat表达式至少会执行一次，而使用while则可能一次都不执行。 结束条件相反。  加入我们正在尝试执行一些逻辑，并且想不断重复直到满足条件为止：\nactor Main new create(env: Env) =\u003e var counter = U64(1) repeat env.out.print(\"hello!\") counter = counter + 1 until counter \u003e 7 end 就像while循环一样，repeat循环返回的值就是上一次迭代时循环内表达式的值，并且可以使用break和continue。\n由于至少要执行一次重复循环，还有必要给它提供一个else表达式吗？ 是的，您可能需要这样做。 如果repeat循环的最后一次迭代中触发了continue那就需要从某个地方获取一个值，这就需要使用else表达式。\n","summary":"在程序开发过程中，你需要能够对条件做出判断，对集合进行遍历，或者重复执行一些逻辑。因此，流程控制必不可少。Pony具有你在其他语言中所熟悉的流程控制控制，例如if，while和for，但是在Pony中，它们的工作方式略有不同。\n条件判断（Conditionals） if是最简单的流程控制控制。它仅在条件为真时才允许您执行某些操作。在Pony中的用法：\nif a \u003e b then env.out.print(\"a is bigger\") end 可以像在C语言中那样使用整数和指针作为条件吗？ 不行。在Pony中，if条件必须是布尔类型，即条件的返回值值始终为true或false。如果要判断数字a是否不为0，则需要明确的使用a！= 0。这个限制让Pony程序避免了潜在的类型错误。\n需要在条件失败时的执行一些逻辑，只需添加一个else：\nif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"a is not bigger\") end 通常，您想要检测和处理多种条件，可以嵌套if语句，但这有点丑陋：\nif a == b then env.out.print(\"they are the same\") else if a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end end 作为替代方案，Pony提供了结合了else和if的elseif关键字。这与其他语言中else if相同，并且每个if可以有任意数量的elseif：\nif a == b then env.out.print(\"they are the same\") elseif a \u003e b then env.","title":"流程控制（Control Structures）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/control-structures.html"},{"content":"与其他面向对象的语言一样，Pony具有 多态性（subtyping） 。也就是说，某些类型充当 categories ，其他类型可以成为其成员。\n编程语言的实现上有两种 多态（subtyping） 类型： 声明式（nominal）多态 和 结构化（structural）多态 。它们有细微的不同，大多数编程语言只会选择一种实现。但是Pony两种都实现了！\n声明式多态（Nominal subtyping） 这种多态的实现被称为 声明式 ，因为它需要你明确指出你要实现的 类型名 。\n如果你有过面向对象编程经验，你应该熟悉 继承（单） 、 多重继承 、 组合 、 特征 或类似的概念，所有的这些都属于 声明式多态\n核心思想是您有一个声明与某种类别类型有关系的类型。例如，在Java中，类（具体类型）可以实现某个接口（抽象类型）。在Java中，这表示这个类必须要实现指定抽象接口。编译器将检查该类是否实现了此抽象类型需要的所有接口。\nPony的特征（Traits）：声明式多态（Nominal subtyping） Pony使用 特征（trait） 来实现声明式多态。trait 的定义看上去有点像 class ，但是它使用关键字trait，并且不能有任何字段。\ntrait Named fun name(): String =\u003e \"Bob\" class Bob is Named 上面代码中，我们定义了一个名为Named的特征，他又一个名为name()的成员函数，返回类型是字符串。它还提供了name()函数的默认实现，返回字符串\"Bob”。\n接着定义了类名为Bob的类。Bob在明确的声明自己实现了Named特征。在Pony中，我们把这成为 Bob拥有Named特征 ，或者说 Bob就是Named 。\n我们看到Bob并没有定义name()函数，所以它会使用特征中的默认实现。如果特征对name()函数没有做出默认实现，则编译器就会报一个错告知：Bob没有实现name()。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald fun hair(): Bool =\u003e false class Bob is (Named \u0026 Bald) 一个类可以同时具备多个特征。在上面的示例中，Bob类同时提供了Named和Bald特征。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald is Named fun hair(): Bool =\u003e false class Bob is Bald 特征是支持组合的。在上面的示例中，所有Bald特征类被声明为包含Named特征。因此，Bob类可以访问两个特征类中的hair()和name()函数的默认实现。从语义上来说，我们可以认为Bald是一个更加明确的特征：Named泛指一个人的基础特征拥有一个名字，Bald更加明确的去描述是否有头发，然后我们使用这套规则描述一个没有头发的老头Bob。\nclass Larry fun name(): String =\u003e \"Larry\" 这个示例中，我们定义了一个名为Larry的类，该类也具备name()函数。但是Larry不是一个Named。\n等等，为什么不是呢？ 因为它并没有声明自己具备Named特征！ 请记住，特征需要 声明（nominal） ：想要提供特征的类型必须显式的声明。Larry确实没有声明。\n结构化多态（Structural subtyping） 多态还有另一种实现方式，无需明确声明，这种被称为 结构化多态 ，这意味着这与类型的构建方式有关，与名称无关。\n结构化多态的实现思路是，如果一个类型A恰好具备一个结构类别B所有必需的成员，那么A就是B。\n如果你用过Go语言，你会自然而然的想到Go的interface就是结构化多态的实现。\nPony的接口（Interfaces）: 结构化多态（structural subtyping） Pony也支持结构化多态，用 接口（interfaces）_ 就可以做到。接口看起来和特征差不多，不过它用interface定义。\ninterface HasName fun name(): String 上面的示例中，我们看到HasName接口和之前的Named特征，除了定义用的关键字不同外，似乎没多大区别。还记得Larry吗？“Larry不是一个Named”，但是\"Larry却是是一个HasName”，“Bob也是一个HasName”。但是程序中没有任何地方声明Bob和Larry与HasName有什么关联。\nPony的接口也可以具有默认实现的功能。如果类型明确声明它是该接口，则该类型将仅接受这些类型。\n我应该在自己的代码中使用特征还是接口？ 相信我，你两种都用的着！接口更加灵活，因此，如果不确定自己想要什么，请使用接口。但是特征也是一个强大的工具：它可以帮你检查子类型实现的完整性。\n","summary":"与其他面向对象的语言一样，Pony具有 多态性（subtyping） 。也就是说，某些类型充当 categories ，其他类型可以成为其成员。\n编程语言的实现上有两种 多态（subtyping） 类型： 声明式（nominal）多态 和 结构化（structural）多态 。它们有细微的不同，大多数编程语言只会选择一种实现。但是Pony两种都实现了！\n声明式多态（Nominal subtyping） 这种多态的实现被称为 声明式 ，因为它需要你明确指出你要实现的 类型名 。\n如果你有过面向对象编程经验，你应该熟悉 继承（单） 、 多重继承 、 组合 、 特征 或类似的概念，所有的这些都属于 声明式多态\n核心思想是您有一个声明与某种类别类型有关系的类型。例如，在Java中，类（具体类型）可以实现某个接口（抽象类型）。在Java中，这表示这个类必须要实现指定抽象接口。编译器将检查该类是否实现了此抽象类型需要的所有接口。\nPony的特征（Traits）：声明式多态（Nominal subtyping） Pony使用 特征（trait） 来实现声明式多态。trait 的定义看上去有点像 class ，但是它使用关键字trait，并且不能有任何字段。\ntrait Named fun name(): String =\u003e \"Bob\" class Bob is Named 上面代码中，我们定义了一个名为Named的特征，他又一个名为name()的成员函数，返回类型是字符串。它还提供了name()函数的默认实现，返回字符串\"Bob”。\n接着定义了类名为Bob的类。Bob在明确的声明自己实现了Named特征。在Pony中，我们把这成为 Bob拥有Named特征 ，或者说 Bob就是Named 。\n我们看到Bob并没有定义name()函数，所以它会使用特征中的默认实现。如果特征对name()函数没有做出默认实现，则编译器就会报一个错告知：Bob没有实现name()。\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald fun hair(): Bool =\u003e false class Bob is (Named \u0026 Bald) 一个类可以同时具备多个特征。在上面的示例中，Bob类同时提供了Named和Bald特征。","title":"特征和接口（Traits and Interfaces）","uri":"https://damon-kwok.github.io/pony-tutorial/types/traits-and-interfaces.html"},{"content":"算术运算就是你在小学中学到的与数字有关的概念：加法，减法，乘法，除法等。小菜一碟。人人都知道这个东西。尽管如此，还是希望花点时间阅读下这一节教程，因为牵扯到计算机，魔鬼总是隐藏在细节中。\n在基元类章节中介绍过，Pony中的数字类型是一种映射到机器码的特殊原语。整数类型和浮点类型都支持一组丰富的算术运算和位运算。中缀运算符，在数字基元类型上作为普通函数实现。\nPony语言专注于两个目标，性能和安全性。这两个目标有时会发生冲突。对于整数和浮点数的算术尤其如此。为了确保代码安全，应在每个可能发生计算操的作上检查溢出，被零除和其他错误情况。 Pony尝试在编译时强制执行尽可能多的安全性检查，但是对算术运算的检查只能在运行时进行。另一方面，从代码的性能角度考虑，应尽快的执行整数算术运算，并在尽可能少的CPU周期内执行完毕。检查溢出是昂贵的，导致溢出的简单危险算术是廉价的。\nPony提供了不同的算术运算方式，使程序员可以自由选择最适合他们的操作：安全但较慢的操作或不太安全但快速的操作，因为性能对于某些应用场景至关重要。\n整数（Integers） 默认的算术运算符（Ponys default Arithmetic） 在处理整数的+, -, *, /算术运算上，Pony使用了一些技巧，试图平衡对性能和正确性的需求。所有默认的算术运算都不会暴露任何未定义的行为或错误条件。这意味着它可以处理上溢/下溢和零除的情况。上溢/下溢使用对带符号整数的补全来适当地环绕语义来处理。在这方面，我们得到如下行为：\n// unsigned wrap-around on overflow U32.max_value() + 1 == 0 // signed wrap-around on overflow/underflow I32.min_value() - 1 == I32.max_value() 除零是一种特殊情况，它会影响除法运算符/和取余%运算符。在数学中，零除是不确定的。为了避免将除法定义为部分除法，在除数为零时引发错误或在这种情况下引入未定义的行为，当除数为0时，将 normal 除法定义为0。如果不小心使用，可能会导致无提示错误。选择部分和校验的算术以除以零。\n与Unsafe Arithmetic 相比，默认算法具有一点点运行时开销，因为它与unsafe变体不同，它会检测并处理溢出和除零的情况。\n    Operator Method Description     + add() wrap around on over-/underflow   - sub() wrap around on over-/underflow   * mul() wrap around on over-/underflow   / div() x / 0 = 0   % rem() x % 0 = 0   %% mod() x %% 0 = 0   - neg() wrap around on over-/underflow   \u003e\u003e shr() filled with zeros, so x \u003e\u003e 1 == x/2 is true   \u003c\u003c shl() filled with zeros, so x \u003c\u003c 1 == x*2 is true     非安全的算术运算符（Unsafe Arithmetic） 不安全的整数算术接近于C语言中的整数算术所期望的结果。不做任何检查， raw speed ，上溢，下溢或被零除的可能性。像在C中一样，上溢，下溢和被零除的情况是不确定的。在这些情况下，请勿依赖结果。它可以是任何东西，并且高度特定于平台。被零除甚至可能会用SIGFPE使程序崩溃。我们的建议是仅在确保可以排除这些情况时才使用这些运算符。\n非安全的算术运算符函数别名的完整列表：\n    Operator Method Undefined in case of     +~ add_unsafe() Overflow E.g. I32.max_value() +~ I32(1)   -~ sub_unsafe() Overflow   *~ mul_unsafe() Overflow.   /~ div_unsafe() Division by zero and overflow. E.g. I32.min_value() / I32(-1)   %~ rem_unsafe() Division by zero and overflow.   %%~ mod_unsafe() Division by zero and overflow.   -~ neg_unsafe() Overflow. E.g. -~I32.max_value()   \u003e\u003e~ shr_unsafe() If non-zero bits are shifted out. E.g. I32(1) \u003e\u003e~ U32(2)   \u003c\u003c~ shl_unsafe() If bits differing from the final sign bit are shifted out.     非安全的类型转换（Unsafe Conversion） 在Pony中整数类型之间的转换需要明确进行。每个数字类型都可以显式转换为其他类型。\n// converting an I32 to a 32 bit floating point I32(12).f32() 对于每个转换操作，都存在一个不安全的对应项，当从浮点数转换为浮点数时，转换会更快。如果目标类型长度小于源类型，例如，数字类型之间的所有这些不安全转换都是不确定的。如果我们将I64转换为F32：\n// converting an I32 to a 32 bit floating point, the unsafe way I32(12).f32_unsafe() // an example for an undefined unsafe conversion I64.max_value().f32_unsafe() // an example for an undefined unsafe conversion, that is actually safe I64(1).u8_unsafe() 这是数字类型所有可用转换的完整列表：\n    Safe conversion Unsafe conversion     u8() u8_unsafe()   u16() u16_unsafe()   u32() u32_unsafe()   u64() u64_unsafe()   u128() u128_unsafe()   ulong() ulong_unsafe()   usize() usize_unsafe()   i8() i8_unsafe()   i16() i16_unsafe()   i32() i32_unsafe()   i64() i64_unsafe()   i128() i128_unsafe()   ilong() ilong_unsafe()   isize() isize_unsafe()   f32() f32_unsafe()   f64() f64_unsafe()     Partial and Checked Arithmetic 如果需要避免溢出或被零除，并且性能问题不太关键，那么部分或校验算法将在运行期间提供极大的安全性。上/下溢和除以零的部分算术运算符错误。经过检查的算术方法将返回运算结果的元组，并返回表示溢出或其他异常行为的布尔值。\n// partial arithmetic let result = try USize.max_value() +? env.args.size() else env.out.print(\"overflow detected\") end // checked arithmetic let result = match USize.max_value().addc(env.args.size()) | (let result: USize, false) =\u003e // use result ... | (_, true) =\u003e env.out.print(\"overflow detected\") end 请注意，部分以及经过检查的算法会带来在不同的异常处理逻辑负担，并会产生一些性能开销。\n   Partial Operator Method Description     +? add_partial() errors on overflow/underflow   -? sub_partial() errors on overflow/underflow   *? mul_partial() errors on overflow/underflow   /? div_partial() errors on overflow/underflow and division by zero   %? rem_partial() errors on overflow/underflow and division by zero   %%? mod_partial() errors on overflow/underflow and division by zero     算术运算检查函数返回运算结果和一个布尔值，指示在元组中上溢/下溢或被零除。\n   Checked Method Description     addc() Checked addition, second tuple element is true on overflow/underflow.   subc() Checked subtraction, second tuple element is true on overflow/underflow.   mulc() Checked multiplication, second tuple element is true on overflow.   divc() Checked division, second tuple element is true on overflow or division by zero.   remc() Checked remainder, second tuple element is true on overflow or division by zero.   modc() Checked modulo, second tuple element is true on overflow or division by zero.   fldc() Checked floored division, second typle element is true on overflow or division by zero.     浮点数（Floating Point） Pony中默认的浮点数(F32, F64)算法的行为与浮点标准 IEEE 754. 中定义的相同。\n这意味着用+0除会返回Inf ，用-0除会返回-Inf。\n非安全的算术运算（Unsafe Arithmetic） 对于每个输入或每个结果，不安全的浮点操作不一定符合IEEE 754。如果任何不安全操作或其结果的参数为“ +/- Inf”或“ NaN”，则结果实际上是不确定的。\n这样可以进行更积极的优化并加快执行速度，但是对于与例外值+/- Inf和NaN不同的值，只会产生有效的结果。如果可以排除这些情况，建议仅对浮点数使用不安全的算法。\n    Operator Method     +~ add_unsafe()   -~ sub_unsafe()   *~ mul_unsafe()   /~ div_unsafe()   %~ rem_unsafe()   %%~ mod_unsafe()   -~ neg_unsafe()   \u003c~ lt_unsafe()   \u003e~ gt_unsafe()   \u003c=~ le_unsafe()   \u003e=~ ge_unsafe()   =~ eq_unsafe()   !=~ ne_unsafe()     另外，没有对于负数定义sqrt_unsafe()。\n","summary":"算术运算就是你在小学中学到的与数字有关的概念：加法，减法，乘法，除法等。小菜一碟。人人都知道这个东西。尽管如此，还是希望花点时间阅读下这一节教程，因为牵扯到计算机，魔鬼总是隐藏在细节中。\n在基元类章节中介绍过，Pony中的数字类型是一种映射到机器码的特殊原语。整数类型和浮点类型都支持一组丰富的算术运算和位运算。中缀运算符，在数字基元类型上作为普通函数实现。\nPony语言专注于两个目标，性能和安全性。这两个目标有时会发生冲突。对于整数和浮点数的算术尤其如此。为了确保代码安全，应在每个可能发生计算操的作上检查溢出，被零除和其他错误情况。 Pony尝试在编译时强制执行尽可能多的安全性检查，但是对算术运算的检查只能在运行时进行。另一方面，从代码的性能角度考虑，应尽快的执行整数算术运算，并在尽可能少的CPU周期内执行完毕。检查溢出是昂贵的，导致溢出的简单危险算术是廉价的。\nPony提供了不同的算术运算方式，使程序员可以自由选择最适合他们的操作：安全但较慢的操作或不太安全但快速的操作，因为性能对于某些应用场景至关重要。\n整数（Integers） 默认的算术运算符（Ponys default Arithmetic） 在处理整数的+, -, *, /算术运算上，Pony使用了一些技巧，试图平衡对性能和正确性的需求。所有默认的算术运算都不会暴露任何未定义的行为或错误条件。这意味着它可以处理上溢/下溢和零除的情况。上溢/下溢使用对带符号整数的补全来适当地环绕语义来处理。在这方面，我们得到如下行为：\n// unsigned wrap-around on overflow U32.max_value() + 1 == 0 // signed wrap-around on overflow/underflow I32.min_value() - 1 == I32.max_value() 除零是一种特殊情况，它会影响除法运算符/和取余%运算符。在数学中，零除是不确定的。为了避免将除法定义为部分除法，在除数为零时引发错误或在这种情况下引入未定义的行为，当除数为0时，将 normal 除法定义为0。如果不小心使用，可能会导致无提示错误。选择部分和校验的算术以除以零。\n与Unsafe Arithmetic 相比，默认算法具有一点点运行时开销，因为它与unsafe变体不同，它会检测并处理溢出和除零的情况。\n    Operator Method Description     + add() wrap around on over-/underflow   - sub() wrap around on over-/underflow   * mul() wrap around on over-/underflow   / div() x / 0 = 0   % rem() x % 0 = 0   %% mod() x %% 0 = 0   - neg() wrap around on over-/underflow   \u003e\u003e shr() filled with zeros, so x \u003e\u003e 1 == x/2 is true   \u003c\u003c shl() filled with zeros, so x \u003c\u003c 1 == x*2 is true     非安全的算术运算符（Unsafe Arithmetic） 不安全的整数算术接近于C语言中的整数算术所期望的结果。不做任何检查， raw speed ，上溢，下溢或被零除的可能性。像在C中一样，上溢，下溢和被零除的情况是不确定的。在这些情况下，请勿依赖结果。它可以是任何东西，并且高度特定于平台。被零除甚至可能会用SIGFPE使程序崩溃。我们的建议是仅在确保可以排除这些情况时才使用这些运算符。","title":"算术运算符（Arithmetic）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/arithmetic.html"},{"content":"A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.\nWe’ll give a couple examples of using type aliases, just to get the feel of them.\nEnumerations One way to use type aliases is to express an enumeration. For example, imagine we want to say something must either be Red, Blue or Green. We could write something like this:\nprimitive Red primitive Blue primitive Green type Colour is (Red | Blue | Green) There are two new concepts in there. The first is the type alias, introduced with the keyword type. It just means that the name that comes after type will be translated by the compiler to the type that comes after is.\nThe second new concept is the type that comes after is. It’s not a single type! Instead, it’s a union type. You can read the | symbol as or in this context, so the type is “Red or Blue or Green”.\nA union type is a form of closed world type. That is, it says every type that can possibly be a member of it. In contrast, object-oriented subtyping is usually open world, e.g. in Java, an interface can be implemented by any number of classes.\nYou can also declare constants like in C or Go like this,\nprimitive Red fun apply(): U32 =\u003e 0xFF0000FF primitive Green fun apply(): U32 =\u003e 0x00FF00FF primitive Blue fun apply(): U32 =\u003e 0x0000FFFF type Colour is (Red | Blue | Green) or namespace them like this\nprimitive Colours fun red(): U32 =\u003e 0xFF0000FF fun green(): U32 =\u003e 0x00FF00FF You might also want to iterate over the enum like this to print its name for debugging purposes\nprimitive ColourList fun apply(): Array[Colour] =\u003e [Red; Green; Blue] for colour in ColourList().values() do end Complex types If a type is complicated, it can be nice to give it a mnemonic name. For example, if we want to say that a type must implement more than one interface, we could say:\ninterface HasName fun name(): String interface HasAge fun age(): U32 interface HasAddress fun address(): String type Person is (HasName \u0026 HasAge \u0026 HasAddress) This use of complex types applies to traits, not just interfaces:\ntrait HasName fun name(): String =\u003e \"Bob\" trait HasAge fun age(): U32 =\u003e 42 trait HasAddress fun address(): String =\u003e \"3 Abbey Road\" type Person is (HasName \u0026 HasAge \u0026 HasAddress) There’s another new concept here: the type has a \u0026 in it. This is similar to the | of a union type: it means this is an intersection type. That is, it’s something that must be all of HasName, HasAge and HasAddress.\nBut the use of type here is exactly the same as the enumeration example above, it’s just providing a name for a type that is otherwise a bit tedious to type out over and over.\nAnother example, this time from the standard library, is SetIs. Here’s the actual definition:\ntype SetIs[A] is HashSet[A, HashIs[A!]] Again there’s something new here. After the name SetIs comes the name A in square brackets. That’s because SetIs is a generic type. That is, you can give a SetIs another type as a parameter, to make specific kinds of set. If you’ve used Java or C#, this will be pretty familiar. If you’ve used C++, the equivalent concept is templates, but they work quite differently.\nAnd again the use of type just provides a more convenient way to refer to the type we’re aliasing:\nHashSet[A, HashIs[A!]] That’s another generic type. It means a SetIs is really a kind of HashSet. Another concept has snuck in, which is ! types. This is a type that is the alias of another type. That’s tricky stuff that you only need when writing complex generic types, so we’ll leave it for later.\nOne more example, again from the standard library, is the Map type that gets used a lot. It’s actually a type alias. Here’s the real definition of Map:\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] Unlike our previous example, the first type parameter, K, has a type associated with it. This is a constraint, which means when you parameterise a Map, the type you pass for K must be a subtype of the constraint.\nAlso, notice that box appears in the type. This is a reference capability. It means there is a certain class of operations we need to be able to do with a K. We’ll cover this in more detail later.\nJust like our other examples, all this really means is that Map is really a kind of HashMap.\nOther stuff Type aliases get used for a lot of things, but this gives you the general idea. Just remember that a type alias is always a convenience: you could replace every use of the type alias with the full type after the is.\nIn fact, that’s exactly what the compiler does.\n","summary":"A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.\nWe’ll give a couple examples of using type aliases, just to get the feel of them.\nEnumerations One way to use type aliases is to express an enumeration.","title":"类型别名（Type Aliases）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-aliases.html"},{"content":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 causal. (Not casual!)  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。\n","summary":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 causal. (Not casual!)  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。","title":"类型系统概览","uri":"https://damon-kwok.github.io/pony-tutorial/types/at-a-glance.html"},{"content":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。\n类型集合的特性可以让我们很容易的将特征和接口组合在一起。例如，标准库中的Map的定义方式：\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] 这是一个相当复杂的类型别名。让我们看一下K的定义：(Hashable box \u0026 Comparable[K] box)，这表示K是一个Hashable 同时 它也具有Comparable[K]的特征。\n类型表达式组合（Combining type expressions） 类型表达式可以组合出更复杂的类型。这是标准库中的另一个示例：\nvar _array: Array[((K, V) | _MapEmpty | _MapDeleted)] 在这里，我们定义了一个数组类型的变量，数组的元素可以是(K, V)类型的元组，也可以是_MapEmpty 或 _MapDeleted。\n每个类型表达式都有括号，所以了解了这一点，实际上还是很容易阅读的。如果遇到需要高频率使用复杂的类型表达式，最好为它提供一个类型别名。\ntype Number is (Signed | Unsigned | Float) type Signed is (I8 | I16 | I32 | I64 | I128) type Unsigned is (U8 | U16 | U32 | U64 | U128) type Float is (F32 | F64) 上面的类型别名定义都来自于标准库。\nNumber是一个类型别名，它定义中中还可以包含其他类型别名？ 没错，这是个非常有趣和方便的特性。\n","summary":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。","title":"类型表达式（Type Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-expressions.html"},{"content":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\n类的组成部分 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.就可以选择构造函数：\nlet defaultWombat = Wombat(\"Fantastibat\") // 使用默认构造函数 let hungryWombat = Wombat.hungry(\"Nomsbat\", 12) // 使用`hunger`构造函数 构造函数中name'参数的单引号时啥意思？ 你可以在 参数 和 内部变量 命名中使用单引号，用来区分时 外部传入 和 内部定义 的字段（就像Python的self.name=name Java的this.nama=name C++的：this-\u003ename=name)。\n每一个构造函数都要为所有字段做出初始化，否则编译器会给你一个error。Pony中是不存在null的，我们不能像Java，C#等语言中一样将字段赋值为null，也没有数字不初始化默认为0的规则。Pony不希望在你运行时因为字段undefined导致崩溃（不像C和C++）。\n有时我们希望可以为所有构造函数快速的设置字段初始值：\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面的例子中，通过为字段赋初值，默认将口渴等级字段设置为1，需要不同的值，可以在构造函数中做修改。\n无参数的构造函数\nclass Hawk var _hunger_level: U64 = 0 class Owl var _hunger_level: U64 new create() =\u003e _hunger_level = 42 上面例子中我们定义了两个类，Hawk类没有构造函数，编译器会生成一个默认的create构造函数。Owl定义了一个构造函数设置_hunger_level字段。\n创建实例时如果类拥有一个无参数构造函数，直接省略掉括号：\nclass Forest let _owl: Owl = Owl let _hawk: Hawk = Hawk 稍后我们会在语法糖章节中做出详细解释。\n成员函数 Pony中的成员函数类似于Java，C#，C++，Ruby，Python等面向对象语言中的方法（类成员函数）。和构造函数一样它们也可以有参数和返回值类型（注意是_可以有_，不是必须。如果没有明确给出返回值类型，默认为None，表示没有返回值）。\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' fun hunger(): U64 =\u003e _hunger_level fun ref set_hunger(to: U64 = 0): U64 =\u003e _hunger_level = to 我们从hunger函数说起：它有一个U64返回类型，返回树袋熊当前的口渴等级。这里我们没有使用return关键字，因为我们要返回的_hunger_level是函数的最后一个表达式。\nPony中有return关键字吗？ 当然有，当你需要在函数中\"提前\"返回时，也就是说你不希望函数运行到最后一个表达式的时候，就需要用到return关键字。\n再来看第二个函数set_hunger，这里出现了 一堆 新概念，让我们来逐步了解一下这些概念。\n fun后面的ref关键字  这是一个 引用权能 。在这里，因为我们需要修改_hunger_level字段。\nhunger方法的接收者参考能力是什么？ 如果未指定，默认的接收者引用权能是box，这意味着“我只需要能读取，不需要修改”。\n如果我们将set_hunger方法中的ref关键字保留下来会怎样？ 编译器会给您一个错误。它会显示您正在尝试修改字段并抱怨它。\n 参数to后面的= 0  这是一个 默认参数 。当你调用这个函数时没有传入参数，就会默认为这个值，在这里它的默认值被设置为0。\n 函数实际返回了什么？  它返回修改前的 旧值 。\n等等，开什么玩笑？旧值？ 没错，在Pony中赋值操作是一个表达式，这意味着它有一个返回值，在很多数语言里赋值语句会返回_新值_，换句话说a=b在大多数语言里都会返回b，但是在Pony中返回a。\n…为什么？ 这被称为\"破坏性读取”，它使您可以使用功能安全类型系统来完成出色的工作，我们稍后再讨论。现在，我们只只需要知道可以使用它来实现_swap_操作。在其他语言里要交换a和b的值你通常需要这么做：\nvar temp = a a = b b = temp 用Pony这样就可以了：\na = b = a 销毁函数 销毁函数是一个特殊函数，函数名为_final，box。函数必须被定义为fun _final()。\n在GC收集对象之前，将调用对象的销毁函数。对象在销毁后成员函数依然可以被调用，但只能从另一个销毁函数内调用。另外需要注意一点：无法从销毁函数中发送消息。\n销毁函数通常用于清理以C代码分配的资源，例如文件句柄，网络套接字等。\n关于继承？ 在很多面向对象的语言中，一种类型可以继承另一种类型，例如在Java中某种东西可以“扩展”其他某种东西。Pony不这样做。相反，Pony的做法是 组合 而不是 继承 。换句话说，在Pony中你的逻辑需要去表达 has ，而不是 is 。\n另一方面，Pony具有强大的 trait（特征） 系统（类似于具有默认实现的Java 8 接口）和强大的 interface（接口） 系统（类似于Go语言的接口，也就是结构化类型）。\n稍后我们将详细讨论这些内容。\n命名规则 Pony中的所有命名，包括类型名，方法名和变量名等，都只能包含 ASCII字符。\n实际上，Pony代码的所有的元素都必须为ASCII，字符串文内容除外，字符串可以愉快地直接从源文件中接受任何类型的字节（无论是UTF-8编码还是ISO-8859-2并以其编码形式表示）。\nPony的类型，无论是class，actor，trait，interface，primitive还是类型别名，都必须以大写字母开头。在私有或特殊 methods （行为，构造函数和普通函数）的下划线之后，任何方法或变量（包括参数和字段）都必须以小写字母开头。在所有情况下，都不允许在一行中或名称末尾加下划线，但否则，字母和数字的任何组合都是合法的。\n实际上，数字也可以使用单个下划线作为分隔符！但是，只有有效的变量名才能以质数结尾。\n","summary":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\n类的组成部分 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.","title":"类（Classes）","uri":"https://damon-kwok.github.io/pony-tutorial/types/classes.html"},{"content":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface. Most functions on a Pointer[A] are private to maintain memory safety. \"\"\" new create() =\u003e \"\"\" A null pointer. \"\"\" compile_intrinsic new _alloc(len: USize) =\u003e \"\"\" Space for len instances of A. \"\"\" compile_intrinsic 这里有两个构造函数。第一个创建一个新的空Pointer，第二个创建分配了内存空间的Pointer。\n成员函数 和类一样，结构体也可以有函数。对Pony类成员函数的所有内容也适用于结构。\nWe’ll see structs again 在Pony与C代码的交互中，结构体扮演着重要的角色。我们将在教程的C-FFI部分中详细讲解结构体。现在，我们不需要过多关注结构体。\n","summary":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface.","title":"结构体（Structs）","uri":"https://damon-kwok.github.io/pony-tutorial/types/structs.html"},{"content":"Pony允许你编写代码时做一些简化，让代码更简洁、易读。使用语法糖是可选的，如果您愿意，你可以始终使用完整的书写方式。\nApply语法糖 许多Pony类都有一个名为apply的函数，该函数可以执行一些该类型最常见的操作。Pony允许你省略apply这个函数名，直接从对象调用。所以:\nvar foo = Foo.create() foo() 等同于：\nvar foo = Foo.create() foo.apply() 需要参数的话可以像调用普通方法那样去添加。\nvar foo = Foo.create() foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create() foo.apply(x, 37 where crash = false) 必须要提供参数吗? 是的，只有apply会为你自动添加，正确的参数数量和类型必须你自己提供。默认传参和命名传参的机制可以正常使用。\n如果apply会被自动添加，那我怎么调用其他函数？ 只有直接调用对象时才添加apply，其他时候不会。编译器能判断什么时候该添加apply。\nCreate语法糖 要实例化对象，你需要指定类型并调用构造函数。Pony允许你忽略构造函数，并将为您插入一个create()调用。所以:\nvar foo = Foo 等同于：\nvar foo = Foo.create() 通常，类型在表达式中是不被求值的，因此省略掉构造函数并不会造成歧义。记住，类型是很容易被识别的，因为它始终是以大写字母开头。\n如果create需要参数，可以直接在后面加括号传入。默认参数和命名传参机制都可以正常使用。\nvar foo = Foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create(x, 37 where crash = false) 如果我想使用一个名字不是create的构造函数怎么做? 不行，语法糖帮不了你，你必须自己把它写出来。\n如果我要调用的create没有参数，我可以加上括号吗? 不能加，调用Type()相当于在组合使用create和apply(参见下面)。要调用Type.create()只需使用Type。\ncreate和apply语法糖的组合使用 如果类型有一个不带参数的create构造函数，那么create和apply语法糖可以一起使用。只需调用类型，创建和应用的调用将被添加。对create的调用将不接受任何参数，而对apply的调用将接受提供的任何参数。\nvar foo = Foo() var bar = Bar(x, 37 where crash = false) 等同于：\nvar foo = Foo.create().apply() var bar = Bar.create().apply(x, 37 where crash = false) 如果create有默认参数怎么办？如果我想使用默认参数，是否能使用create-apply组合语法糖? 只有当create构造函数没有参数时，才可以使用组合的create-apply语法糖。如果有默认参数，则不能使用。\nUpdate语法糖 update语法糖允许任何类使用赋值的方式来更新数据。在很多语言都可以给集合中的元素赋值，例如，一个简单的C数组a[3] = x;。\n遇到左边是函数调用的赋值表达式，Pony会将其转换为对update的调用，而右边的值则是一个额外的参数。所以:\nfoo(37) = x 等同于：\nfoo.update(37 where value = x) 赋值右侧的值总是传递给一个名为value的参数。任何对象都可以简单地通过提供一个update函数和value参数来支持这种语法。\n我的update函数必须是整数型的参数吗? 不，你可以自定义参数类型，只要有一个名为value的参数。以下都可以:\nfoo1(2, 3) = x foo2() = x foo3(37, \"Hello\", 3.5 where a = 2, b = 3) = x 参数列表中value的位置有关系吗？ 虽然从严格意义上讲没什么关系，但把value作为最后一个参数是个好习惯。这样，所有其他参数就可以通过位置传参来指定。\n","summary":"Pony允许你编写代码时做一些简化，让代码更简洁、易读。使用语法糖是可选的，如果您愿意，你可以始终使用完整的书写方式。\nApply语法糖 许多Pony类都有一个名为apply的函数，该函数可以执行一些该类型最常见的操作。Pony允许你省略apply这个函数名，直接从对象调用。所以:\nvar foo = Foo.create() foo() 等同于：\nvar foo = Foo.create() foo.apply() 需要参数的话可以像调用普通方法那样去添加。\nvar foo = Foo.create() foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create() foo.apply(x, 37 where crash = false) 必须要提供参数吗? 是的，只有apply会为你自动添加，正确的参数数量和类型必须你自己提供。默认传参和命名传参的机制可以正常使用。\n如果apply会被自动添加，那我怎么调用其他函数？ 只有直接调用对象时才添加apply，其他时候不会。编译器能判断什么时候该添加apply。\nCreate语法糖 要实例化对象，你需要指定类型并调用构造函数。Pony允许你忽略构造函数，并将为您插入一个create()调用。所以:\nvar foo = Foo 等同于：\nvar foo = Foo.create() 通常，类型在表达式中是不被求值的，因此省略掉构造函数并不会造成歧义。记住，类型是很容易被识别的，因为它始终是以大写字母开头。\n如果create需要参数，可以直接在后面加括号传入。默认参数和命名传参机制都可以正常使用。\nvar foo = Foo(x, 37 where crash = false) 等同于：\nvar foo = Foo.create(x, 37 where crash = false) 如果我想使用一个名字不是create的构造函数怎么做?","title":"语法糖（Sugar）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/sugar.html"},{"content":"An important part of Pony’s capabilities is being able to say “I’m done with this thing.” We’ll cover two means of handling this situation: consuming a variable and destructive reads.\nConsuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don’t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.\nYou can do this by using consume. When you consume a variable you take the value out of it, effectively leaving the variable empty. No code can read from that variable again until a new value is written to it. Consuming a local variable or a parameter allows you to make an alias with the same type, even if it’s an iso or trn. For example:\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! The compiler is happy with that because by consuming a, you’ve said the value can’t be used again and the compiler will complain if you try to.\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! var c: Wombat tag = a // Not allowed! Here’s an example of that. When you try to assign a to c, the compiler will complain.\nCan I consume a field? Definitely not! Consuming something means it is empty, that is, it has no value. There’s no way to be sure no other alias to the object will access that field. If we tried to access a field that was empty, we would crash. But there’s a way to do what you want to do: destructive read.\nDestructive read There’s another way to move a value from one name to another. Earlier, we talked about how assignment in Pony returns the old value of the left-hand side, rather than the new value. This is called destructive read, and we can use it to do what we want to do, even with fields.\nclass Aardvark var buddy: Wombat iso new create() =\u003e buddy = recover Wombat end fun ref test(a: Wombat iso) =\u003e var b: Wombat iso = buddy = consume a // Allowed! Here, we consume a, assign it to the field buddy, and assign the old value of buddy to b.\nWhy is it ok to destructively read fields when we can’t consume them? Because when we do a destructive read, we assign to the field so it always has a value. Unlike consume, there’s no time when the field is empty. That means it’s safe and the compiler doesn’t complain.\n","summary":"An important part of Pony’s capabilities is being able to say “I’m done with this thing.” We’ll cover two means of handling this situation: consuming a variable and destructive reads.\nConsuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don’t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.","title":"转让和破坏性读取（Consume and Destructive Read）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html"},{"content":"中缀运算符（Infix Operators） 中缀运算符需要两个操作数，位于操作数之间。算术和比较运算符是最常见的中缀运算符：\n1 + 2 a \u003c b Pony的中缀运算符集和其他语言基本一致。\n运算符别名（Operator aliasing） Pony中的大多数中缀运算符都是函数的别名。左边的操作数是调用函数的接收器，右边的操作数作为参数传递。例如，下面的两个表达式是等效的：\nx + y x.add(y) +不是只能用于特性类型的特殊符号。任何类型都可以提供自己的add函数，然后可以根据需要对该类型使用+。\n在定义自己的add函数时，对参数类型或返回类型没有限制。 +的右侧必须与参数类型匹配，并且+表达式将具有add函数返回的类型。\n下面的代码是自定义+运算符的完整示例：\n// Define a suitable type class Pair var _x: U32 = 0 var _y: U32 = 0 new create(x: U32, y: U32) =\u003e _x = x _y = y // Define a + function fun add(other: Pair): Pair =\u003e Pair(_x + other._x, _y + other._y) // Now let's use it class Foo fun foo() =\u003e var x = Pair(1, 2) var y = Pair(3, 4) var z = x + y 使用类型联合体或f界多态性可以在某种程度上重载中缀运算符，但这不在本教程的讨论范围之内。有关更多信息，请参考Pony标准库。\n如果您不想，则不必担心任何这些。您可以像使用任何其他语言一样简单地将现有的中缀运算符用于数字，而不必为您自己的类型提供它们。\n中缀运算符函数别名的完整列表：\n    运算符 函数 描述 注意     + add() Addition    - sub() Subtraction    * mul() Multiplication    / div() Division    % rem() Remainder    %% mod() Modulo Starting with version 0.26.1   \u003c\u003c shl() Left bit shift    \u003e\u003e shr() Right bit shift    and op_and() And, both bitwise and logical    or op_or() Or, both bitwise and logical    xor op_xor() Xor, both bitwise and logical    == eq() Equality    != ne() Non-equality    \u003c lt() Less than    \u003c= le() Less than or equal    \u003e= ge() Greater than or equal    \u003e gt() Greater than    \u003e~ gt_unsafe() Unsafe greater than    +~ add_unsafe() Unsafe Addition    -~ sub_unsafe() Unsafe Subtraction    *~ mul_unsafe() Unsafe Multiplication    /~ div_unsafe() Unsafe Division    %~ rem_unsafe() Unsafe Remainder    %%~ mod_unsafe() Unsafe Modulo Starting with version 0.26.1   \u003c\u003c~ shl_unsafe() Unsafe left bit shift    \u003e\u003e~ shr_unsafe() Unsafe right bit shift    ==~ eq_unsafe() Unsafe equality    !=~ ne_unsafe() Unsafe non-equality    \u003c~ lt_unsafe() Unsafe less than    \u003c=~ le_unsafe() Unsafe less than or equal    \u003e=~ ge_unsafe() Unsafe greater than or equal    +? add_partial()? Partial Addition    -? sub_partial()? Partial Subtraction    *? mul_partial()? Partial Multiplication    /? div_partial()? Partial Division    %? rem_partial()? Partial Remainder    %%? mod_partial()? Partial Modulo Starting with version 0.26.1     短路求值（Short circuiting） 与Bool变量一起使用时，and和or运算符会采用使用 短路求值（short circuiting） 。第一个操作数始终会被求值，第二个操作数仅在对有影响结果时，才会被求值。\n对于and，如果第一个操作数是 false ，则不会对第二个操作数求值，因为它不会影响结果。\n对于or，如果第一个操作数是 true ，则不会对第二个操作数求值，因为它不会影响结果。\n这是编译器内置的特殊功能，不能与其他类型的运算符别名一起使用。\n一元运算符（Unary operators） 一元运算符的与中缀运算符的别名机制类似，但只有一个操作数。例如，以下表达式是等效的：\n-x x.neg() 一元运算符函数别名的完整列表：\n    运算符 函数 描述       | neg() | Arithmetic negation    not | op_not() | Not, both bitwise and logical -~ | neg_unsafe() | Unsafe arithmetic negation\n 运算符优先级（Precedence） 在Pony中，一元运算符的优先级总是比中缀运算符高：not a == b将被解释为（not a）== b而不是not（a == b）。\n在复杂表达式中使用中缀运算符时， 优先级 问题很关键。试着评估下面这句表达式的运算符优先级：\n1 + 2 * 3 // Compilation failed. 如果我们计算加法，得到的结果为9，如果计算乘法，得到的结果为7。在数学中有一套评估运算符优先级的规则，大多数编程语言都遵循这种方法。\n这样做的问题是程序员必须记住规则，通常人们对这样的事情不是很擅长。大多数人会记得在加法之前要进行乘法运算，但是左移与按位运算又如何呢？有时人们会忘记（或猜错），这会导致错误。更糟糕的是，这些错误通常很难发现。\nPony采取了不同的做法，去避免这个问题。 如果一个表达式中需要使用多个中缀运算符 必须 使用括号来消除歧义。如果您不这样做，编译时会报错。\n上面的示例在Pony中是非法的，正确的写法为：\n1 + (2 * 3) // 7 如果使用的是相同的运算符就可以省略括号：\n1 + 2 + 3 // 6 同时，一元运算符和中缀运算符的混合不需要额外的括号，因为一元运算符总是和操作数紧贴在一起，因此如果上面的示例使用的是负3是没问题的。但是如果用到不同的中缀运算符：\n1 + 2 * -3 // Compilation failed. 仍然需要括号来消除歧义，就像上面所做的一样，但是不需要负数一元运算（-）加括号：\n1 + (2 * -3) // -5 我们可以看到，将一元运算符应用在中缀运算之前更有意义，因为它仅作用于表达式中的单个数字，因此它永远不会模棱两可。\n一元运算符也可以应用于括号，在括号之外，所有中缀运算符之前，对括号中的运算结果进行操作：\n1 + -(2 * -3) // 7 ","summary":"中缀运算符（Infix Operators） 中缀运算符需要两个操作数，位于操作数之间。算术和比较运算符是最常见的中缀运算符：\n1 + 2 a \u003c b Pony的中缀运算符集和其他语言基本一致。\n运算符别名（Operator aliasing） Pony中的大多数中缀运算符都是函数的别名。左边的操作数是调用函数的接收器，右边的操作数作为参数传递。例如，下面的两个表达式是等效的：\nx + y x.add(y) +不是只能用于特性类型的特殊符号。任何类型都可以提供自己的add函数，然后可以根据需要对该类型使用+。\n在定义自己的add函数时，对参数类型或返回类型没有限制。 +的右侧必须与参数类型匹配，并且+表达式将具有add函数返回的类型。\n下面的代码是自定义+运算符的完整示例：\n// Define a suitable type class Pair var _x: U32 = 0 var _y: U32 = 0 new create(x: U32, y: U32) =\u003e _x = x _y = y // Define a + function fun add(other: Pair): Pair =\u003e Pair(_x + other._x, _y + other._y) // Now let's use it class Foo fun foo() =\u003e var x = Pair(1, 2) var y = Pair(3, 4) var z = x + y 使用类型联合体或f界多态性可以在某种程度上重载中缀运算符，但这不在本教程的讨论范围之内。有关更多信息，请参考Pony标准库。","title":"运算符（Operators）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/ops.html"}]