[{"content":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.\nLet’s start with a simple one.\nleft side must be something that can be assigned to Suppose you wrote:\nactor Main let x: I64 = 0 new create(env: Env) =\u003e x = 12 The error message would be:\nError: .../a.pony:6:5: can't assign to a let or embed definition more than once x = 12 ^ Error: .../a.pony:6:7: left side must be something that can be assigned to x = 12 ^ What happened is that you declared x as a constant, by writing let x, and then tried to assign a new value to it, 12. To fix the error, replace let with var or reconsider what value you want x to have.\nThat one error resulted in two error messages. The first, pointing to the x, describes the specific problem, that x was defined with let. The second, pointing to the = describes a more general error, that whatever is on the left side of the assignment is not something that can be assigned to. You would get that same error message if you attempted to assign a value to a literal, like 3.\ncannot write to a field in a box function Suppose you create a class with a mutable field and added a method to change the field:\nclass Wombat var color: String = \"brown\" fun dye(new_color: String) =\u003e color = new_color The error message would be:\nError: .../a.pony:4:11: cannot write to a field in a box function. If you are trying to change state in a function use fun ref color = new_color ^ To understand this error message, you have to have some background. The field color is mutable since it is declared with var, but the method dye does not have an explicit receiver reference capability. The default receiver reference capability is box, which allows dye to be called on any mutable or immutable Wombat; the box reference capability says that the method may read from but not write to the receiver. As a result, it is illegal to attempt to modify the receiver in the method.\nTo fix the error, you would need to give the dye method a mutable reference capability, such as ref: fun ref dye(new_color: String) =\u003e ....\nreceiver type is not a subtype of target type Suppose you made a related, but slightly different error:\nclass Rainbow let colors: Array[String] = Array[String] fun add_stripe(color: String) =\u003e colors.push(color) In this example, rather than trying to change the value of a field, the code calls a method which attempts to modify the object referred to by the field.\nThe problem is very similar to that of the last section, but the error message is significantly more complicated:\nError: ../a.pony:4:16: receiver type is not a subtype of target type colors.push(color) ^ Info: .../a.pony:4:5: receiver type: this-\u003eArray[String val] ref colors.push(color) ^ .../ponyc/packages/builtin/array.pony:252:3: target type: Array[String val] ref fun ref push(value: A): Array[A]^ =\u003e ^ .../a.pony:2:15: Array[String val] box is not a subtype of Array[String val] ref: box is not a subtype of ref let colors: Array[String] = Array[String]() ^ Once again, Pony is trying to be helpful. The first few lines describe the error, in general terms that only a programming language maven would like: an incompatibility between the receiver type and the target type. However, Pony provides more information: the lines immediately after “Info:” tell you what it believes the receiver type to be and the next few lines describe what it believes the target type to be. Finally, the last few lines describe in detail what the problem is.\nUnfortunately, this message does not locate the error as clearly as the previous examples.\nBreaking it down, the issue seems to be with the call to push, with the receiver colors. The receiver type is this-\u003eArray[String val] ref; in other words, the view that this method has of a field whose type is Array[String val] ref. In the class Rainbow, the field colors is indeed declared with the type Array[String], and the default reference capability for Strings is val while the default reference capability for Array is ref.\nThe “target type” in this example is the type declaration for the method push of the class Array, with its type variable A replaced by String (again, with a default reference capability of val). The reference capability for the overall array, as required by the receiver reference capability of push, is ref. It seems that the receiver type and the target type should be pretty close.\nBut take another look at the final lines: what Pony thinks is the actual receiver type, Array[String val] box, is significantly different from what it thinks is the actual target type, Array[String val] ref. And a type with a reference capability of box, which is immutable, is indeed not a subtype of a type with a reference capability of ref, which is mutable.\nThe issue must lie with the one difference between the receiver type and the target type, which is the prefix “this-\u003e”. The type this-\u003eArray[String val] ref is a viewpoint adapted type, or arrow type, that describes the Array[String val] ref “as seen by the receiver”. The receiver, in this case, has the receiver reference capability of the method add_stripe, which is the default box. That is why the final type is Array[String val] box.\nThe fundamental error in this example is the same as the last: the default receiver reference capability for a method is box, which is immutable. This method, however, is attempting to modify the receiver, by adding another color stripe. That is not legal at all.\nAs an aside, while trying to figure out what is happening, you may have been misled by the declaration of the colors field, let colors.... That declaration makes the colors binding constant. As a result, you cannot assign a new array to the field. On the other hand, the array itself can be mutable or immutable. In this example, it is mutable, allowing push to be called on the colors field in the add_stripe method.\nA note on compiler versions The error messages shown in this section are from ponyc 0.2.1-1063-g6ae110f [release], the current head of the master branch at the time this is written. The messages from other versions of the compiler may be different, to a greater or lesser degree.\n","summary":"You’ve been through the tutorial, you’ve watched some videos, and now you’re ready to write some Pony code. You fire up your editor, shovel coal into the compiler, and… you find yourself looking at a string of gibberish.\nDon’t panic! Pony’s error messages try to be as helpful as possible and the ultimate goal is to improve them further. But, in the meantime, they can be a little intimidating.\nThis section tries to provide a short bestiary of Pony’s error messages, along with a guide to understanding them.","title":"A Short Guide to Pony Error Messages","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/error-messages.html"},{"content":"When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don’t know the precise reference capability of the origin.\nWhen that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -\u003e.\nUsing this-\u003e as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box. Sometimes, we want to be able to talk about a type to take this into account. For example:\nclass Wombat var _friend: Wombat fun friend(): this-\u003eWombat =\u003e _friend Here, we have a Wombat, and every Wombat has a friend that’s also a Wombat (lucky Wombat). In fact, it’s a Wombat ref, since ref is the default reference capability for a Wombat (since we didn’t specify one). We also have a function that returns that friend. It’s got a box receiver (because box is the default receiver reference capability for a function if we don’t specify it).\nSo the return type would normally be a Wombat box. Why’s that? Because, as we saw earlier, when we read a ref field from a box origin, we get a box. In this case, the origin is the receiver, which is a box.\nBut wait! What if we want a function that can return a Wombat ref when the receiver is a ref, a Wombat val when the receiver is a val, and a Wombat box when the receiver is a box? We don’t want to have to write the function three times.\nWe use this-\u003e! In this case, this-\u003eWombat. It means “a Wombat ref as seen by the receiver”.\nWe know at the call site what the real reference capability of the receiver is. So when the function is called, the compiler knows everything it needs to know to get this right.\nUsing a type parameter as a viewpoint We haven’t covered generics yet, so this may seem a little weird. We’ll cover this again when we talk about generics (i.e. parameterised types), but we’re mentioning it here for completeness.\nAnother time we don’t know the precise reference capability of something is if we are using a type parameter. Here’s an example from the standard library:\nclass ListValues[A, N: ListNode[A] box] is Iterator[N-\u003eA] Here, we have a ListValues type that has two type parameters, A and N. In addition, N has a constraint: it has to be a subtype of ListNode[A] box. That’s all fine and well, but we also say the ListValues[A, N] provides Iterator[N-\u003eA]. That’s the interesting bit: we provide an interface that let’s us iterate over values of the type N-\u003eA.\nThat means we’ll be returning objects of the type A, but the reference capability will be the same as an object of type N would see an object of type A.\nUsing box-\u003e as a viewpoint There’s one more way we use arrow types, and it’s also related to generics. Sometimes we want to talk about a type parameter as it is seen by some unknown type, as long as that type can read the type parameter.\nIn other words, the unknown type will be a subtype of box, but that’s all we know. Here’s an example from the standard library:\ninterface Comparable[A: Comparable[A] box] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) Here, we say that something is Comparable[A] if and only if it has functions eq and ne and those functions have a single parameter of type box-\u003eA and return a Bool. In other words, whatever A is bound to, we only need to be able to read it.\n","summary":"When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don’t know the precise reference capability of the origin.\nWhen that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -\u003e.\nUsing this-\u003e as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box.","title":"Arrow Types aka Viewpoints","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/arrow-types.html"},{"content":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible. This can be applied to types that are related through inheritance, as well as unions and intersections. This is done at runtime, and if it fails then an error is raised.\nLet’s look at an example. The json package provides a type called JsonDoc that can attempt to parse strings as fragments of JSON. The parsed value is stored in the data field of the object, and that field’s type is the union (F64 | I64 | Bool | None | String | JsonArray | JsonObject). So if there is a JsonDoc object referenced by jsonDoc then jsonDoc.parse(\"42\") will store an I64 equal to 42 in jsonDoc.data. If the programmer wants to treat jsonDoc.data as an I64 then they can get an I64 reference to the data by using jsonDoc.data as I64.\nIn the following program, the command line arguments are parsed as Json. A running sum is kept of all of the arguments that can be parsed as I64 numbers, and all other arguments are ignored.\nuse \"json\" actor Main new create(env: Env) =\u003e var jsonSum: I64 = 0 let jd: JsonDoc = JsonDoc for arg in env.args.slice(1).values() do try jd.parse(arg)? jsonSum = jsonSum + (jd.data as I64) end end env.out.print(jsonSum.string()) When run with the arguments 2 and 4 et 7 y 15, the program’s output is 28.\nThe same thing can be done with interfaces, using as to create a reference to a more specific interface or class. Let’s say, for example, that you have a library for doing things with furry, rodent-like creatures. It provides a Critter interface which programmers can then use to create specific types of critters.\ninterface Critter fun wash(): String The programmer uses this library to create a Wombat and a Capybara class. But the Capybara class provides a new method, swim(), that is not part of the Critter class. The programmer wants to store all of the critters in an array, in order to carry out actions on groups of critters. Now assume that when capybaras finish washing they want to go for a swim. The programmer can accomplish that by using as to attempt to use each Critter object in the Array[Critter] as a Capybara. If this fails because the Critter is not a Capybara, then an error is raised; the program can swallow this error and go on to the next item.\ninterface Critter fun wash(): String class Wombat is Critter fun wash(): String =\u003e \"I'm a clean wombat!\" class Capybara is Critter fun wash(): String =\u003e \"I feel squeaky clean!\" fun swim(): String =\u003e \"I'm swimming like a fish!\" actor Main new create(env: Env) =\u003e let critters = Array[Critter].\u003epush(Wombat).\u003epush(Capybara) for critter in critters.values() do env.out.print(critter.wash()) try env.out.print((critter as Capybara).swim()) end end Specify the type of items in an array literal The as operator can be used to tell the compiler what type to use for the items in an array literal. In many cases, the compiler can infer the type, but sometimes it is ambiguous.\nFor example, in the case of the following program, the method foo can take either an Array[U32] ref or an Array[U64] ref as an argument. If a literal array is passed as an argument to the method and no type is specified then the compiler cannot deduce the correct one because there are two equally valid ones.\nactor Main fun foo(xs: (Array[U32] ref | Array[U64] ref)): Bool =\u003e // do something boring here true new create(env: Env) =\u003e foo([as U32: 1; 2; 3]) // the compiler would complain about this: // foo([1; 2; 3]) The requested type must be a valid type for the items in the array. Since these types are checked at compile time they are guaranteed to work, so there is no need for the programmer to handle an error condition.\n","summary":"The as operator in Pony has two related uses. First, it provides a safe way to increase the specificity of an object’s type (casting). Second, it gives the programmer a way to specify the type of the items in an array literal.\nSafely converting to a more specific type (casting) The as operator can be used to create a reference to an object with a more specific type than the given reference, if possible.","title":"as操作符（As Operator）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/as.html"},{"content":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony. A Jump Consistent Hash, for example, could be provided in pure Pony as follows:\n// Jump consistent hashing in Pony, with an inline pseudo random generator fun jch(key: U64, buckets: I64): I32 =\u003e var k = key var b = I64(0) var j = I64(0) while j \u003c buckets do b = j k = (k * 2862933555777941757) + 1 j = ((b + 1).f64() * (U32(1 \u003c\u003c 31).f64() / ((key \u003e\u003e 33) + 1).f64())).i64() end b.i32() Let’s say we wish to compare the pure Pony performance to an existing C function with the following header:\n#ifndef __JCH_H_ #define __JCH_H_  extern \"C\" { int32_t jch_chash(uint64_t key, uint32_t num_buckets); } #endif Note the use of extern \"C\". If the library is built as C++ then we need to tell the compiler not to mangle the function name, otherwise, Pony won’t be able to find it. For libraries built as C, this is not needed, of course.\nThe implemented would be something like:\n#include \u003cstdint.h\u003e#include \u003climits.h\u003e#include \"math.h\" // A reasonably fast, good period, low memory use, xorshift64* based prng double lcg_next(uint64_t* x) { *x ^= *x \u003e\u003e 12; *x ^= *x \u003c\u003c 25; *x ^= *x \u003e\u003e 27; return (double)(*x * 2685821657736338717LL) / ULONG_MAX; } // Jump consistent hash int32_t jch_chash(uint64_t key, uint32_t num_buckets) { uint64_t seed = key; int b = -1; int32_t j = 0; do { b = j; double r = lcg_next(\u0026seed); j = floor((b + 1)/r); } while(j \u003c num_buckets); return (int32_t)b; } We need to compile the native code to a shared library. This example is for OSX. The exact details may vary on other platforms.\nclang -fPIC -Wall -Wextra -O3 -g -MM jch.c \u003ejch.d clang -fPIC -Wall -Wextra -O3 -g -c -o jch.o jch.c clang -shared -lm -o libjch.dylib jch.o The Pony code to use this new C library is just like the code we’ve already seen for using C libraries.\n\"\"\" This is an example of Pony integrating with native code via the built-in FFI support \"\"\" use \"lib:jch\" use \"collections\" use \"random\" use @jch_chash[I32](hash: U64, bucket_size: U32) actor Main var _env: Env new create(env: Env) =\u003e _env = env let bucket_size: U32 = 1000000 var random = MT for i in Range[U64](1, 20) do let r: U64 = random.next() let hash = @jch_chash(i, bucket_size) _env.out.print(i.string() + \": \" + hash.string()) end We can now use ponyc to compile a native executable integrating Pony and our C library. And that’s all we need to do.\n","summary":"The FFI support in Pony uses the C application binary interface (ABI) to interface with native code. The C ABI is a calling convention, one of many, that allow objects from different programming languages to be used together.\nWriting a C library for Pony Writing your own C library for use by Pony is almost as easy as using existing libraries.\nLet’s look at a complete example of a C function we may wish to provide to Pony.","title":"C ABI","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/c-abi.html"},{"content":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.\nBare functions Classic Pony functions have a receiver, which acts as an implicit argument to the function. Because of this, classic functions can’t be used as callbacks with many C APIs. Instead, you can use bare functions, which are functions with no receiver.\nYou can define a bare function by prefixing the function name with the @ symbol.\nclass C fun @callback() =\u003e ... The function can then be passed as a callback to a C API with the addressof operator.\n@setup_callback(addressof C.callback) Note that it is possible to use an object reference instead of a type as the left-hand side of the method access.\nSince bare methods have no receiver, they cannot reference the this identifier in their body (either explicitly or implicitly through field access), cannot use this viewpoint adapted types, and cannot specify a receiver capability.\nBare lambdas Bare lambdas are special lambdas defining bare functions. A bare lambda or bare lambda type is specified using the same syntax as other lambda types, with the small variation that it is prefixed with the @ symbol. The underlying value of a bare lambda is equivalent to a C function pointer, which means that a bare lambda can be directly passed as a callback to a C function. The partial application of a bare method yields a bare lambda.\nlet callback = @{() =\u003e ... } @setup_callback(callback) Bare lambdas can also be used to define structures containing function pointers. For example:\nstruct S var fun_ptr: @{()} This Pony structure is equivalent to the following C structure:\nstruct S { void(*fun_ptr)(); }; In the same vein as bare functions, bare lambdas cannot specify captures, cannot use this neither as an identifier nor as a type, and cannot specify a receiver capability. In addition, a bare lambda object always has a val capability.\nClassic lambda types and bare lambda types can never be subtypes of each other.\nAn example Consider SQLite, mentioned earlier. When the client code calls sqlite3_exec, an SQL query is executed against a database, and the callback function is called for each row returned by the SQL statement. Here’s the signature for sqlite3_exec:\ntypedef int (*sqlite3_callback)(void*,int,char**, char**); ... SQLITE_API int SQLITE_STDCALL sqlite3_exec( sqlite3 *db, /* The database on which the SQL executes */ const char *zSql, /* The SQL to be executed */ sqlite3_callback xCallback, /* Invoke this callback routine */ void *pArg, /* First argument to xCallback() */ char **pzErrMsg /* Write error messages here */ ) { ... xCallback(pArg, nCol, azVals, azCols) ... } sqlite3_callback is the type of the callback function that will be called by sqlite3_exec for each row returned by the sql statement. The first argument to the callback function is the pointer pArg that was passed to sqlite3_exec, the second argument is the number of columns in the row being processed, the third argument is data for each column, and the fourth argument is the name of each column.\nHere’s the skeleton of some Pony code that uses sqlite3_exec to query an SQLite database, with examples of both the bare method way and the bare lambda way:\nclass SQLiteClient fun client_code() =\u003e ... @sqlite3_exec[I32](db, sql.cstring(), addressof this.method_callback, this, addressof zErrMsg) ... fun @method_callback(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... class SQLiteClient fun client_code() =\u003e ... let lambda_callback = @{(client: SQLiteClient, argc: I32, argv: Pointer[Pointer[U8]], azColName: Pointer[Pointer[U8]]): I32 =\u003e ... } @sqlite3_exec[I32](db, sql.cstring(), lambda_callback, this, addressof zErrMsg) ... Focusing on the callback-related parts, the callback function is passed using addressof this.method_callback (resp. by directly passing the bare lambda) as the third argument to sqlite3_exec. The fourth argument is this, which will end up being the first argument when the callback function is called. The callback function is called in sqlite3_exec by the call to xCallback.\n","summary":"Some C APIs let the programmer specify functions that should be called to do pieces of work. For example, the SQLite API has a function called sqlite3_exec that executes an SQL statement and calls a function given by the programmer on each row returned by that statement. The functions that are supplied by the programmer are known as “callback functions”. Some specific Pony functions can be passed as callback functions.","title":"Callbacks","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/callbacks.html"},{"content":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call. Any time you see an @ in Pony there’s an FFI going on.\nThe other key difference is that the return type of the function is specified after the function name, in square brackets. This is because the compiler needs to know what type the value returned is (if any), but has no way to determine that, so it needs you to explicitly tell it.\nThere are a few unusual things going on with the arguments to this FFI call as well. For the second argument, for which we’re passing the value 1, we’ve had to specify that this is a U64. Again this is because the compiler needs to know what size argument to use, but has no way to determine this.\nSafely does it It is VERY important that when calling FFI functions you MUST get the parameter and return types right. The compiler has no way to know what the native code expects and will just believe whatever you do. Errors here can cause invalid data to be passed to the FFI function or returned to Pony, which can lead to program crashes.\nTo help avoid bugs here Pony allows you to specify the type signatures of FFI functions in advance. Whilst you must still get the types correct the arguments you provide at each FFI call site are checked against the declared signature. This means that you must get a type wrong, in the same way, in at least 2 places for a bug to exist. This won’t help if the argument types the native code expects are different to what you think they are, but it will protect you against trivial mistakes and simple typos.\nFFI signatures are declared using the use command. Here’s an example from the standard library:\nuse @SSL_CTX_ctrl[I32](ctx: Pointer[_SSLContext] tag, op: I32, arg: I32, parg: Pointer[U8] tag) if windows use @SSL_CTX_ctrl[I64](ctx: Pointer[_SSLContext] tag, op: I32, arg: I64, parg: Pointer[U8] tag) if not windows class SSLContext val new create() =\u003e // set SSL_OP_NO_SSLv2 @SSL_CTX_ctrl(_ctx, 32, 0x01000000, Pointer[U8]) The @ symbol tells us that the use command is an FFI signature declaration. The types specified here are considered authoritative and any FFI calls that differ are considered to be an error.\nNote that we no longer need to specify the return type at the call site, since the signature declaration has already told us what it is. However, it is perfectly acceptable to specify it again if you want to.\nThe use @ command can take a condition just like other use commands. This is useful in this case, where the Windows version of SSL_CTX_ctrl has a slightly different signature to other platforms.\nC types Many C functions require types that don’t have an exact equivalent in Pony. A variety of features is provided for these.\nFor FFI functions that have no return value (ie they return void in C) the return value specified should be [None].\nIn Pony String is an object with a header and fields, but in C a char* is simply a pointer to character data. The .cstring() function on String provides us with a valid pointer to hand to C. Our fwrite example above makes use of this for the first argument.\nPony classes correspond directly to pointers to the class in C.\nFor C pointers to simple types, such as U64, the Pony Pointer[] polymorphic type should be used, with a tag reference capability. Pointer[U8] tag should be used for void*. This can be seen in our SSL_CTX_ctrl example above.\nTo pass pointers to values to C the addressof operator can be used (previously \u0026), just like taking an address in C. This is done in the standard library to pass the address of a U64 to an FFI function that takes a uint64_t* as an out parameter:\nvar len = U64(0) @pcre2_substring_length_bynumber_8[I32](_match, i.u32(), addressof len) Get and Pass Pointers to FFI To pass and receive pointers to c structs you need to declare pointer to primitives\nprimitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Read Struct Values from FFI A common pattern in C is to pass a struct pointer to a function, and that function will fill in various values in the struct. To do this in Pony, you make a struct and then use a NullablePointer:\nstruct Winsize var height: U16 = 0 var width: U16 = 0 new create() =\u003e None let size = Winsize @ioctl(0, 21523, NullablePointer[Winsize](size)) env.out.print(size.height.string()) FFI functions raising errors FFI functions can raise Pony errors. Functions in existing C libraries are very unlikely to do this, but support libraries specifically written for use with Pony may well do.\nFFI calls to functions that might raise an error must mark it as such by adding a ? after the arguments. For example:\n@os_send[U64](_event, data.cstring(), data.size()) ? // May raise an error If a signature declaration is used then that must be marked as possibly raising an error in the same way. The FFI call site must mark it as well.\nuse @os_send[U64](ev: Event, buf: Pointer[U8] tag, len: U64) ? @os_send(_event, data.cstring(), data.size())? // May raise an error ","summary":"FFI is built into Pony and native libraries may be directly referenced in Pony code. There is no need to code or configure bindings, wrappers or interfaces.\nHere’s an example of an FFI call in Pony from the standard library. It looks like a normal method call, with just a few differences:\n@fwrite[U64](data.cstring(), U64(1), data.size(), _handle) The main difference is the @ symbol before the function name. This is what tells us it’s an FFI call.","title":"Calling C from Pony","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/calling-c.html"},{"content":"","summary":"","title":"Categories","uri":"https://damon-kwok.github.io/pony-tutorial/categories.html"},{"content":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g. With -l you can generate a C library, lib\u003cdirectory\u003e.\n--debug will skip the LLVM optimizations passes. This should not be mixed up with make config=debug, the default make configuration target. config=debug will create DWARF symbols, and add slower assertions to ponyc, but not to the generated binaries. For those, you can omit DWARF symbols with the --strip or -s option.\n--path or -p take a : separated path list as the argument and adds those to the compile-time library paths for the linker to find source packages and the native libraries, static or dynamic, being linked at compile-time or via the FFI at run-time. The system adds several paths already, e.g. on windows it queries the registry to find the compiler run-time paths, you can also use use \"lib:path\" statements in the source code and as a final possibility, you can add -p paths. But if you want the generated binary to accept such a path to find a dynamic library on your client system, you need to handle that in your source code by yourself. See the options package for this.\n--output or -o takes a directory name where the final binary is created.\n--docs or -g creates a directory of the package with documentation in readthedocs.org format, i.e. markdown with nice navigation.\nLet’s study the documentation of the builtin stdlib:\npip install mkdocs ponyc packages/stdlib --docs \u0026\u0026 cd stdlib-docs \u0026\u0026 mkdocs serve And point your web browser to http://127.0.0.1:8000 serving a live-reloading local version of the docs.\nNote that there is no built-in debugger to interactively step through your program and interpret the results. But ponyc creates proper DWARF symbols and you can step through your programs with a conventional debugger, such as GDB or LLDB.\nRuntime options for Pony programs Besides using the cli package, there are also several built-in options for the generated binary (not for use with ponyc) starting with --pony*, see ponyc --help, to tweak runtime performance. You can override the number of initial threads, tune cycle detection (CD), the garbage collector and even turn off yield, which is not really recommended.\n","summary":"ponyc, the compiler, is usually called in the project directory, where it finds the .pony files and its dependencies automatically. There it will create the binary based on the directory name. You can override this and tune the compilation with several options as described via ponyc --help and you can pass a separate source directory as an argument.\nponyc [OPTIONS] \u003cpackage directory\u003e The most useful options are --debug, --path or just -p, --output or just -o and --docs or -g.","title":"Compiler Arguments","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/compiler-args.html"},{"content":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero. That’s right,\nlet x = I64(1) / I64(0) results in 0 being assigned to x. Baffling right? Well, yes and no. From a mathematical standpoint, it is very much baffling. From a practical standpoint, it is very much not.\nWhile Pony has Partial division:\nlet x = try I64(1) /? I64(0) else // handle division by zero end Defining division as partial leads to code littered with trys attempting to deal with the possibility of division by zero. Even if you had asserted that your denominator was not zero, you’d still need to protect against divide by zero because, at this time, the compiler can’t detect that value dependend typing.\nPony also offers Unsafe Division, which declares division by zero as undefined, as in C:\n// the value of x is undefined let x = I64(1) /~ I64(0) But declaring this case as undefined does not help us out here. As a programmer you’d still need to guard that case in order to not poison your program with undefined values or risking terminating your program with a SIGFPE. So, in order to maintain a practical API and avoid undefined behaviour, normal division on integers in Pony is defined to be 0. To avoid 0s silently creeping through your divisions, use Partial or Checked Division.\nDivide by zero on floating points In conformance with IEEE 754, floating point division by zero results in inf or -inf, depending on the sign of the numerator.\nIf you can assert that your denominator cannot be 0, it is possible to use Unsafe Division to gain some performance:\nlet x = F64(1.5) /~ F64(0.5) ","summary":"What’s 1 divided by 0? How about 10 divided by 0? What is the result you get in your favorite programming language?\nIn math, divide by zero is undefined. There is no answer to that question as the expression 1/0 has no meaning. In many programming languages, the answer is a runtime exception that the user has to handle. In Pony, things are a bit different.\nDivide by zero in Pony In Pony, integer division by zero results in zero.","title":"Divide by Zero","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/divide-by-zero.html"},{"content":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().values() do end Read struct values from FFI If you have a C struct which returns a struct with data like this\ntypedef struct { uint8_t code; float x; float y; } EGLEvent; EGLEvent getEvent() { EGLEvent e = {1, ev.xconfigure.width, ev.xconfigure.height}; return e; } the you can destructure it and get the values using a tuple\ntype EGLEvent is (U8, F32, F32) (var code, var x, var y) = @getEvent[EGLEvent]() Get and pass pointers to FFI primitive _XDisplayHandle primitive _EGLDisplayHandle let x_dpy = @XOpenDisplay[Pointer[_XDisplayHandle]](U32(0)) if x_dpy.is_null() then env.out.print(\"XOpenDisplay failed\") end let e_dpy = @eglGetDisplay[Pointer[_EGLDisplayHandle]](x_dpy) if e_dpy.is_null() then env.out.print(\"eglGetDisplay failed\") end Pass an Array of values to FFI (TODO) primitive _EGLConfigHandle let a = Array[U16](8) a.push(0x3040) a.push(0x4) a.push(0x3033) a.push(0x4) a.push(0x3022) a.push(0x8) a.push(0x3023) a.push(0x8) a.push(0x3024) let config = Pointer[_EGLConfigHandle] if @eglChooseConfig[U32](e_dpy, a, config, U32(1), Pointer[U32]) == 0 then env.out.print(\"eglChooseConfig failed\") end How to access command line arguments actor Main new create(env: Env) =\u003e // The no of arguments env.out.print(env.args.size().string()) for value in env.args.values() do env.out.print(value) end // Access the arguments the first one will always be the application name try env.out.print(env.args(0)?) end How to use cli to parse command line arguments use \"cli\" actor Main new create(env: Env) =\u003e let command_spec = try CommandSpec.leaf( \"pony-embed\", \"sample program\", [ OptionSpec.string(\"output\", \"output filename\", 'o') ], [ ArgSpec.string(\"input\", \"source of input\" where default' = \"-\") ] )? .\u003e add_help()? else env.exitcode(1) return end let command = match CommandParser(command_spec).parse(env.args, env.vars) | let c: Command =\u003e c | let ch: CommandHelp =\u003e ch.print_help(env.out) env.exitcode(0) return | let se: SyntaxError =\u003e env.err.print(se.string()) env.exitcode(1) return end let input_source = command.arg(\"input\").string() let output_filename = command.option(\"output\").string() env.out.print(\"Loading data from \" + input_source + \". Writing output to \" + output_filename) // ... How to write tests Just create a test.pony file\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAddition) class iso _TestAddition is UnitTest \"\"\" Adding 2 numbers \"\"\" fun name(): String =\u003e \"u32/add\" fun apply(h: TestHelper): TestResult =\u003e h.expect_eq[U32](2 + 2, 4) Some assertions you can make with the TestHelper are\nfun tag log(msg: String, verbose: Bool = false) be fail() =\u003e be assert_failed(msg: String) =\u003e fun tag assert_true(actual: Bool, msg: String = \"\") ? fun tag expect_true(actual: Bool, msg: String = \"\"): Bool fun tag assert_false(actual: Bool, msg: String = \"\") ? fun tag expect_false(actual: Bool, msg: String = \"\"): Bool fun tag assert_error(test: ITest, msg: String = \"\") ? fun tag expect_error(test: ITest box, msg: String = \"\"): Bool fun tag assert_is (expect: Any, actual: Any, msg: String = \"\") ? fun tag expect_is (expect: Any, actual: Any, msg: String = \"\"): Bool fun tag assert_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\") ? fun tag expect_eq[A: (Equatable[A] #read \u0026 Stringable)] (expect: A, actual: A, msg: String = \"\"): Bool Operator overloading (easy for copy and paste) fun add(other: A): A fun sub(other: A): A fun mul(other: A): A fun div(other: A): A fun rem(other: A): A fun mod(other: A): A fun eq(other: A): Bool fun ne(other: A): Bool fun lt(other: A): Bool fun le(other: A): Bool fun ge(other: A): Bool fun gt(other: A): Bool fun shl(other: A): A fun shr(other: A): A fun op_and(other:A): A fun op_or(other: A): A fun op_xor(othr: A): A Create empty functions in a class class Test fun alpha() =\u003e \"\"\" \"\"\" fun beta() =\u003e \"\"\" \"\"\" How to create Arrays with values Single values can be separated by semicolon or newline.\nlet dice: Array[U32] = [1; 2; 3 4 5 6 ] How to modify a lexically captured variable in a closure actor Main fun foo(n:U32): {ref(U32): U32} =\u003e var s: Array[U32] = Array[U32].init(n, 1) {ref(i:U32)(s): U32 =\u003e try s(0) = s(0) + i s(0) else 0 end } new create(env:Env) =\u003e var f = foo(5) env.out.print(f(10).string()) env.out.print(f(20).string()) ","summary":"Small how do I examples for Pony. These will eventually find another home. Until then, they live here.\nEnum with values primitive Black fun apply(): U32 =\u003e 0xFF000000 primitive Red fun apply(): U32 =\u003e 0xFFFF0000 Enum with values with namespace primitive Colours fun black(): U32 =\u003e 0xFF000000 fun red(): U32 =\u003e 0xFFFF0000 Enum which can be iterated primitive Black primitive Blue primitive Red primitive Yellow type Colour is (Black | Blue | Red | Yellow) primitive ColourList fun tag apply(): Array[Colour] =\u003e [Black; Blue; Red; Yellow] for colour in ColourList().","title":"Examples","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/examples.html"},{"content":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver. The use of assignment expressions like x = 42 is quite rare so we don’t think many folks will be bitten by this. However, it’s definitely something you want to be aware of. Also remember that if fn were to be called, it would be called with 0 (the result of the assignment expression).\n","summary":"Consider the following code:\nclass Foo fun fn(x: U64) =\u003e None actor Main new create(env: Env) =\u003e var x: U64 = 0 try foo()?.fn(x = 42) end env.out.print(x.string()) fun foo(): Foo ? =\u003e error What do you think it will print? Probably 0 right? Or maybe you realized this code is in the gotchas section so it must be 42. If you went with 42, you’d be right. Why?\nExpressions for arguments in function calls are evaluated before the expression for the function receiver.","title":"Function Call Side Effects","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/side-effect-ordering-in-function-call-expressions.html"},{"content":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up. This sucks if you want predictable completion of sections of code. Most of the time, your function will finish in less than a millisecond but every now and then, its paused during execution to GC. There are advantages to this approach. Whenever you run low on memory, the GC can attempt to free some memory and get you more. In general, this is how people expect Pony’s garbage collector to work. As you might guess though, it doesn’t work that way.\nGarbage Collection in Pony Garbage collection is never attempted on any actor while it is executing a behavior. This gives you very predictable performance when executing behaviors but also makes it easy to grab way more memory than you intend to. Let’s take a look at how that can happen via the “long-running behavior problem”.\nLong running behaviors and memory Here’s a typical “I’m learning Pony” program:\nactor Main new create(env: Env) for i in Range(1, 2_000_000) do ... something that uses up heap ... end This program will never garbage collect before exiting. create is run as a behavior on actors which means that no garbage collection will occur while it’s running. Long loops in behaviors are a good way to exhaust memory. Don’t do it. If you want to execute something in such a fashion, use a Timer.\n","summary":"There’s a common GC anti-pattern that many new Pony programmers accidentally stumble across. Usually, this results in a skyrocketing memory usage in their test program and questions on Zulip as to why Pony isn’t working correctly. It is, in fact, working correctly, albeit not obviously.\nGarbage Collection in the world at large Garbage collection, in most languages, can run at any time. Your program can be paused so that memory can be freed up.","title":"Garbage Collection","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/garbage-collection.html"},{"content":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.\nPony-ORCA, yes the killer whale, is based on ideas from ownership and deferred, distributed, weighted reference counting. It adapts messaging systems of actors to keep the reference count consistent. The main challenges in concurrent garbage collection are the detection of cycles of sleeping actors in the actor’s graph, in the presence of the concurrent mutation of this graph. With message passing, you get deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph).\n  Soundness: the technique collects only dead actors.\n  Completeness: the technique collects all dead actors eventually.\n  Concurrency: the technique does not require a stop-the-world step, clocks, time stamps, versioning, thread coordination, actor introspection, shared memory, read/write barriers or cache coherency.\n  The type system ensures at compile time that your program can never have data races. It’s deadlock free… Because Pony has no locks!\nWhen an actor has completed local execution and has no pending messages on its queue, it is blocked. An actor is dead, if it is blocked and all actors that have a reference to it are blocked, transitively. A collection of dead actors depends on being able to collect closed cycles of blocked actors.\nThe Pony type system guarantees race and deadlock free concurrency and soundness by adhering to the following principles:\nPony-ORCA characteristics   An actor may perform garbage collection concurrently with other actors while they are executing any kind of behaviour.\n  An actor may decide whether to garbage collect an object solely based on its own local state, without consultation with or inspecting the state of any other actor.\n  No synchronization between actors is required during garbage collection, other than potential message sends.\n  An actor may garbage collect between its normal behaviours, i.e. it need not wait until its message queue is empty.\n  Pony-ORCA can be applied to several other programming languages, provided that they satisfy the following two requirements:\n  Actor behaviours are atomic.\n  Message delivery is causal. Causal: messages arrive before any messages they may have caused if they have the same destination. So there needs to be some kind of causal ordering guarantee, but fewer requirements than with comparable concurrent, fast garbage collectors.\n    ","summary":"Pony-ORCA is a fully concurrent protocol for garbage collection in the actor paradigm. It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems. It does not require any form of synchronization across actors except those introduced through the actor paradigm, i.e. message send and message receive.","title":"Garbage Collection with Pony-ORCA","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/garbage-collection.html"},{"content":"你已经成功的安装了Pony编译器，我们来写点代码吧！我们从输出\"hello,world!“开始。首先n欻关键一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 代码 Then, create a file in that directory called main.pony. 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件中敲入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 运行程序 现在可以运行程序了：\n$ ./helloworld Hello, world! 恭喜，你已经完成了第一个Pony程序！下一节我们会讲解这几行代码的含义。\n","summary":"你已经成功的安装了Pony编译器，我们来写点代码吧！我们从输出\"hello,world!“开始。首先n欻关键一个目录：helloworld：\n$ mkdir helloworld $ cd helloworld 代码 Then, create a file in that directory called main.pony. 然后用你的文本编辑器在这个目录中新建一个文件：main.pony。\n文件中敲入下面的代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 编译程序 现在可以编译程序了：\n$ ponyc Building . Building builtin Generating Optimising Writing ./helloworld.o Linking ./helloworld 运行程序 现在可以运行程序了：\n$ ./helloworld Hello, world! 恭喜，你已经完成了第一个Pony程序！下一节我们会讲解这几行代码的含义。","title":"Hello World","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/hello-world.html"},{"content":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.   do loop statement, or after a with statement   else conditional statement in if, for, while, repeat, try (as a catch block), match   elseif conditional statement, also used with ifdef   embed embed a class as a field of another class   end ending of: if then, ifdef, while do, for in, repeat until, try, object, lambda, recover, match   error raises an error   for loop statement   fun define a function, executed synchronously   if (1) conditional statement    (2) to define a guard in a pattern match   ifdef when defining a build flag at compile time: ponyc –D “foo”   in used in a for in - loop statement   interface used in structural subtyping   is (1) used in nominal subtyping    (2) in type aliasing    (3) identity comparison   isnt negative identity comparison   iso reference capability – read and write uniqueness   lambda to make a closure   let declaration of immutable variable: you can’t rebind this name to a new value   match pattern matching   new constructor   not logical negation   object to make an object literal   primitive declares a primitive type   recover removes the reference capability of a variable   ref reference capability – object (on which function is called) is mutable   repeat loop statement   return to return early from a function   tag reference capability – neither readable nor writeable, only object identity   then (1) in if conditional statement    (2) as a (finally) block in try   this the current object   trait used in nominal subtyping: class Foo is TraitName   trn reference capability – write uniqueness, no other actor can write to the object   try error handling   type to declare a type alias   until loop statement   use (1) using a package    (2) using an external library foo: use “lib:foo”    (3) declaration of an FFI signature    (4) add a search path for external libraries: use “path:/usr/local/lib”   var declaration of mutable variable: you can rebind this name to a new value   val reference capability – globally immutable object   where when specifying named arguments   while loop statement   with ensure disposal of an object    ","summary":"This listing explains the usage of every Pony keyword.\n   Keyword Usage     actor defines an actor   as conversion of a value to another Type (can raise an error)   be behavior, executed asynchronously   box default reference capability – object is readable, but not writable   break to step out of a loop statement   class defines a class   compile_error will provoke a compile error   compile_intrinsic implementation is written in C and not available as Pony code   continue continues a loop with the next iteration   consume move a value to a new variable, leaving the original variable empty   digestof create a USize value that summarizes the Pony object, similar to a Java object’s hashCode() value.","title":"Keywords","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/keywords.html"},{"content":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.\nCompatible type: Two types are compatible if there can be any single object which is an instance of both types. Note that a suitable type for the single object does not have to have been defined, as long as it could be. For example, any two traits are compatible because a class could be defined that provides both of them, even if such a class has not been defined. Conversely, no two classes can ever be compatible because no object can be an instance of both.\nCompound type: A type combining multiple other types, ie union, intersection, and tuple. Opposite of a single type.\nConcrete type: An actor, class or primitive.\nCurly brackets: { }. Synonymous with braces.\nDeclaration and definition: synonyms for each other, we do not draw the C distinction between forward declarations and full definitions.\nDefault method body: Method body defined in a trait and optionally used by concrete types.\nEntity: Top level definition within a file, ie alias, trait, actor, class, primitive.\nExplicit type: An actor, class or primitive.\nMember: Method or field.\nMethod: Something callable on a concrete type/object. Function, behaviour or constructor.\nOverride: When a concrete type has its own body for a method with a default body provided by a trait.\nParentheses: ( ). Synonymous with round brackets.\nProvide: An entity’s usage of traits and the methods they contain. Equivalent to implements or inherits from.\nRound brackets: ( ). Synonymous with parentheses.\nSingle type: Any type which is not defined as a collection of other types. Actors, classes, primitives, traits and structural types are all single types. Opposite of a compound type.\nSquare brackets: [ ]\nTrait clash: A trait clashes with another type if it contains a method with the same name, but incompatible signature as a method in the other type. A clashing trait is incompatible with the other type. Traits can clash with actors, classes, primitives, intersections, structural types and other traits.\n","summary":"Words are hard. We can all be saying the same thing but do we mean the same thing? It’s tough to know. Hopefully, this lexicon helps a little.\nTerminology Braces: { }. Synonymous with curly brackets.\nBrackets: This term is ambiguous. In the UK it usually means ( ) in the US is usually means [ ]. It should, therefore, be avoided for use for either of these. Can be used as a general term for any unspecified grouping punctuation, including { }.","title":"Lexicon","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/lexicon.html"},{"content":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified. This is particularly useful when the library has slightly different names on different platforms.\nHere’s a real example from the standard library:\nuse \"path:/usr/local/opt/libressl/lib\" if osx use \"lib:ssl\" if not windows use \"lib:crypto\" if not windows use \"lib:libssl-32\" if windows use \"lib:libcrypto-32\" if windows primitive _SSLInit \"\"\" This initialises SSL when the program begins. \"\"\" fun _init() =\u003e @SSL_load_error_strings[None]() @SSL_library_init[I32]() On Windows, we use the libraries “libssl-32” and “libcrypto-32” and on other platforms we use “ssl” and “crypto”. These contain the FFI functions SSL_library_init and SSL_load_error_strings (amongst others).\nBy default the Pony compiler will look for the libraries to link in the standard places, however, that is defined on the build platform. However, it may be necessary to look in extra places. The use \"path:...\" command allows this. The specified path is added to the library search paths for the remainder of the current file. The example above uses this to add the path “/usr/local/opt/libressl/lib” for OSX. This is required because the library is provided by brew, which installs things outside the standard library search paths.\nIf you are integrating with existing libraries, that is all you need to do.\n","summary":"If Pony code calls FFI functions, then those functions, or rather the libraries containing them, must be linked into the Pony program.\nUse for external libraries To link an external library to Pony code another variant of the use command is used. The “lib” specifier is used to tell the compiler you want to link to a library. For example:\nuse \"lib:foo\" As with other use commands a condition may be specified.","title":"Linking to C Libraries","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi/linking-c.html"},{"content":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory). You can have millions of actors at the same time.  But Caveat Emptor But Pony can be used to create C libraries and Pony can use external C libraries via the FFI which does not have this luxury.\nSo you can use any external C library out there, but the question is if you need to and if you should.\nThe biggest problem is external heap memory, created by an external FFI call, or created to support an external call. But external stack space might also need some thoughts, esp. when being created from actors.\nPony does have finalisers (callbacks which are called by the garbage collector which may be used to free resources allocated by an FFI call); However, the garbage collector is not timely (as with pure reference counting), it is not triggered immediately when some object goes out of scope.\nA blocked actor will keep its memory allocated, only a dead actor will release it eventually.\nAnd, long-running actors Might cause unexpected out of memory errors, since the GC is not yet triggered on an out-of-memory segfault or stack exhaustion.\n…\n","summary":"Pony is a null-free, type-safe language, with no dangling pointers, no buffer overruns, but with a very fast garbage collector, so you don’t have to worry about explicit memory allocation, if on the heap or stack, if in a threaded actor, or not.\nFast, Safe and Cheap  An actor has ~240 bytes of memory overhead. No locks. No context switches. All mutation is local. An idle actor consumes no resources (other than memory).","title":"Memory Allocation at Runtime","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/memory-allocation.html"},{"content":"Sometimes it’s really convenient to be able to write a whole object inline. In Pony, this is called an object literal, and it does pretty much exactly what an object literal in JavaScript does: it creates an object that you can use immediately.\nBut Pony is statically typed, so an object literal also creates an anonymous type that the object literal fulfills. This is similar to anonymous classes in Java and C#. In Pony, an anonymous type can provide any number of traits and interfaces.\nWhat’s this look like, then? It basically looks like any other type definition, but with some small differences. Here’s a simple one:\nobject fun apply(): String =\u003e \"hi\" end Ok, that’s pretty trivial. Let’s extend it so that it explicitly provides an interface so that the compiler will make sure the anonymous type fulfills that interface. You can use the same notation to provide traits as well.\nobject is Hashable fun apply(): String =\u003e \"hi\" fun hash(): USize =\u003e this().hash() end What we can’t do is specify constructors in an object literal, because the literal is the constructor. So how do we assign to fields? Well, we just assign to them. For example:\nuse \"collections\" class Foo fun foo(str: String): Hashable =\u003e object is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end When we assign to a field in the constructor, we are capturing from the lexical scope the object literal is in. Pretty fun stuff! It lets us have arbitrarily complex closures that can even have multiple entry points (i.e. functions you can call on a closure).\nAn object literal with fields is returned as a ref by default unless an explicit reference capability is declared by specifying the capability after the object keyword. For example, an object with sendable captured references can be declared as iso if needed:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable let s: String = str fun apply(): String =\u003e s fun hash(): USize =\u003e s.hash() end We can also implicitly capture values from the lexical scope by using them in the object literal. Sometimes values that aren’t local variables, aren’t fields, and aren’t parameters of a function are called free variables. By using them in a function, we are closing over them - that is, capturing them. The code above could be written without the field s:\nuse \"collections\" class Foo fun foo(str: String): Hashable iso^ =\u003e object iso is Hashable fun apply(): String =\u003e str fun hash(): USize =\u003e str.hash() end Lambdas Arbitrarily complex closures are nice, but sometimes we just want a simple closure. In Pony, you can use the lambdas for that. A lambda is written as a function (implicitly named apply) enclosed in curly brackets:\n{(s: String): String =\u003e \"lambda: \" + s } This produces the same code as:\nobject fun apply(s: String): String =\u003e \"lambda: \" + s end The reference capability of the lambda object can be declared by appending it after the closing curly bracket:\n{(s: String): String =\u003e \"lambda: \" + s } iso This produces the same code as:\nobject iso fun apply(s: String): String =\u003e \"lambda: \" + s end Lambdas can be used to capture from the lexical scope in the same way as object literals can assign from the lexical scope to a field. This is done by adding a second argument list after the parameters:\nclass Foo new create(env:Env) =\u003e foo({(s: String)(env) =\u003e env.out.print(s) }) fun foo(f: {(String)}) =\u003e f(\"Hello World\") It’s also possible to use a capture list to create new names for things. A capture list is a second parenthesised list after the parameters:\nnew create(env:Env) =\u003e foo({(s: String)(myenv = env) =\u003e myenv.out.print(s) }) The type of a lambda is also declared using curly brackets. Within the brackets, the function parameter types are specified within parentheses followed by an optional colon and return type. The example above uses {(String)} to be the type of a lambda function that takes a String as an argument and returns nothing.\nIf the lambda object is not declared with a specific reference capability, the reference capability is inferred from the structure of the lambda. If the lambda does not have any captured references, it will be val by default; if it does have captured references, it will be ref by default. The following is an example of a val lambda object:\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[U32] l.\u003epush(10).\u003epush(20).\u003epush(30).push(40) let r = reduce(l, 0, {(a:U32, b:U32): U32 =\u003e a + b }) env.out.print(\"Result: \" + r.string()) fun reduce(l: List[U32], acc: U32, f: {(U32, U32): U32} val): U32 =\u003e try let acc' = f(acc, l.shift()?) reduce(l, acc', f) else acc end The reduce method in this example requires the lambda type for the f parameter to require a reference capability of val. The lambda object passed in as an argument does not need to declare an explicit reference capability because val is the default for a lambda that does not capture anything.\nAs mentioned previously the lambda desugars to an object literal with an apply method. The reference capability for the apply method defaults to box like any other method. In a lambda that captures this needs to be ref if the function needs to modify any of the captured variables or call ref methods on them. The reference capability for the method (versus the reference capability for the object which was described above) is defined by putting the capability before the parenthesized argument list.\nuse \"collections\" actor Main new create(env:Env) =\u003e let l = List[String] l.\u003epush(\"hello\").push(\"world\") var count = U32(0) for_each(l, {ref(s:String) =\u003e env.out.print(s) count = count + 1 }) // Displays '0' as the count env.out.print(\"Count: \" + count.string()) fun for_each(l: List[String], f: {ref(String)} ref) =\u003e try f(l.shift()?) for_each(l, f) end This example declares the type of the apply function that is generated by the lambda expression as being ref. The lambda type declaration for the f parameter in the for_each method also declares it as ref. The reference capability of the lambda type must also be ref so that the method can be called. The lambda object does not need to declare an explicit reference capability because ref is the default for a lambda that has captures.\nThe above example also notes a subtle reality of captured references. At first glance one might expect count to have been incremented by the application of f. However, reassigning a reference, count = count + 1, inside a lambda or object literal can never cause a reassignment in the outer scope. If count were an object with reference capabilities permiting mutation, the captured reference could be modified with for example count.increment(). The resulting mutation would be visible to any location holding a reference to the same object as count.\nActor literals Normally, an object literal is an instance of an anonymous class. To make it an instance of an anonymous actor, just include one or more behaviours in the object literal definition.\nobject be apply() =\u003e env.out.print(\"hi\") end An actor literal is always returned as a tag.\nPrimitive literals When an anonymous type has no fields and no behaviours (like, for example, an object literal declared as a lambda literal), the compiler generates it as an anonymous primitive, unless a non-val reference capability is explicitly given. This means no memory allocation is needed to generate an instance of that type.\nIn other words, in Pony, a lambda that doesn’t close over anything has no memory allocation overhead. Nice.\nA primitive literal is always returned as a val.\n","summary":"Sometimes it’s really convenient to be able to write a whole object inline. In Pony, this is called an object literal, and it does pretty much exactly what an object literal in JavaScript does: it creates an object that you can use immediately.\nBut Pony is statically typed, so an object literal also creates an anonymous type that the object literal fulfills. This is similar to anonymous classes in Java and C#.","title":"object关键字（Object Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/object-literals.html"},{"content":"Partial application lets us supply some of the arguments to a constructor, function, or behaviour, and get back something that lets us supply the rest of the arguments later.\nA simple case A simple case is to create a “callback” function. For example:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) This is a bit of a silly example, but hopefully, the idea is clear. We partially apply the addmul function on foo, binding the receiver to foo and the add argument to 3. We get back an object, f, that has an apply method that takes a mul argument. When it’s called, it in turn calls foo.addmul(3, mul).\nWe can also bind all the arguments:\nlet f = foo~addmul(3, 4) f() Or even none of the arguments:\nlet f = foo~addmul() f(3, 4) Out of order arguments Partial application with named arguments allows binding arguments in any order, not just left to right. For example:\nlet f = foo~addmul(where mul = 4) f(3) Here, we bound the mul argument but left add unbound.\nPartially applying a partial application Since partial application results in an object with an apply method, we can partially apply the result!\nlet f = foo~addmul() let f2 = f~apply(where mul = 4) f2(3) Partial application is an object literal Under the hood, we’re assembling an object literal for partial application. It captures some of the lexical scope as fields and has an apply method that takes some, possibly reduced, number of arguments. This is actually done as sugar, by rewriting the abstract syntax tree for partial application to be an object literal, before code generation.\nThat means partial application results in an anonymous class and returns a ref. If you need another reference capability, you can wrap partial application in a recover expression.\n","summary":"Partial application lets us supply some of the arguments to a constructor, function, or behaviour, and get back something that lets us supply the rest of the arguments later.\nA simple case A simple case is to create a “callback” function. For example:\nclass Foo var _f: F64 = 0 fun ref addmul(add: F64, mul: F64): F64 =\u003e _f = (_f + add) * mul class Bar fun apply() =\u003e let foo: Foo = Foo let f = foo~addmul(3) f(4) This is a bit of a silly example, but hopefully, the idea is clear.","title":"Partial Application","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/partial-application.html"},{"content":"Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.\nPassing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.\nBut what if we want to pass a mutable object from one actor to another? To do that, we need to be sure that the actor that is sending the mutable object also gives up the ability to both read from and write to that object.\nThis is exactly what iso does. It is read and write unique, there can only be one reference at a time that can be used for reading or writing. If you send an iso object to another actor, you will be giving up the ability to read from or write to that object.\nSo I should use iso when I want to pass a mutable object between actors? Yes! If you don’t need to pass it, you can just use ref instead.\nSharing If you want to share an object amongst actors, then we have to make one of the following guarantees:\n Either no actor can write to the object, in which case any actor can read from it, or Only one actor can write to the object, in which case other actors can neither read from or write to the object.  The first guarantee is exactly what val does. It is globally immutable, so we know that no actor can ever write to that object. As a result, you can freely send val objects to other actors, without needing to give up the ability to read from that object.\nSo I should use val when I want to share an immutable object amongst actors? Yes! If you don’t need to share it, you can just use ref instead, or box if you want it to be immutable.\nThe second guarantee is what tag does. Not the part about only one actor writing (that’s guaranteed by any mutable reference capability), but the part about not being able to read from or write to an object. That means you can freely pass tag objects to other actors, without needing to give up the ability to read from or write to that object.\nWhat’s the point in sending a tag reference to another actor if it can’t then read or write the fields? Because tag can be used to identify objects and sometimes that’s all you need. Also, if the object is an actor you can call behaviours on it even though you only have a tag.\nSo I should use tag when I want to share the identity of a mutable object amongst actors? Yes! Or, really, the identity of anything, whether it’s mutable, immutable, or even an actor.\nReference capabilities that can’t be sent You may have noticed we didn’t mention trn, ref, or box as things you can send to other actors. That’s because you can’t do it. They don’t make the guarantees we need in order to be safe.\nSo when should you use those reference capabilities?\n Use ref when you need to be able to change an object over time. On the other hand, if your program wouldn’t be any slower if you used an immutable type instead, you may want to use a val anyway. Use box when you don’t care whether the object is mutable or immutable. In other words, you want to be able to read it, but you don’t need to write to it or share it with other actors. Use trn when you want to be able to change an object for a while, but you also want to be able to make it globally immutable later.  ","summary":"Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.\nPassing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.","title":"Passing and Sharing References","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html"},{"content":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug\nThey can also use the operators and, or, xor and not. As with other expressions in Pony, parentheses must be used to indicate precedence if more than one of and, or and xor is used.\nAny use command whose condition evaluates to false is ignored.\n","summary":"The Pony libraries, of course, want to abstract platform differences. Sometimes you may want a use command that only works under certain circumstances, most commonly only on a particular OS or only for debug builds. You can do this by specifying a condition for a use command:\nuse \"foo\" if linux use \"bar\" if (windows and debug) Use conditions can use any of the methods defined in builtin/Platform as conditions. There are currently the following booleans defined: freebsd, linux, osx, posix =\u003e (freebsd or linux or osx), windows, x86, arm, lp64, llp64, ilp32, native128, debug","title":"Platform-dependent code","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/platform-dependent-code.html"},{"content":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running). For example, if using bash, add the following to your ~/.bashrc:\nexport PONYPATH=$PONYPATH:$HOME/pony (Then run source ~/.bashrc to add this variable to a running session. New terminal session will automatically source ~/.bashrc.)\nWindows  Create folder at C:\\Users\\\u003cyourusername\u003e\\pony. Right click on “Start” and click on “Control Panel”. Select “System and Security”, then click on “System”. From the menu on the left, select the “Advanced systems settings”. Click the “Environment Variables” button at the bottom. Click “New” from the “User variables” section. Type PONYPATH into the “Variable name” field. Type %PONYPATH%;%USERPROFILE%\\pony into the “Variable value” field. Click OK.  You can also add to PONYPATH from the command prompt via:\nsetx PONYPATH %PONYPATH%;%USERPROFILE%\\pony ","summary":"When searching for Pony packages, ponyc checks both the installation directory (where the standard libraries reside) and any directories listed in the optional environment variable PONYPATH.\nAdding to PONYPATH Assuming you just placed new Pony code under a directory called pony in your home directory here is how to inform ponyc that the directory contains Pony code via adding it to PONYPATH.\nUnix/Mac Edit/add the “rc” file corresponding to your chosen shell (echo $SHELL will tell you what shell you are running).","title":"PONYPATH","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/ponypath.html"},{"content":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:\n actor class struct primitive trait interface new fun be if (only as a condition, not as a guard) ifdef elseif else while repeat until for match | (only as a case in a match expression) recover object { (only as a lambda) with try then (only when part of a try block)  The effect of annotations Annotations are entirely implementation-specific. In other words, the Pony compiler (or any other tool that processes Pony programs) is free to take any action for any annotation that it encounters, including not doing anything at all. Annotations starting with ponyint are reserved by the compiler for internal use and shouldn’t be used by external tools.\nAnnotations in the Pony compiler The following annotations are recognised by the Pony compiler. Note that the Pony compiler will ignore annotations that it doesn’t recognise, as well as the annotations described here if they’re encountered in an unexpected place.\npacked Recognised on a a struct declaration. Removes padding in the associated struct, making it ABI-compatible with a packed C structure with compatible members (declared with the __attribute__((packed)) extension or the #pragma pack preprocessor directive in many C compilers).\nstruct \\packed\\ MyPackedStruct var x: U8 var y: U32 likely and unlikely Recognised on a conditional expression (if, while, until and | (as a pattern matching case)). Gives optimisation hints to the compiler on the likelihood of a given conditional expression.\nif \\likely\\ cond then foo end while \\unlikely\\ cond then bar end repeat baz until \\likely\\ cond end match obj | \\likely\\ expr =\u003e foo | \\unlikely\\ let capt: T =\u003e bar end ","summary":"In Pony, we provide a special syntax for implementation-specific annotations to various elements of a program. The basic syntax is a comma-separated list of identifiers surrounded by backslashes:\n\\annotation1, annotation2\\ Here, annotation1 and annotation2 can be any valid Pony identifier, i.e. a sequence of alphanumeric characters starting with a letter or an underscore.\nWhat can be annotated Annotations are allowed after any scoping keyword or symbol. The full list is:","title":"Program Annotations","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/annotations.html"},{"content":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows. Most recursive functions can be easily transformed into tail-recursive function which are less problematic. A tail-recursive function is a function in which the recursive call is the last instruction of the function. Here is an example with a factorial function:\nfun recursive_factorial(x: U32): U32 =\u003e if x == 0 then 1 else x * recursive_factorial(x - 1) end fun tail_recursive_factorial(x: U32, y: U32): U32 =\u003e if x == 0 then y else tail_recursive_factorial(x - 1, x * y) end The compiler can optimise a tail-recursive function to a loop, completely avoiding call stack growth. Note that this is an optimisation which is only performed in release builds (i.e. builds without the -d flag passed to ponyc.) If you need to avoid stack growth in debug builds as well then you have to write your function as a loop manually.\nIf the tail-recursive version of your algorithm isn’t practical to implement, there are other ways to control stack growth depending on your algorithm. For example, you can implement your algorithm using an explicit stack data structure instead of implicitly using the call stack to store data.\nNote that light recursion usually doesn’t cause problems. Unless your amount of recursive calls is in the hundreds, you’re unlikely to encounter this problem.\n","summary":"Recursive functions in Pony can cause many problems. Every function call in a program adds a frame on the system call stack, which is bounded. If the stack grows too big it will overflow, usually crashing the program. This is an out-of-memory type of error and it cannot be prevented by the guarantees offered by Pony.\nIf you have a heavy recursive algorithm, you must take some precautions in your code to avoid stack overflows.","title":"Recursion","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/recursion.html"},{"content":"At this point, it’s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It’s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you’ll get a better intuition with them.\nIn the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.\nIt is also the origin of the concept behind each capability in Pony, in the sense of how each capability denies certain properties to its reference – in other words, which guarantees a capability makes. We will explain what that actually means before presenting the matrix.\nLocal and global aliases Before anything else, we want to clarify what we mean by “local” and “global” aliases.\nA local alias is a reference to the same variable that exists in the same actor. Whenever you pass a value around, and it’s not the argument of an actor’s behavior, this is the kind of alias we are working with.\nOn the other hand, a global alias is a reference to the same variable that can exist in a different actor. That is, it describes the properties of how two or more actors could interact with the same reference.\nEach reference capability in Pony is actually a pair of local guarantees and global guarantees. For instance, ref doesn’t deny any read/write capabilities inside the actor, but denies other actors from reading or writing to that reference.\nYou may recall from the Reference Capability Guarantees section that mutable references cannot be safely shared between actors, while immutable references can be read by multiple actors. In general, global properties are always as restrictive or more restrictive than the local properties to that reference - what is denied globally must also be denied locally. For example, it’s not possible to write to an immutable reference in either a global or local alias. It’s also not possible to read from or write to an opaque reference, tag. Therefore, some combinations of local and global aliases are impossible, and have no designated capabilities.\nReference capability matrix Without further ado, here’s the reference capability matrix:\n      Deny global read/write aliases Deny global write aliases Don’t deny any global aliases     Deny local read/write aliases iso     Deny local write aliases trn val    Don’t deny any local aliases ref box tag     (Mutable) (Immutable) (Opaque)     In the context of the matrix, “denying a capability” means that any other alias to that reference is not allowed to do that action. For example, since trn denies other local write aliases (but allows reads), this is the only reference that allows writing to the object; and since it denies both read and write aliases to other actors, it’s safe to write inside this actor, thus being mutable. And since box does not break any guarantees that trn makes (local reads are allowed, but global writes are forbidden), we can create box aliases to a trn reference.\nYou’ll notice that the top-right side is empty. That’s because, as previously discussed, we cannot make any local guarantees that are more restrictive than the global guarantees, or we’d end up with invalid capabilities that could be written to in this actor but read somewehre else at the same time.\nThe matrix also helps visualizing other concepts previously discussed in this chapter:\n Sendable capabilities. If we want to send references to a different actor, we must make sure that the global and local aliases make the same guarantees. It’d be unsafe to send a trn to another actor, since we could possibly hold box references locally. Only iso, val, and tag have the same global and local restrictions – all of which are in the main diagonal of the matrix. Ephemeral subtyping. If we have an ephemeral capability (for instance, iso^ after consuming an isolated variable), we can be more permissive for the new alias, i.e. remove restrictions, such as allowing local aliases with read capabilities, and receive the reference into a trn^; or both read and write, which gives us ref. The same is true for more global alias, and we can get val, box, or tag. Visually, this would be equivalent to walking downwards and/or to-the-right starting from the capability in the matrix. Recovering capabilities. This is when we “lift” a capability, from a mutable reference to iso or an immutable reference to val. The matrix equivalent would be walking upwards starting from the capability – quite literally lifting in this case. Aliasing. With a bit more of imagination, it’s possible to picture aliasing iso and trn as reflecting them on the secondary diagonal of the matrix onto tag and box, respectively. The reason for that lies on which restrictions arise from the local guarantees. An iso doesn’t allow different aliases to read or write, which tag enforces; and trn doesn’t allow different aliases to write but allows them to do local reads, fitting box's restrictions.  We want to emphasize that trying to apply the reference capability matrix to some capabilities problems is not guaranteed to work (viewpoint adaptation is one example). The matrix is the original definition of the reference capabilities, presented here as a mnemonic device. Whenever you struggle with reference capabilities, we recommend that you reread the corresponding section of this chapter to understand why something is not allowed by the compiler.\n","summary":"At this point, it’s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It’s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you’ll get a better intuition with them.\nIn the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.","title":"Reference Capability Matrix","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-matrix.html"},{"content":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time. You do not want to do this. Do not call FFI code that doesn’t return in a reasonable amount of time.\nLong running behaviors Another way to monopolize a scheduler thread is to write a behavior that never exits or takes a really long time to exit.\nbe bad_citizen() =\u003e while true do _env.out.print(\"Never gonna give you up. Really gonna make you cry\") end That is some seriously bad citizen code that will hog a scheduler thread forever. Call that behavior a few times and your program will grind to a halt. If you find yourself writing code with loops that will run for a long time, stop and rethink your design. Take a look at the Timer class from the standard library. Combine that together with a counter in your class and you can execute the same behavior repeatedly while yielding your scheduler thread to other actors.\n","summary":"The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn’t end, you will continue to monopolize a scheduler thread and bad things will happen.\nFFI and monopolizing the scheduler An easy way to monopolize a scheduler thread is to use the FFI facilities of Pony to kick off code that doesn’t return for an extended period of time.","title":"Scheduling","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas/scheduling.html"},{"content":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object. A Serialised object can be created in one of two ways:\n calling the create(...) constructor with the SerialiseAuth authority and the object to serialize calling the input(...) constructor with the DeserialiseAuth authority and an Array[U8] that represents the object to deserialise This intermediate object can then be used to either: generate an Array[U8] that represents the object by calling the output(...) method with the OutputSerialisedAuth authority generate a deserialised object by calling the apply(...) method with the InputSerialisedAuth authority  This program serialises and deserialise an object, and checks that the fields of the original object are the same as the fields of the deserialised object.\nuse \"serialise\" class Foo is Equatable[Foo box] let _s: String let _u: U32 new create(s: String, u: U32) =\u003e _s = s _u = u fun eq(foo: Foo box): Bool =\u003e (_s == foo._s) and (_u == foo._u) actor Main new create(env: Env) =\u003e try let ambient = env.root as AmbientAuth // get serialization authorities let serialise = SerialiseAuth(ambient) let output = OutputSerialisedAuth(ambient) let deserialise = DeserialiseAuth(ambient) let input = InputSerialisedAuth(ambient) let foo1 = Foo(\"abc\", 123) // serialisation let sfoo = Serialised(serialise, foo1)? let bytes_foo: Array[U8] val = sfoo.output(output) env.out.print(\"serialised representation is \" + bytes_foo.size().string() + \" bytes long\") // deserialisation let dfoo = Serialised.input(input, bytes_foo) let foo2 = dfoo(deserialise)? as Foo env.out.print(\"(foo1 == foo2) is \" + (foo1 == foo2).string()) else env.err.print(\"there was an error\") end Caveats There are several things to keep in mind when using Pony’s serialisation system:\n Serialised objects will currently only work when passed between two running instances of the same Pony executable. You cannot pass objects between different Pony programs, nor can you pass them between different versions of the same program. Objects with embed fields will not be properly serialised. Objects with Pointer fields must use the custom serialisation mechanism or else the Pointer fields will be null when the object is deserialised. For information on how to handle these kinds of fields, please see the discussion of custom serialisation and deserialisation below.  Custom Serialisation and Deserialisation Pony objects can have Pointer fields that store pointers to memory that contains things that are opaque to Pony but that may be useful to code that is called via FFI. Because the objects that Pointer fields point to are opaque, Pony cannot serialise and deserialise them by itself. However, Pony’s serialisation system provides a way for the programmer to specify how the objects pointed to by these fields should be serialised and deserialised. This system is called custom serialisation.\nSince Pointer fields are opaque to Pony, it is assumed that the serialisation and deserialisation code will be written in another language that knows how to read the object referenced by the pointers.\nCustom Serialisation In order to serialise an object from a pointer field, Pony needs to know how much space to set aside for that object and how to write a representation of that object into the reserved space. The programmer must provide two methods on the object:\n fun _serialise_space(): USize – This method returns the number of bytes that must be reserved for the object. fun _serialise(bytes: Pointer[U8] tag) – This method receives a pointer to the memory that has been set aside for serialising the object. The programmer must not write more bytes than were returned by the _serialise_space method.  Custom Deserialisation Custom deserialisation is handled by a fun ref _deserialise(bytes: Pointer[U8] tag) method. This method receives a pointer to the character array that stores the serialised representation of the object (or objects) that the Pointer fields should point to. The programmer must copy out any bytes that will be used by the deserialised object.\nThe custom deserialization method is expected to modify the values of the objects Pointer fields, so the fields must be declared var so that they can be modified.\nConsiderations Fixed Versus Variable Object Sizes The programmer must write their custom serialisation and deserialisation code in such a way that it is aware of how many bytes are available in the byte arrays that are passed to the methods. If the objects are always of a fixed size then the functions can read and write than many bytes to the buffer. However, if the objects are of varying sizes (for example, if the object was a string), then the serialized representation must include information that the deserialisation code can use to ensure that it does not read beyond the end of the memory occupied by the object. The custom serialisation system does not provide a mechanism for doing this, so it is up to the program to choose a mechanism and implement it. In the case of a string, the serialisation format could consist of a 4-byte header that encodes the length of the string, followed by a string of the specified length. This additional four bytes must be included in the value returned by _serialise_space(). The deserialisation function would then start by reading the first four bytes of the array to obtain the size of the string and then read only that many bytes from the array.\nClasses With Multiple Pointer Fields If a class has more than one Pointer field then all of those fields must be handled by the custom serialisation and deserialisation methods for that class; there are not methods for each field. For example, if a class has three Pointer fields then the _serialise_space() method must return the total number of bytes required to serialise the objects from all three fields.\nExample Assume we have a Pony class with a field that is a pointer to a C string. We would like to be able to serialise and deserialise this object. In order to do that, the Pony class implements the methods _serialise_space(...), _serialise(...), and _deserialise(...). These methods, in turn, call C functions that calculate the number of bytes needed to serialise the string and serialise and deserialise it. In this example the serialised string is represented by a four-byte big-endian number that represents the length of the string, followed by the string itself without the terminating null. So if the C string is hello world\\0 then the serialised string is \\0x00\\0x00\\0x00\\0x0Bhello world (where the first four bytes of the serialised string are a big-endian representation of the number 0x0000000B, which is 11).\nuse \"serialise\" use \"lib:custser\" class CStringWrapper var _cstr: Pointer[U8] tag new create(cstr: Pointer[U8] tag) =\u003e _cstr = cstr fun _serialise_space(): USize =\u003e @serialise_space[USize](_cstr) fun _serialise(bytes: Pointer[U8] tag) =\u003e @serialise[None](bytes, _cstr) fun ref _deserialise(bytes: Pointer[U8] tag) =\u003e _cstr = @deserialise[Pointer[U8] tag](bytes) fun print() =\u003e @printf[I32](_cstr) actor Main new create(env: Env) =\u003e let csw = CStringWrapper(@get_string[Pointer[U8]]()) csw.print() try let ambient = env.root as AmbientAuth let serialise = SerialiseAuth(ambient) let deserialise = DeserialiseAuth(ambient) let sx = Serialised(serialise, csw)? let y = sx(deserialise)? as CStringWrapper y.print() else env.err.print(\"there was an error\") end // custser.c  #include \u003cstdlib.h\u003e#include \u003cstring.h\u003e extern char *get_string() { return \"hello world\\n\"; } extern size_t serialise_space(char *s) { // space for the size and the string (without the null)  return 4 + strlen(s); } extern void serialise(char *buff, char *s) { size_t sz = strlen(s); unsigned char *ubuff = (unsigned char *) buff; // write the size as a 32-bit big-endian integer  ubuff[0] = (sz \u003e\u003e 24) \u0026 0xFF; ubuff[1] = (sz \u003e\u003e 16) \u0026 0xFF; ubuff[2] = (sz \u003e\u003e 8) \u0026 0xFF; ubuff[3] = sz \u0026 0xFF; // copy the string  strncpy(buff + 4, s, sz); } extern char *deserialise(char *buff) { unsigned char *ubuff = (unsigned char *) buff; size_t sz = (ubuff[0] \u003c\u003c 24) + (ubuff[1] \u003c\u003c 16) + (ubuff[2] \u003c\u003c 8) + ubuff[3]; char *s = malloc(sizeof(char) * sz + 1); memcpy(s, buff + 4, sz); s[sz] = '\\0'; return s; } ","summary":"Pony provides a built-in mechanism for serialising and deserialising objects so that they can be passed between Pony processes. Serialisation takes an object and turns it into an array of bytes that can be used to send the object to another process by, for example, writing it to a TCP stream. Deserialisation takes an array of bytes and turns them into a Pony object.\nPony uses an intermediate object type called Serialised to represent a serialised object.","title":"Serialisation","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/serialisation.html"},{"content":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .\u003e Chaining   ^ Ephemeral   @ FFI   \u0026 Intersection   =\u003e Match arrow   ~ Partial application   ? Partial function   ' Prime   \u003c: Subtype    Here is a more elaborate explanation of Pony’s use of special characters: (a line with (2) or (3) means an alternate usage of the symbol of the previous line)\n   Symbol Usage     , to separate parameters in a function signature, or the items of a tuple   . (1) to call a field or a function on a variable (field access or method call)    (2) to qualify a type/method with its package name   .\u003e to call a method on an object and return the receiver (chaining)   ' used as alternative name in parameters (prime)   \" to delineate a literal string   \"\"\" to delineate a documentation string   ( (1) start of line: start of a tuple    (2) middle of line: method call   () (1) parentheses, for function or behavior parameters    (2) making a tuple (values separated by ,)    (3) making an enumeration (values separated by |)   [ (1) start of line: start of an array literal    (2) middle of line: generic formal parameters   [] (1) to indicate a generic type, for example Range[U64]    (2) to indicate the return type of an FFI function call   {} a function type   : (1) after a variable: is followed by the type name    (2) to indicate a function return type    (3) a type constraint   ; only used to separate expressions on the same line   = (1) (destructive) assignment    (2) in: use alias = packname    (3) supply default argument for method    (4) supply default type for generics   ! (1) boolean negation    (2) a type that is an alias of another type   ? (1) partial functions    (2) a call to a C function that could raise an error   - (1) start of line: unary negation    (2) middle of line: subtraction   _ (1) to indicate a private variable, constructor, function, behavior    (2) to ignore a tuple item in a pattern match   ~ partial application   ^ an ephemeral type   | (1) separates the types in an enumeration (the value can be any of these types)    (2) starts a branch in a match   \u0026 (1) separates the types in a complex type (the value is of all of these types)    (2) intersection   @ FFI call   // comments   /* */ multi-line or block comments   =\u003e (1) start of a function body    (2) starts the code of a matching branch   -\u003e (1) arrow type    (2) viewpoint   ._i where i = 1,2,… means the ith item of a tuple   \u003c: “is a subtype of” or “can be substituted for”    ","summary":"Pony, like just about any other programming language, has plenty of odd symbols that make up its syntax. If you don’t remember what one means, it can be hard to search for them. Below you’ll find a table with various Pony symbols and what you should search the tutorial for in order to learn more about the symbol.\n   Symbol Search Keywords     ! Alias   -\u003e Arrow type, viewpoint   .","title":"Symbol Lookup Cheatsheet","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/symbol-lookup-cheatsheet.html"},{"content":"","summary":"","title":"Tags","uri":"https://damon-kwok.github.io/pony-tutorial/tags.html"},{"content":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.\nWhen any assertion function fails the test is counted as a fail. However, tests can also indicate failure by raising an error in the test function.\nExample program To use PonyTest simply write a class for each test and a TestList type that tells the PonyTest object about the tests. Typically the TestList will be Main for the package.\nThe following is a complete program with 2 trivial tests.\nuse \"ponytest\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e test(_TestAdd) test(_TestSub) class iso _TestAdd is UnitTest fun name(): String =\u003e \"addition\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](4, 2 + 2) class iso _TestSub is UnitTest fun name(): String =\u003e \"subtraction\" fun apply(h: TestHelper) =\u003e h.assert_eq[U32](2, 4 - 2) The make() constructor is not needed for this example. However, it allows for easy aggregation of tests (see below) so it is recommended that all test Mains provide it.\nMain.create() is called only for program invocations on the current package. Main.make() is called during aggregation. If so desired extra code can be added to either of these constructors to perform additional tasks.\nTest names Tests are identified by names, which are used when printing test results and on the command line to select which tests to run. These names are independent of the names of the test classes in the Pony source code.\nArbitrary strings can be used for these names, but for large projects, it is strongly recommended to use a hierarchical naming scheme to make it easier to select groups of tests.\nAggregation Often it is desirable to run a collection of unit tests from multiple different source files. For example, if several packages within a bundle each have their own unit tests it may be useful to run all tests for the bundle together.\nThis can be achieved by writing an aggregate test list class, which calls the list function for each package. The following is an example that aggregates the tests from packages foo and bar.\nuse \"ponytest\" use foo = \"foo\" use bar = \"bar\" actor Main is TestList new create(env: Env) =\u003e PonyTest(env, this) new make() =\u003e None fun tag tests(test: PonyTest) =\u003e foo.Main.make().tests(test) bar.Main.make().tests(test) Aggregate test classes may themselves be aggregated. Every test list class may contain any combination of its own tests and aggregated lists.\nLong tests Simple tests run within a single function. When that function exits, either returning or raising an error, the test is complete. This is not viable for tests that need to use actors.\nLong tests allow for delayed completion. Any test can call long_test() on its TestHelper to indicate that it needs to keep running. When the test is finally complete it calls complete() on its TestHelper.\nThe complete() function takes a Bool parameter to specify whether the test was a success. If any asserts fail then the test will be considered a failure regardless of the value of this parameter. However, complete() must still be called.\nSince failing tests may hang, a timeout must be specified for each long test. When the test function exits a timer is started with the specified timeout. If this timer fires before complete() is called the test is marked as a failure and the timeout is reported.\nOn a timeout, the timed_out() function is called on the unit test object. This should perform whatever test specific tidy up is required to allow the program to exit. There is no need to call complete() if a timeout occurs, although it is not an error to do so.\nNote that the timeout is only relevant when a test hangs and would otherwise prevent the test program from completing. Setting a very long timeout on tests that should not be able to hang is perfectly acceptable and will not make the test take any longer if successful.\nTimeouts should not be used as the standard method of detecting if a test has failed.\nExclusion groups By default, all tests are run concurrently. This may be a problem for some tests, eg if they manipulate an external file or use a system resource. To fix this issue any number of tests may be put into an exclusion group.\nNo tests that are in the same exclusion group will be run concurrently.\nExclusion groups are identified by name, arbitrary strings may be used. Multiple exclusion groups may be used and tests in different groups may run concurrently. Tests that do not specify an exclusion group may be run concurrently with any other tests.\nThe command line option “–sequential” prevents any tests from running concurrently, regardless of exclusion groups. This is intended for debugging rather than standard use.\nTear down Each unit test object may define a tear_down() function. This is called after the test has finished allowing the tearing down of any complex environment that had to be set up for the test.\nThe tear_down() function is called for each test regardless of whether it passed or failed. If a test times out tear_down() will be called after timed_out() returns.\nWhen a test is in an exclusion group, the tear_down() call is considered part of the tests run. The next test in the exclusion group will not start until after tear_down() returns on the current test.\nThe test’s TestHelper is handed to tear_down() and it is permitted to log messages and call assert functions during tear down.\nAdditional resources You can learn more about PonyTest specifics by checking out the API documentation. There’s also a testing section in the Pony Patterns book.\n","summary":"PonyTest is Pony’s unit testing framework. It is designed to be as simple as possible to use, both for the unit test writer and the user running the tests.\nEach unit test is a class, with a single test function. By default, all tests run concurrently.\nEach test run is provided with a helper object. This provides logging and assertion functions. By default log messages are only shown for tests that fail.","title":"Testing with Ponytest","uri":"https://damon-kwok.github.io/pony-tutorial/testing/ponytest.html"},{"content":"We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you’ve called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.\nTrust boundaries When we talk about trust, we don’t mean things you trust because you think they are perfect. Instead, we mean things you have to trust in order to get things done, even though you know they are imperfect.\nIn Pony, when you use the C FFI, you are basically declaring that you trust the C code that’s being executed. That’s fine, because you may need it to get work done. But what about trusting someone else’s code to use the C FFI? You may need to, but you definitely want to know that it’s happening.\nSafe packages The normal way to handle that is to be sure you’re using just the code you need to use in your program. Pretty simple! Don’t use some random package from the internet without looking at the code and making sure it doesn’t do nasty FFI stuff.\nBut we can do better than that.\nIn Pony, you can optionally declare a set of safe packages on the ponyc command line, like this:\nponyc --safe=files:net:net/ssl my_project Here, we are declaring that only the files, net and net/ssl packages are allowed to use C FFI calls. We’ve established our trust boundary: any other packages that try to use C FFI calls will result in a compile-time error.\n","summary":"We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you’ve called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.\nTrust boundaries When we talk about trust, we don’t mean things you trust because you think they are perfect. Instead, we mean things you have to trust in order to get things done, even though you know they are imperfect.","title":"Trust Boundary","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/trust-boundary.html"},{"content":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction). A ( at the beginning of a line starts a new expression (a tuple), whereas a ( in the middle of an expression is a method call. A [ at the beginning of a line starts a new expression (an array literal), whereas a [ in the middle of an expression is generic formal parameters.  That stuff may seem a little esoteric right now, but we’ll explain it all later. The - part should make sense though.\na - b That means “subtract b from a”.\na -b That means “first do a, then, in a new expression, do a unary negation of b”.\nSemicolons In Pony, you don’t end an expression with a ;, unlike C, C++, Java, C#, etc. In fact, you don’t need to end it at all! The compiler knows when an expression has finished, like Python or Ruby.\nHowever, sometimes it’s convenient to put more than one expression on the same line. When you want to do that, you must separate them with a ;.\nWhy? Can’t the compiler tell an expression has finished? Yes, it can. The compiler doesn’t really need the ;. However, it turns out the programmer does! By requiring a ; between expressions on the same line, the compiler can catch some pretty common syntax errors for you.\nDocstrings Including documentation in your code makes you awesome. If you do it, everyone will love you.\nPony makes it easy by allowing you to put a docstring on every type, field, or method. Just put a string literal right after declaring the type or field, or right after the =\u003e of a method, before writing the body. The compiler will know what to do with them.\nFor traits and interfaces that have methods without bodies, you can put the docstring after the method declaration, even though there is no =\u003e.\nBy convention, a docstring should be a triple-quoted string, and it should use Markdown for any formatting.\nactor Main \"\"\" This is documentation for my Main actor \"\"\" var count: USize = 0 \"\"\" This is documentation for my count field \"\"\" new create(env: Env) =\u003e \"\"\" This is documentation for my create method \"\"\" None trait Readable fun val read() \"\"\" This is documentation for my unimplemented read method \"\"\" Comments Use docstrings first! But if you need to put some comments in the implementation of your methods, perhaps to explain what’s happening on various lines, you can use C++ style comments. In Pony, block comments can be nested.\n// This is a line comment. /* This is a block comment. */ /* This block comment /* has another block comment */ inside of it. */ ","summary":"Whitespace (e.g. spaces, tabs, newlines, etc.) in Pony isn’t significant.\nWell, it mostly isn’t significant.\nMostly insignificant whitespace Pony reads a bit like Python, which is a whitespace significant language. That is, the amount of indentation on a line means something in Python. In Pony, the amount of indentation is meaningless.\nThat means Pony programmers can format their code in whatever way suits them.\nThere are three exceptions:\n A - at the beginning of a line starts a new expression (unary negation), whereas a - in the middle of an expression is a binary operator (subtraction).","title":"Whitespace","uri":"https://damon-kwok.github.io/pony-tutorial/appendices/whitespace.html"},{"content":"首先，你需要一个文本编辑器，还有Pony编译器。如果你想偷点懒直接使用Pony’s Playground也是可以的。\nPony编译器 安装Pony编译器的方法：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，不是解释型的语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以拿到其他地方运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整的程序。\n但是这就需要你必须先构建程序，然后才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python)，然后使用chmod设置运行权限，然后直接运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接敲ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果你的代码在其他目录里，把目录作为参数告诉编译器就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，我们将在后面介绍。\n","summary":"首先，你需要一个文本编辑器，还有Pony编译器。如果你想偷点懒直接使用Pony’s Playground也是可以的。\nPony编译器 安装Pony编译器的方法：安装教程。Windows用户可以直接下载Pony。另外在Windows上编译Pony程序你需要安装VsualStudio或Microsoft C++ Build Tools。\n文本编辑器 你可以用自己喜欢的文本编辑器，这里是Pony对编辑器的支持列表\n编译器说明 Pony是一个编译型语言，不是解释型的语言。更进一步来说：Pony是一种提前（AOT）编译型语言，而不是即时（JIT）编译型语言。\n这表示只要你编译成功，就可以拿到其他地方运行它，不再需编译器，虚拟机或其他任何运行时。编译出来的是一个完整的程序。\n但是这就需要你必须先构建程序，然后才能运行。在解释性语言或JIT编译语言中，你可能会用下面的方式来运行程序：\n$ python helloworld.py 或者你可能在代码文件头部加入shebang(#!/usr/bin/env python)，然后使用chmod设置运行权限，然后直接运行：\n$ ./helloworld.py 但是这些方法在Pony中行不通！\n编译你的程序 进入代码目录，直接敲ponyc就可以进行编译：\n$ ponyc 这相当于告诉编译器你的代码在当前目录里，请遍历所有源码文件然后编译它们。如果你的代码在其他目录里，把目录作为参数告诉编译器就行了：\n$ ponyc path/to/my/code 还有一些其他编译选项，我们将在后面介绍。","title":"准备工作（What You Need）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/what-you-need.html"},{"content":"Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.\nIn most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what’s being assigned to it, and everything is fine.\nIn Pony, that works for some reference capabilities, but not all.\nAliasing and deny guarantees The reason for this is that the iso reference capability denies other iso variables that point to the same object. That is, you can only have one iso variable pointing to any given object. The same goes for trn.\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = a // Not allowed! Here we have some function that gets passed an isolated Wombat. If we try to alias a by assigning it to b, we’ll be breaking reference capability guarantees so the compiler will stop us.\nWhat can I alias an iso as? Since an iso says no other variable can be used by any actor to read from or write to that object, we can only create aliases to an iso that can neither read nor write. Fortunately, we’ve got a reference capability that does exactly that: tag. So we can do this and the compiler will be happy:\nfun test(a: Wombat iso) =\u003e var b: Wombat tag = a // Allowed! What about aliasing trn? Since a trn says no other variable can be used by any actor to write to that object, we need something that doesn’t allow writing but also doesn’t prevent our trn variable from writing. Fortunately, we’ve got a reference capability that does that too: box. So we can do this and the compiler will be happy:\nfun test(a: Wombat trn) =\u003e var b: Wombat box = a // Allowed! What about aliasing other stuff? For both iso and trn, the guarantees require that aliases must give up on some ability (reading and writing for iso, writing for trn). For the other capabilities (ref, val, box and tag), aliases allow for the same operations, so such a reference can just be aliased as itself.\nWhat counts as making an alias? There are three things that count as making an alias:\n When you assign a value to a variable or a field. When you pass a value as an argument to a method. When you call a method, an alias of the receiver of the call is created. It is accessible as this within the method body.  In all three cases, you are making a new name for the object. This might be the name of a local variable, the name of a field, or the name of a parameter to a method.\nEphemeral types In Pony, every expression has a type. So what’s the type of consume a? It’s not the same type as a, because it might not be possible to alias a. Instead, it’s an ephemeral type. That is, it’s a type for a value that currently has no name (it might have a name through some other alias, but not the one we just consumed or destructively read).\nTo show a type is ephemeral, we put a ^ at the end. For example:\nfun test(a: Wombat iso): Wombat iso^ =\u003e consume a Here, our function takes an isolated Wombat as a parameter and returns an ephemeral isolated Wombat.\nThis is useful for dealing with iso and trn types, and for generic types, but it’s also important for constructors. A constructor always returns an ephemeral type, because it’s a new object.\nAlias types For the same reason Pony has ephemeral types, it also has alias types. An alias type is a way of saying “whatever we can safely alias this thing as”. It’s only needed when dealing with generic types, which we’ll discuss later.\nWe indicate an alias type by putting a ! at the end. Here’s an example:\nfun test(a: A) =\u003e var b: A! = a Here, we’re using A as a type variable, which we’ll cover later. So A! means “an alias of whatever type A is”.\n","summary":"Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.\nIn most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what’s being assigned to it, and everything is fine.","title":"别名（Aliasing）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/aliasing.html"},{"content":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.\nA package is usually split into several source files, although it does not have to be. This is purely a convenience to allow better code organisation and the compiler treats all the code within a package as if it were from a single file.\nThe package is the privacy boundary for types and methods. That is:\n Private types (those whose name starts with an underscore) can be used only within the package in which they are defined. Private methods (those whose name starts with an underscore) can be called only from code within the package in which they are defined.  It follows that all code within a package is assumed to know and trust, all the rest of the code in the package.\nThere is no such concept as a sub-package in Pony. For example, the packages “foo/bar” and “foo/bar/wombat” will, presumably, perform related tasks but they are two independent packages. Package “foo/bar” does not contain package “foo/bar/wombat” and neither has access to the private elements of the other.\n","summary":"Pony code is organised into packages. Each program and library is a single package, possibly using other packages.\nThe package structure The package is the basic unit of code in Pony. It corresponds directly to a directory in the file system, all Pony source files within that directory are within that package. Note that this does not include files in any sub-directories.\nEvery source file is within exactly one package. Hence all Pony code is in packages.","title":"包机制（Package System）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/package-system.html"},{"content":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same. They come at the beginning of Pony files and look like this:\nuse \"collections\" This will find all of the publicly visible types defined in the collections package and add them to the type namespace of the file containing the use command. These types are then available to use within that file, just as if they were defined locally.\nFor example, the standard library contains the package time. This contains the following definition (among others):\nprimitive Time fun now(): (I64, I64) To access the now function just add a use command:\nuse \"time\" class Foo fun f() =\u003e (var secs, var nsecs) = Time.now() Use names As we saw above the use command adds all the public types from a package into the namespace of the using file. This means that using a package may define type names that you want to use for your own types. Furthermore, if you use two packages within a file they may both define the same type name, causing a clash in your namespace. For example:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use \"packageB\" class Bar var _x: Foo The declarations of _x is an error because we don’t know which Foo is being referred to. Actually using ‘Foo’ is not even required, simply using both packageA and packageB is enough to cause an error here.\nTo avoid this problem the use command allows you to specify an alias. If you do this then only that alias is put into your namespace. The types from the used package can then be accessed using this alias as a qualifier. Our example now becomes:\n// In package A class Foo // In package B class Foo // In your code use a = \"packageA\" use b = \"packageB\" class Bar var _x: a.Foo // The Foo from package A var _y: b.Foo // The Foo from package B If you prefer you can give an alias to only one of the packages. Foo will then still be added to your namespace referring to the unaliased package:\n// In package A class Foo // In package B class Foo // In your code use \"packageA\" use b = \"packageB\" class Bar var _x: Foo // The Foo from package A var _y: b.Foo // The Foo from package B Can I just specify the full package path and forget about the use command, like I do in Java and C#? No, you can’t do that in Pony. You can’t refer to one package based on a use command for another package and you can’t use types from a package without a use command for that package. Every package that you want to use must have its own use command.\nAre there limits on the names I can use for an alias? Use alias names have to start with a lower case letter. Other than that you can use whatever name you want, as long as you’re not using that name for any other purpose in your file.\nScheme indicators The string we give to a use command is known as the specifier. This consists of a scheme indicator and a locator, separated by a colon. The scheme indicator tells the use command what we want it to do, for example, the scheme indicator for including a package is “package”. If no colon is found within the specifier string then the use command assumes you meant “package”.\nThe following two use commands are exactly equivalent:\nuse \"foo\" use \"package:foo\" If you are using a locator string that includes a colon, for example, an absolute path in Windows, then you have to include the “package” scheme specifier:\nuse \"C:/foo/bar\" // Error, scheme \"C\" is unknown use \"package:C:/foo/bar\" // OK To allow use commands to be portable across operating systems, and to avoid confusion with escape characters, ‘/’ should always be used as the path separator in use commands, even on Windows.\n","summary":"To use a package in your code you need to have a use command. This tells the compiler to find the package you need and make the types defined in it available to you. Every Pony file that needs to know about a type from a package must have a use command for it.\nUse commands are a similar concept to Python and Java “import”, C/C++ “#include” and C# “using” commands, but not exactly the same.","title":"包的使用方式（Use Statement）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/use-statement.html"},{"content":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.0 =\u003e \"float\" | \"2\" =\u003e \"string\" else \"something else\" end If you’re used to functional languages this should be very familiar.\nFor those readers more familiar with the C and Java family of languages, think of this like a switch statement. But you can switch on values other than just integers, like Strings. In fact, you can switch on any type that provides a comparison function, including your own classes. And you can also switch on the runtime type of an expression.\nA match starts with the keyword match, followed by the expression to match, which is known as the match operand. In this example, the operand is just the variable x, but it can be any expression.\nMost of the match expression consists of a series of cases that we match against. Each case consists of a pipe symbol (‘|’), the pattern to match against, an arrow (‘=\u003e’) and the expression to evaluate if the case matches.\nWe go through the cases one by one until we find one that matches. (Actually, in practice the compiler is a lot more intelligent than that and uses a combination of sequential checks and jump tables to be as efficient as possible.)\nNote that each match case has an expression to evaluate and these are all independent. There is no “fall through” between cases as there is in languages such as C.\nIf the value produced by the match expression isn’t used then the cases can omit the arrow and expression to evaluate. This can be useful for excluding specific cases before a more general case.\nElse cases As with all Pony control structures, the else case for a match expression is used if we have no other value, i.e. if none of our cases match. The else case, if there is one, must come at the end of the match, after all of the specific cases.\nIf the value the match expression results in is used then you need to have an else case, except in cases where the compiler recognizes that the match is exhaustive and that the else case can never actually be reached. If you omit it a default will be added which evaluates to None.\nThe compiler recognizes a match as exhaustive when the union of the types for all patterns that match on type alone is a supertype of the matched expression type. In other words, when your cases cover all possible types for the matched expression, the compiler will not add an implicit else None to your match statement.\nMatching on values The simplest match expression just matches on value.\nfun f(x: U32): String =\u003e match x | 1 =\u003e \"one\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | 5 =\u003e \"not four\" else \"something else\" end For value matching the pattern is simply the value we want to match to, just like a C switch statement. The case with the same value as the operand wins and we use its expression.\nThe compiler calls the eq() function on the operand, passing the pattern as the argument. This means that you can use your own types as match operands and patterns, as long as you define an eq() function.\nclass Foo var _x: U32 new create(x: U32) =\u003e _x = x fun eq(that: Foo): Bool =\u003e _x == that._x actor Main fun f(x: Foo): String =\u003e match x | Foo(1) =\u003e \"one\" | Foo(2) =\u003e \"two\" | Foo(3) =\u003e \"three\" | Foo(5) =\u003e \"not four\" else \"something else\" end Matching on type and value Matching on value is fine if the match operand and case patterns have all the same type. However, match can cope with multiple different types. Each case pattern is first checked to see if it is the same type as the runtime type of the operand. Only then will the values be compared.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | \"5\" =\u003e \"not four\" else \"something else\" end In many languages using runtime type information is very expensive and so it is generally avoided whenever possible.\nIn Pony it’s cheap. Really cheap. Pony’s “whole program” approach to compilation means the compiler can work out as much as possible at compile time. The runtime cost of each type check is generally a single pointer comparison. Plus of course, any checks which can be fully determined at compile time are. So for upcasts there’s no runtime cost at all.\nWhen are case patterns for value matching evaluated? Each case pattern expression that matches the type of the match operand, needs to be evaluated each time the match expression is evaluated until one case matches (further case patterns are ignored). This can lead to creating lots of objects unintentionally for the sole purpose of checking for equality. If case patterns actually only need to differentiate by type, Captures should be used instead, these boil down to simple type checks at runtime.\nAt first sight it is easy to confuse a value matching pattern for a type check. Consider the following example:\nclass Foo is Equatable[Foo] actor Main fun f(x: (Foo | None)): String =\u003e match x | Foo =\u003e \"foo\" | None =\u003e \"bar\" else \"\" end new create(env: Env) =\u003e f(Foo) Both case patterns actually do not check for the match operand x being an instance of Foo or None, but check for equality with the instance created by evaluating the case pattern (each time). None is a primitive and thus there is only one instance at all, in which case this value pattern kind of does the expected thing, but not quite. If None had a custom eq function that would not use identity equality, this could lead to surprising results.\nRemember to always use Captures if all you need is to differentiate by type. Only use value matching if you need a full blown equality check, be it for structural equality or identity equality.\nCaptures Sometimes you want to be able to match the type, for any value of that type. For this, you use a capture. This defines a local variable, valid only within the case, containing the value of the operand. If the operand is not of the specified type then the case doesn’t match.\nCaptures look just like variable declarations within the pattern. Like normal variables, they can be declared as var or let. If you’re not going to reassign them within the case expression it is good practice to use let.\nfun f(x: (U32 | String | None)): String =\u003e match x | None =\u003e \"none\" | 2 =\u003e \"two\" | 3 =\u003e \"three\" | let u: U32 =\u003e \"other integer\" | let s: String =\u003e s end Can I omit the type from a capture, like I can from a local variable? Unfortunately no. Since we match on type and value the compiler has to know what type the pattern is, so it can’t be inferred.\nImplicit matching on capabilities in the context of union types In union types, when we pattern match on individual classes or traits, we also implicitly pattern match on the corresponding capabilities. In the example provided below, if _x has static type (A iso | B ref | None) and dynamically matches A, then we also know that it must be an A iso.\nclass A fun ref sendable() =\u003e None class B fun ref update() =\u003e None actor Main var _x: (A iso | B ref | None) new create(env: Env) =\u003e _x = None be f(a': A iso) =\u003e match (_x = None) // type of this expression: (A iso^ | B ref | None) | let a: A iso =\u003e f(consume a) | let b: B ref =\u003e b.update() end Note that using a match expression to differentiate solely based on capabilities at runtime is not possible, that is:\nclass A fun ref sendable() =\u003e None actor Main var _x: (A iso | A ref | None) new create(env: Env) =\u003e _x = None be f() =\u003e match (_x = None) | let a1: A iso =\u003e None | let a2: A ref =\u003e None end does not typecheck.\nMatching tuples If you want to match on more than one operand at once then you can simply use a tuple. Cases will only match if all the tuple elements match.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, let u: U32) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) =\u003e s + \" other integer\" else \"something else\" end Do I have to specify all the elements in a tuple? No, you don’t. Any tuple elements in a pattern can be marked as “don’t care” by using an underscore ('_'). The first and fourth cases in our example don’t actually care about the U32 element, so we can ignore it.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, _) =\u003e s + \" other integer\" else \"something else\" end Guards In addition to matching on types and values, each case in a match can also have a guard condition. This is simply an expression, evaluated after type and value matching has occurred, that must give the value true for the case to match. If the guard is false then the case doesn’t match and we move onto the next in the usual way.\nGuards are introduced with the if keyword (was where until 0.2.1).\nA guard expression may use any captured variables from that case, which allows for handling ranges and complex functions.\nfun f(x: (String | None), y: U32): String =\u003e match (x, y) | (None, _) =\u003e \"none\" | (let s: String, 2) =\u003e s + \" two\" | (let s: String, 3) =\u003e s + \" three\" | (let s: String, let u: U32) if u \u003e 14 =\u003e s + \" other big integer\" | (let s: String, _) =\u003e s + \" other small integer\" else \"something else\" end ","summary":"If we want to compare an expression to a value then we use an if. But if we want to compare an expression to a lot of values this gets very tedious. Pony provides a powerful pattern matching facility, combining matching on values and types, without any special code required.\nMatching: the basics Here’s a simple example of a match expression that produces a string.\nmatch x | 2 =\u003e \"int\" | 2.","title":"匹配表达式（Match Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching/match.html"},{"content":"Like most other programming languages Pony allows you to store data in variables. There are a few different kinds of variables which have different lifetimes and are used for slightly different purposes.\n局部变量 Local variables in Pony work very much as they do in other languages, allowing you to store temporary values while you perform calculations. Local variables live within a chunk of code (they are local to that chunk) and are created every time that code chunk executes and disposed of when it completes.\nTo define a local variable the var keyword is used (let can also be used, but we’ll get to that later). Right after the var comes the variable’s name, and then you can (optionally) put a : followed by the variable’s type. For example:\nvar x: String = \"Hello\" Here, we’re assigning the string literal \"Hello\" to x.\nYou don’t have to give a value to the variable when you define it: you can assign one later if you prefer. If you try to read the value from a variable before you’ve assigned one, the compiler will complain instead of allowing the dreaded uninitialised variable bug.\nEvery variable has a type, but you don’t have to specify it in the declaration if you provide an initial value. The compiler will automatically use the type of the initial value of the variable.\nThe following definitions of x, y and z are all effectively identical.\nvar x: String = \"Hello\" var y = \"Hello\" var z: String z = \"Hello\" Can I miss out both the type and initial value for a variable? No. The compiler will complain that it can’t figure out a type for that variable.\nAll local variable names start with a lowercase letter. If you want to you can end them with a prime ' (or more than one) which is useful when you need a second variable with almost the same meaning as the first. For example, you might have one variable called time and another called time'.\nThe chunk of code that a variable lives in is known as its scope. Exactly what its scope is depends on where it is defined. For example, the scope of a variable defined within the then expression of an if statement is that then expression. We haven’t looked at if statements yet, but they’re very similar to every other language.\nif a \u003e b then var x = \"a is bigger\" env.out.print(x) // OK end env.out.print(x) // Illegal Variables only exist from when they are defined until the end of the current scope. For our variable x this is the end at the end of the then expression: after that, it cannot be used.\nvar和let Local variables are declared with either a var or a let. Using var means the variable can be assigned and reassigned as many times as you like. Using let means the variable can only be assigned once.\nvar x: U32 = 3 let y: U32 = 4 x = 5 // OK y = 6 // Error, y is let Using let instead of var also means the variable has to be assigned immediately.\nlet x: U32 = 3 // Ok let y: U32 // Error, can't declare a let local without assigning to it y = 6 // Error, can't reassign to a let local Note that a variable having been declared with let only restricts reassignment, and does not influence the mutability of the object it references. This is the job of reference capabilities, explained later in this tutorial.\nYou never have to declare variables as let, but if you know you’re never going to change what a variable references then using let is a good way to catch errors. It can also serve as a useful comment, indicating what is referenced is not meant to be changed.\n字段 In Pony, fields are variables that live within objects. They work like fields in other object-oriented languages.\nFields have the same lifetime as the object they’re in, rather than being scoped. They are set up by the object constructor and disposed of along with the object.\nIf the name of a field starts with _, it’s private. That means only the type the field is in can have code that reads or writes that field. Otherwise, the field is public and can be read or written from anywhere.\nJust like local variables, fields can be var or let. Nevertheless, rules for field assignment differ a bit from variable assignment. No matter the type of the field (either var or let), either:\n an initial value has to be assigned in their definition or an initial value has to be assigned in the constructor method.  In the example below, the initial value of the two fields of the class Wombat is assigned at the definition level:\nclass Wombat let name: String = \"Fantastibat\" var _hunger_level: U32 = 0 Alternatively, these fields could be assigned in the constructor method:\nclass Wombat let name: String var _hunger_level: U32 new create(hunger: U32) =\u003e name = \"Fantastibat\" _hunger_level = hunger If the assignment is not done at the definition level or in the constructor, an error is raised by the compiler. This is true for both var and let fields.\nPlease note that the assignment of a value to a field has to be explicit. The below example raises an error when compiled, even when the field is of var type:\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' set_hunger_level(level) // Error: field _hunger_level left undefined in constructor fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level We will see later in the Methods section that a class can have several constructors. For now, just remember that if the assignment of a field is not done at the definition level, it has to be done in each constructor of the class the field belongs to.\nAs for variables, using var means a field can be assigned and reassigned as many times as you like in the class. Using let means the field can only be assigned once.\nclass Wombat let name: String var _hunger_level: U64 new ref create(name': String, level: U64) =\u003e name = name' _hunger_level = level fun ref set_hunger_level(hunger_level: U64) =\u003e _hunger_level = hunger_level // Ok, _hunger_level is of var type fun ref set_name(name' : String) =\u003e name = name' // Error, can't assign to a let definition more than once Can field declarations appear after methods? No. If var or let keywords appear after a fun or be declaration, they will be treated as variables within the method body rather than fields within the type declaration. As a result, fields must appear prior to methods in the type declaration\n内嵌字段（Embedded Fields） Unlike local variables, some types of fields can be declared using embed. Specifically, only classes or structs can be embedded - interfaces, traits, primitives and numeric types cannot. A field declared using embed is similar to one declared using let, but at the implementation level, the memory for the embedded class is laid out directly within the outer class. Contrast this with let or var, where the implementation uses pointers to reference the field class. Embedded fields can be passed to other functions in exactly the same way as let or var fields. Embedded fields must be initialised from a constructor expression.\nWhy would I use embed? embed avoids a pointer indirection when accessing a field and a separate memory allocation when creating that field. By default, it is advised to use embed if possible. However, since an embedded field is allocated alongside its parent object, exterior references to the field forbids garbage collection of the parent, which can result in higher memory usage if a field outlives its parent. Use let if this is a concern for you.\n全局变量 Some programming languages have global variables that can be accessed from anywhere in the code. What a bad idea! Pony doesn’t have global variables at all.\n隐藏（Shadowing） Some programming languages let you declare a variable with the same name as an existing variable, and then there are rules about which one you get. This is called shadowing, and it’s a source of bugs. If you accidentally shadow a variable in Pony, the compiler will complain.\nIf you need a variable with nearly the same name, you can use a prime '.\n","summary":"Like most other programming languages Pony allows you to store data in variables. There are a few different kinds of variables which have different lifetimes and are used for slightly different purposes.\n局部变量 Local variables in Pony work very much as they do in other languages, allowing you to store temporary values while you perform calculations. Local variables live within a chunk of code (they are local to that chunk) and are created every time that code chunk executes and disposed of when it completes.","title":"变量（Variables）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/variables.html"},{"content":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段意味着primitive不会产生副作用。只有一个实例意味着，如果您的代码以 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\nprimitive 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n1.作为\"标记值”。例如，Pony经常使用 primitive None来表示某事物没有值。当然，它确实具有一个值，以便您可以检查它是什么，并且该值是“无”的单个实例。 2.作为\"枚举\"类型。通过具有 primitive 类型的 union ，您可以具有类型安全的枚举。稍后我们将介绍 union 类型。 3.作为\"函数集合”。由于基元可以具有函数，因此可以将函数分组为基元类型。您可以在标准库中看到这一点，例如，路径处理功能在 primitive Path中分组。\n// 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.out.print(\"Is door open? \" + isDoorOpen.string()) env.out.print(\"2 + 3 = \" + BasicMath.add(2,3).string()) primitive非常强大，尤其是作为枚举使用时。与其他语言中的枚举不同，枚举中的每个“值”都是完整类型，这使得将数据和函数附加到枚举值变得容易。\n内置基元类 primitive 关键字还用于引入某些内置的\"machine word\"类型。除了具有与之关联的值外，这些还类似于用户定义的原语。这些是：\n 布尔 。这是一个1位值，可能为true或false。 ISize，ILong，I8，I16，I32，I6​​4，I128 。各种宽度的有符号整数。 USize，ULong，U8，U16，U32，U64，U128 。各种宽度的无符号整数。 F32，F64 。各种宽度的浮点数。  ISize / USize 对应于本机类型size_t的位宽，该位宽因平台而异。 ILong / ULong 类似地对应于本机类型 long的位宽，该位宽也因平台而异。在所有Pony支持的平台上，本机int的位宽均相同，您可以使用 I32 / U32 来实现。\n基元类的初始化和销毁 基元可以具有两个特殊功能，_init和_final。在任何actor开始之前都会调用_init。在所有参与者都终止之后，将调用_final。这两个函数不带参数。不同的primitives的_init和_final函数始终按顺序执行。\n一个常见的用例是初始化和清理C语言的库，而不会承担actor不当使用的风险。\n","summary":"primitive（基元类） 和 class（类） 有两点主要区别：\n 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段意味着primitive不会产生副作用。只有一个实例意味着，如果您的代码以 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省\"machine word” primitives除外）。\nprimitive 有什么用途？ 基元类有三种主要用途（如果算上内置的\"machine word” primitives则有四种）。\n1.作为\"标记值”。例如，Pony经常使用 primitive None来表示某事物没有值。当然，它确实具有一个值，以便您可以检查它是什么，并且该值是“无”的单个实例。 2.作为\"枚举\"类型。通过具有 primitive 类型的 union ，您可以具有类型安全的枚举。稍后我们将介绍 union 类型。 3.作为\"函数集合”。由于基元可以具有函数，因此可以将函数分组为基元类型。您可以在标准库中看到这一点，例如，路径处理功能在 primitive Path中分组。\n// 2 \"marker values\" primitive OpenedDoor primitive ClosedDoor // An \"enumeration\" type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =\u003e a + b fun multiply(a: U64, b: U64): U64 =\u003e a * b actor Main new create(env: Env) =\u003e let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =\u003e true | ClosedDoor =\u003e false end env.","title":"基元类（Primitives）","uri":"https://damon-kwok.github.io/pony-tutorial/types/primitives.html"},{"content":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\nEvery programming language has literals to encode values of certain types, and so does Pony.\nIn Pony you can express booleans, numeric types, characters, strings and arrays as literals.\nBool型 There is true, there is false. That’s it.\n数值型 Numeric literals can be used to encode any signed or unsigned integer or floating point number.\nIn most cases Pony is able to infer the concrete type of the literal from the context where it is used (e.g. assignment to a field or local variable or as argument to a method/behaviour call).\nIt is possible to help the compiler determine the concrete type of the literal using a constructor of one of the numeric types:\n U8, U16, U32, U64, U128, USize, ULong I8, I16, I32, I64, I128, ISize, ILong F32, F64  let my_explicit_unsigned: U32 = 42_000 let my_constructor_unsigned = U8(1) let my_constructor_float = F64(1.234) Integer literals can be given as decimal, hexadecimal or binary:\nlet my_decimal_int: I32 = 1024 let my_hexadecimal_int: I32 = 0x400 let my_binary_int: I32 = 0b10000000000 Floating Point literals are expressed as standard floating point or scientific notation:\nlet my_double_precision_float: F64 = 0.009999999776482582092285156250 let my_scientific_float: F32 = 42.12e-4 字符型 Character literals are enclosed with single quotes (').\nCharacter literals, unlike String literals, encode to a single numeric value. Usually this is a single byte, a U8. But they can be coerced to any integer type:\nlet big_a: U8 = 'A' // 65 let hex_escaped_big_a: U8 = '\\x41' // 65 let newline: U32 = '\\n' // 10 The following escape sequences are supported:\n \\x4F hex escape sequence with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\'  多重字符（Multibyte Character literals） It is possible to have character literals that contain multiple characters. The resulting integer value is constructed byte by byte with each character representing a single byte in the resulting integer, the last character being the least significant byte:\nlet multiByte: U64 = 'ABCD' // 0x41424344 字符串 String literals are enclosed with double quotes \" or triple-quoted \"\"\". They can contain any kind of bytes and various escape sequences:\n \\u00FE unicode escape sequence with 4 hex digits encoding one code point \\u10FFFE unicode escape sequence with 6 hex digits encoding one code point \\x4F hex escape sequence for unicode letters with 2 hex digits (up to 0xFF) \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\0, \\\"  Each escape sequence encodes a full character, not byte.\nuse \"format\" actor Main new create(env: Env) =\u003e let pony = \"🐎\" let pony_hex_escaped = \"p\\xF6n\\xFF\" let pony_unicode_escape = \"\\U01F40E\" env.out.print(pony + \" \" + pony_hex_escaped + \" \" + pony_unicode_escape) for b in pony.values() do env.out.print(Format.int[U8](b, FormatHex)) end All string literals support multiline strings:\nlet stacked_ponies = \" 🐎 🐎 🐎 \" 字符串和编码 String Literals contain the bytes that were read from their source code file. Their actual value thus depends on the encoding of their source.\nConsider the following example:\nlet u_umlaut = \"ü\" If the file containing this code is encoded as UTF-8 the byte-value of u_umlaut will be: \\xc3\\xbc. If the file is encoded with ISO-8559-1 (Latin-1) its value will be \\xfc.\n多行字符串（Triple quoted Strings） For embedding multi-line text in string literals, there are triple quoted strings.\nlet triple_quoted_string_docs = \"\"\" Triple quoted strings are the way to go for long multiline text. They are extensively used as docstrings which are turned into api documentation. They get some special treatment, in order to keep Pony code readable: * The string literal starts on the line after the opening triple quote. * Common indentation is removed from the string literal so it can be conveniently aligned with the enclosing indentation e.g. each line of this literal will get its first two whitespaces removed * Whitespace after the opening and before the closing triple quote will be removed as well. The first line will be completely removed if it only contains whitespace. e.g. this strings first character is `T` not `\\n`. \"\"\" String Literal Instances When a single string literal is used several times in your Pony program, all of them will be converted to a single common instance. This means they will always be equal based on identity.\nlet pony = \"🐎\" let another_pony = \"🐎\" if pony is another_pony then // True, therefore this line will run. end 数组（Array Literals） Array literals are enclosed by square brackets. Array literal elements can be any kind of expressions. They are separated by semicolon or newline:\nlet my_literal_array = [ \"first\"; \"second\" \"third one on a new line\" ] 接口（Type inference） If the type of the array is not specified, the resulting type of the literal array expression is Array[T] ref where T (the type of the elements) is inferred as the union of all the element types:\nlet my_heterogenous_array = [ U64(42) \"42\" U64.min_value() ] In the above example the resulting array type will be Array[(U64|String)] ref because the array contains String and U64 elements.\nIf the variable or call argument the array literal is assigned to has a type, the literal is coerced to that type:\nlet my_stringable_array: Array[Stringable] ref = [ U64(0xA) \"0xA\" ] Here my_stringable_array is coerced to Array[Stringable] ref. This works because Stringable is a trait that both String and U64 implement.\nIt is also possible to return an array with a different Reference Capability than ref just by specifying it on the type:\nlet my_immutable_array: Array[Stringable] val = [ U64(0xBEEF) \"0xBEEF\" ] This way array literals can be used for creating arrays of any Reference Capability.\nas表达式 It is also possible to give the literal a hint on what kind of type it should coerce the array elements to using an as Expression. The expression with the desired array element type needs to be added right after the opening square bracket, delimited by a colon:\nlet my_as_array = [ as Stringable: U64(0xFFEF) \"0xFFEF\" U64(1 + 1) ] This array literal is coerced to be an Array[Stringable] ref according to the as expression.\nIf a type is specified on the left-hand side, it needs to exactly match the type in the as expression.\n数组和引用 Constructing an array with a literal creates new references to its elements. Thus, to be 100% technically correct, array literal elements are inferred to be the alias of the actual element type. If all elements are of type T the array literal will be inferred as Array[T!] ref that is as an array of aliases of the type T.\nIt is thus necessary to use elements that can have more than one reference of the same type (e.g. types with val or ref capability) or use ephemeral types for other capabilities (as returned from constructors or the consume expression).\n","summary":"What do we want?\nValues!\nWhere do we want them?\nIn our Pony programs!\nSay no more\nEvery programming language has literals to encode values of certain types, and so does Pony.\nIn Pony you can express booleans, numeric types, characters, strings and arrays as literals.\nBool型 There is true, there is false. That’s it.\n数值型 Numeric literals can be used to encode any signed or unsigned integer or floating point number.","title":"字面量（Literals）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/literals.html"},{"content":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n A capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.\n So what’s that token? It’s an address. A pointer. A reference. It’s just… an object.\nHow is that unforgeable? Since Pony has no pointer arithmetic and is both type-safe and memory-safe, object references can’t be “invented” (i.e. forged) by the program. You can only get one by constructing an object or being passed an object.\nWhat about the C FFI? Using the C FFI can break this guarantee. We’ll talk about the C FFI trust boundary later, and how to control it.\nWhat about global variables? They’re bad! Because you can get them without either constructing them or being passed them.\nGlobal variables are a form of what is called ambient authority. Another form of ambient authority is unfettered access to the file system.\nPony has no global variables and no global functions. That doesn’t mean all ambient authority is magically gone - we still need to be careful about the file system, for example. Having no globals is necessary, but not sufficient, to eliminate ambient authority.\nHow does this help? Instead of having permissions lists, access control lists, or other forms of security, the object-capabilities model means that if you have a reference to an object, you can do things with that object. Simple and effective.\nThere’s a great paper on how the object-capability model works, and it’s pretty easy reading:\n权能梦碎——对象权能模型跌落神坛\nCapabilities and concurrency The object-capability model on its own does not address concurrency. It makes clear what will happen if there is simultaneous access to an object, but it does not prescribe a single method of controlling this.\nCombining capabilities with the actor-model is a good start, and has been done before in languages such as E and Joule.\nPony does this and also uses a system of reference capabilities in the type system.\n","summary":"Pony的类型安装系统是构建在对象权能模型的理论基础上的。感觉上很复杂，但是其实非常简单优雅，这是对象权能模型的核心概念：\n A capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.\n So what’s that token? It’s an address. A pointer. A reference. It’s just… an object.\nHow is that unforgeable? Since Pony has no pointer arithmetic and is both type-safe and memory-safe, object references can’t be “invented” (i.e. forged) by the program.","title":"对象权能模型（Object Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities/object-capabilities.html"},{"content":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 类似于 函数，不过函数是 同步执行 的，但是行为是 异步执行 的。换句话说，当您调用一个函数时，该函数将立即执行，并且立即就可以得到函数的返回值。函数就像其他面向对象语言中的方法调用一样。\n但是调用行为，__不会__立即执行。相反，该行为的将在将来某个不确定的时间执行。\n行为看起来像一个函数，但是它不是由关键字fun定义的，而是使用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何功能的接收器上调用行为），您不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None，就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) Here we have an Aardvark that can eat asynchronously. Clever Aardvark. 在这里，我们有一个可以异步进餐的“土豚”。聪明的土豚。\n消息处理 如果您熟悉基于语言的语言（例如Erlang），那么您将熟悉“消息传递”的概念。演员之间就是这样交流的。行为等同于小马。当您调用演员的行为时，您正在向其发送消息。\n如果您不熟悉消息传递，则不必担心。我们已经覆盖了您。所有内容将在下面说明。\n并发 由于行为是异步的，因此可以同时运行一系列行为的主体。这正是Pony所做的。 Pony运行时具有自己的协作调度程序，默认情况下，该调度程序的线程数等于您计算机上的CPU内核数。每个调度程序线程可以在任何给定时间执行参与者行为，因此Pony程序自然是并发的。\n执行次序 Actor本身是有序的。也就是说，每个actor一次只能执行一个行为。这意味着可以在不考虑并发性的情况下编写actor中的所有代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，演员应该只执行顺序要执行的操作。其他任何东西都可以分解为另一个actor，使其自动并行。\n在下面的示例中，Main actor调用了一个行为call_me_later，正如我们所知，该行为是_asynchronous_，因此我们无需等待它运行就可以继续。然后，我们运行方法“ env.out.print”，它也是_asynchronous_，并将提供的文本打印到终端。现在，我们已经完成了在Main角色中执行代码的工作，我们先前调用的行为最终将运行，并且将打印最后的文本。\nactor Main new create(env: Env) =\u003e call_me_later(env) env.out.print(\"This is printed first\") be call_me_later(env: Env) =\u003e env.out.print(\"This is printed last\") 由于所有这些代码都在同一个actor中运行，并且对其他行为env.out.print的调用也都是顺序的，因此我们可以确保始终在 before 之前打印出\"This is printed last\"。\n为什么这些代码时安全的？ 因为Pony拥有 权能安全类型系统 。在谈论函数接收器参考功能之前，我们已经简要提到了引用权能。简短的版本是它们是对类型的注释，这些注释使所有这些并行性安全无任何运行时开销。\n稍后我们将深入介绍参考功能。\nActor的开销非常低 如果您以前做过并发编程，您将知道线程可能很昂贵。上下文切换可能会导致问题，每个线程都需要一个堆栈（可能会占用很多内存），并且您需要大量的锁和其他机制来编写线程安全的代码。\n但是演员很便宜。真便宜。与对象相比，演员的额外开销约为256个字节的内存。字节，而不是千字节！而且没有锁，也没有上下文切换。除了少数几个额外的内存字节外，没有执行的actor不会消耗资源。\n编写一个使用成千上万演员的Pony程序是很正常的。\nActor finalisers 像班级一样，演员可以有终结者。终结器的定义是相同的（fun _final（））。类终结者的所有保证和限制也对演员终结者有效。另外，参与者的终结器被调用后，它将不再收到任何其他消息。\n","summary":"actor 和 类 的关键区别：actor可以有 行为 。\nBehaviours 行为 行为 类似于 函数，不过函数是 同步执行 的，但是行为是 异步执行 的。换句话说，当您调用一个函数时，该函数将立即执行，并且立即就可以得到函数的返回值。函数就像其他面向对象语言中的方法调用一样。\n但是调用行为，__不会__立即执行。相反，该行为的将在将来某个不确定的时间执行。\n行为看起来像一个函数，但是它不是由关键字fun定义的，而是使用be关键字。\n和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何功能的接收器上调用行为），您不能为行为指定返回类型。\n那么行为会返回什么呢？ 行为总是返回None，就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。\nactor Aardvark let name: String var _hunger_level: U64 = 0 new create(name': String) =\u003e name = name' be eat(amount: U64) =\u003e _hunger_level = _hunger_level - amount.min(_hunger_level) Here we have an Aardvark that can eat asynchronously. Clever Aardvark. 在这里，我们有一个可以异步进餐的“土豚”。聪明的土豚。\n消息处理 如果您熟悉基于语言的语言（例如Erlang），那么您将熟悉“消息传递”的概念。演员之间就是这样交流的。行为等同于小马。当您调用演员的行为时，您正在向其发送消息。\n如果您不熟悉消息传递，则不必担心。我们已经覆盖了您。所有内容将在下面说明。\n并发 由于行为是异步的，因此可以同时运行一系列行为的主体。这正是Pony所做的。 Pony运行时具有自己的协作调度程序，默认情况下，该调度程序的线程数等于您计算机上的CPU内核数。每个调度程序线程可以在任何给定时间执行参与者行为，因此Pony程序自然是并发的。\n执行次序 Actor本身是有序的。也就是说，每个actor一次只能执行一个行为。这意味着可以在不考虑并发性的情况下编写actor中的所有代码：不需要锁，信号量或类似的东西。\n在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，演员应该只执行顺序要执行的操作。其他任何东西都可以分解为另一个actor，使其自动并行。\n在下面的示例中，Main actor调用了一个行为call_me_later，正如我们所知，该行为是_asynchronous_，因此我们无需等待它运行就可以继续。然后，我们运行方法“ env.out.print”，它也是_asynchronous_，并将提供的文本打印到终端。现在，我们已经完成了在Main角色中执行代码的工作，我们先前调用的行为最终将运行，并且将打印最后的文本。","title":"并发单元（Actors）","uri":"https://damon-kwok.github.io/pony-tutorial/types/actors.html"},{"content":"首先我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来我们逐行解释。\n第一行 actor Main 这是一个类型声明。关键字actor表示我们定义了一个并发单元，但是暂时你只需要了解到这是Pony中的声明Main函数的做法，等同于于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲解。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Mainactor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是表示程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。关键字new表示它可以创建类型实例，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。我们可以用不同的构造函数创建特定的实例。这里我们用的是默认构造函数create。\n接下来构造函数的参数。这里我们的构造函数里定义了一个名为env的参数，类型为Env。\nPony的参数类型总是在参数之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、Typecript等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体是什么？怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定一个.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout ，内容会被输出到控制台。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号的定义方式是C/C++的风格的（支持\\n方式的转译）。三引号\"\"\"可以定义是Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是你的程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony不允许全局变量，所以你可以通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名字为Main actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。接下来我们会讲解Pony的类型系统。\n","summary":"首先我们来看一下helloworld代码：\nactor Main new create(env: Env) =\u003e env.out.print(\"Hello, world!\") 接下来我们逐行解释。\n第一行 actor Main 这是一个类型声明。关键字actor表示我们定义了一个并发单元，但是暂时你只需要了解到这是Pony中的声明Main函数的做法，等同于于Python, Java, C#, C++等语言中的程序入口。Pony中也有类的概念，后面会讲解。\nactor和类的区别是：actor可以异步执行函数，这些函数在Pony中被称为行为（behaviours）。后面会讲到。\nPony程序中的Mainactor跟C、C++中的main函数，或者Java、C#中的Main方法类似，都是表示程序的入口。\n第二行 new create(env: Env) =\u003e 这是一个构造函数。关键字new表示它可以创建类型实例，这个实例的类型就是Main。\n和其他语言不同，Pony的构造函数可以有名字。我们可以用不同的构造函数创建特定的实例。这里我们用的是默认构造函数create。\n接下来构造函数的参数。这里我们的构造函数里定义了一个名为env的参数，类型为Env。\nPony的参数类型总是在参数之后，并且需要用冒号分割。如果你熟悉C、C++、Java、C#，你可能习惯了Env env的写法,不过Pony的参数写法其实也是很常见的（比如在Go、Pascal、Rust、Typecript等语言中）。\n现在明白了，Main actor 有一个默认构造函数，它接受单个参数，参数类型为Env。程序的入口就是构造函数的函数体。\n函数体是什么？怎么定义？ 注意看=\u003e后面的代码。\n第三行 env.out.print(\"Hello, world!\") 这个函数体里面就是你的代码。\n在Pony中，怎么确定一个.的作用是字段访问还是方法调用？注意观察小括号。有小括号就是方法调用，没有就是字段访问。\n这行代码引用了env参数。 首先调用了env的out字段，这个字段表示 （标准输出流）stdout ，内容会被输出到控制台。 然后，调用out的print函数，将\"hello,world!“字符串输出到控制台。\nPony中的字符串定义可以使用双引号\"也可以使用三引号。双引号的定义方式是C/C++的风格的（支持\\n方式的转译）。三引号\"\"\"可以定义是Python风格的原始字符串，内容不会被转译。\nEnv是什么？ 它是你的程序执行的上下文信息，其中包含命令行参数、环境变量、标准输入流、标准输出流、标准错误流。Pony不允许全局变量，所以你可以通过Env来初始化配置。\n总结 就是这样。Pony程序开始运行时会创建一个名字为Main actor实例，然后执行里面的逻辑：打印\"hello,woeld!“到标准输出流。接下来我们会讲解Pony的类型系统。","title":"庖丁解牛","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started/how-it-works.html"},{"content":"Since types are guarantees, it’s useful to talk about what guarantees a reference capability makes.\nWhat is denied We’re going to talk about reference capability guarantees in terms of what’s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?\nWe need to distinguish between the actor that contains the variable in question and other actors.\nThis is important because data reads and writes from other actors may occur concurrently. If two actors can both read the same data and one of them changes it then it will change under the feet of the other actor. This leads to data-races and the need for locks. By ensuring this situation can never occur, Pony eliminates the need for locks.\nAll code within any one actor always executes sequentially. This means that data accesses from multiple variables within a single actor do not suffer from data-races.\nMutable reference capabilities The mutable reference capabilities are iso, trn and ref. These reference capabilities are mutable because they can be used to both read from and write to an object.\n If an actor has an iso variable, no other variable can be used by any actor to read from or write to that object. This means an iso variable is the only variable anywhere in the program that can read from or write to that object. It is read and write unique. If an actor has a trn variable, no other variable can be used by any actor to write to that object, and no other variable can be used by other actors to read from or write to that object. This means a trn variable is the only variable anywhere in the program that can write to that object, but other variables held by the same actor may be able to read from it. It is write unique. If an actor has a ref variable, no other variable can be used by other actors to read from or write to that object. This means that other variables can be used to read from and write to the object, but only from within the same actor.  Why can they be used to write? Because they all stop other actors from reading from or writing to the object. Since we know no other actor will be reading, it’s safe for us to write to the object, without having to worry about data-races. And since we know no other actor will be writing, it’s safe for us to read from the object, too.\nImmutable reference capabilities The immutable reference capabilities are val and box. These reference capabilities are immutable because they can be used to read from an object, but not to write to it.\n If an actor has a val variable, no other variable can be used by any actor to write to that object. This means that the object can’t ever change. It is globally immutable. If an actor has a box variable, no other variable can be used by other actors to write to that object. This means that other actors may be able to read the object and other variables in the same actor may be able to write to it (although not both). In either case, it is safe for us to read. The object is locally immutable.  Why can they be used to read but not write? Because these reference capabilities only stop other actors from writing to the object. That means there is no guarantee that other actors aren’t reading from the object, which means it’s not safe for us to write to it. It’s safe for more than one actor to read from an object at the same time though, so we’re allowed to do that.\nOpaque reference capabilities There’s only one opaque reference capability, which is tag. A tag variable makes no guarantees about other variables at all. As a result, it can’t be used to either read from or write to the object; hence the name opaque.\nIt’s still useful though: you can do identity comparison with it, you can call behaviours on it, and you can call functions on it that only need a tag receiver.\nWhy can’t tag be used to read or write? Because tag doesn’t stop other actors from writing to the object. That means if we tried to read, we would have no guarantee that there wasn’t some other actor writing to the object, so we might get a race condition.\n","summary":"Since types are guarantees, it’s useful to talk about what guarantees a reference capability makes.\nWhat is denied We’re going to talk about reference capability guarantees in terms of what’s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?\nWe need to distinguish between the actor that contains the variable in question and other actors.\nThis is important because data reads and writes from other actors may occur concurrently.","title":"引用权能保证（Reference Capability Guarantees）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/guarantees.html"},{"content":"So if the object is the capability, what controls what we can do with the object? How do we express our access rights on that object?\nIn Pony, we do it with reference capabilities.\nRights are part of a capability If you open a file in UNIX and get a file descriptor back, that file descriptor is a token that designates an object - but it isn’t a capability. To be a capability, we need to open that file with some permission - some access right. For example:\nint fd = open(\"/etc/passwd\", O_RDWR); Now we have a token and a set of rights.\nIn Pony, every reference has both a type and a reference capability. In fact, the reference capability is part of its type. These allow you to specify which of your objects can be shared with other actors and allow the compiler to check that what you’re doing is concurrency safe.\nBasic concepts There are a few simple concepts you need to understand before reference capabilities will make any sense. We’ve talked about some of these already, and some may already be obvious to you, but it’s worth recapping here.\nShared mutable data is hard\nThe problem with concurrency is shared mutable data. If two different threads have access to the same piece of data then they might try to update it at the same time. At best this can lead to the two threads having different versions of the data. At worst the updates can interact badly resulting in the data being overwritten with garbage. The standard way to avoid these problems is to use locks to prevent data updates from happening at the same time. This causes big performance hits and is very difficult to get right, so it causes lots of bugs.\nImmutable data can be safely shared\nAny data that is immutable (i.e. it cannot be changed) is safe to use concurrently. Since it is immutable it is never updated and it’s the updates that cause concurrency problems.\nIsolated data is safe\nIf a block of data has only one reference to it then we call it isolated. Since there is only one reference to it, isolated data cannot be shared by multiple threads, so there are no concurrency problems. Isolated data can be passed between multiple threads. As long as only one of them has a reference to it at a time then the data is still safe from concurrency problems.\nIsolated data may be complex\nAn isolated piece of data may be a single byte. But it can also be a large data structure with multiple references between the various objects in that structure. What matters for the data to be isolated is that there is only a single reference to that structure as a whole. We talk about the isolation boundary of a data structure. For the structure to be isolated:\n There must only be a single reference outside the boundary that points to an object inside. There can be any number of references inside the boundary, but none of them must point to an object outside.  Every actor is single threaded\nThe code within a single actor is never run concurrently. This means that, within a single actor, data updates cannot cause problems. It’s only when we want to share data between actors that we have problems.\nOK, safely sharing data concurrently is tricky. How do reference capabilities help?\nBy sharing only immutable data and exchanging only isolated data we can have safe concurrent programs without locks. The problem is that it’s very difficult to do that correctly. If you accidentally hang on to a reference to some isolated data you’ve handed over or change something you’ve shared as immutable then everything goes wrong. What you need is for the compiler to force you to live up to your promises. Pony reference capabilities allow the compiler to do just that.\nType qualifiers If you’ve used C/C++, you may be familiar with const, which is a type qualifier that tells the compiler not to allow the programmer to mutate something.\nA reference capability is a form of type qualifier and provides a lot more guarantees than const does!\nIn Pony, every use of a type has a reference capability. These capabilities apply to variables, rather than to the type as a whole. In other words, when you define a class Wombat, you don’t pick a reference capability for all instances of the class. Instead, Wombat variables each have their own reference capability.\nAs an example, in some languages, you have to define a type that represents a mutable String and another type that represents an immutable String. For example, in Java, there is a String and a StringBuilder. In Pony, you can define a single class String and have some variables that are String ref (which are mutable) and other variables that are String val (which are immutable).\nThe list of reference capabilities There are six reference capabilities in Pony and they all have strict definitions and rules on how they can be used. We’ll get to all of that later, but for now here are their names and what you use them for:\nIsolated, written iso. This is for references to isolated data structures. If you have an iso variable then you know that there are no other variables that can access that data. So you can change it however you like and give it to another actor.\nValue, written val. This is for references to immutable data structures. If you have a val variable then you know that no-one can change the data. So you can read it and share it with other actors.\nReference, written ref. This is for references to mutable data structures that are not isolated, in other words, “normal” data. If you have a ref variable then you can read and write the data however you like and you can have multiple variables that can access the same data. But you can’t share it with other actors.\nBox. This is for references to data that is read-only to you. That data might be immutable and shared with other actors or there may be other variables using it in your actor that can change the data. Either way, the box variable can be used to safely read the data. This may sound a little pointless, but it allows you to write code that can work for both val and ref variables, as long as it doesn’t write to the object.\nTransition, written trn. This is used for data structures that you want to write to, while also holding read-only (box) variables for them. You can also convert the trn variable to a val variable later if you wish, which stops anyone from changing the data and allows it be shared with other actors.\nTag. This is for references used only for identification. You cannot read or write data using a tag variable. But you can store and compare tags to check object identity and share tag variables with other actors.\nNote that if you have a variable referring to an actor then you can send messages to that actor regardless of what reference capability that variable has.\nHow to write a reference capability A reference capability comes at the end of a type. So, for example:\nString iso // An isolated string String trn // A transition string String ref // A string reference String val // A string value String box // A string box String tag // A string tag What does it mean when a type doesn’t specify a reference capability? It means you are using the default reference capability for that type, which is defined along with the type. Here’s an example from the standard library:\nclass val String When we use a String we usually mean an immutable string value, so we make val the default reference capability for String (but not necessarily for String constructors, see below). For example, when we don’t specify the capability in the following code, the compiler understands that we are using the default reference capability val specified in the type definition:\nlet a: String val = \"Hello, world!\" let b: String = \"I'm a wombat!\" // Also a String val So do I have to specify a reference capability when I define a type? Only if you want to. There are sensible defaults that most types will use. These are ref for classes, val for primitives (i.e. immutable references), and tag for actors.\nHow to create objects with different capabilities When you write a constructor, by default, that constructor will either create a new object with ref or tag as the capability. In the case of actors, the constructor will always create a tag. For classes, if defaults to ref but you can create with other capabilities. Let’s take a look at an example:\nclass Foo let x: U32 new val create(x': U32) =\u003e x = x' Now when you call Foo.create(1), you’ll get a Foo val instead of Foo ref. But what if you want to create both val and ref Foos? You could do something like this:\nclass Foo let x: U32 new val create_val(x': U32) =\u003e x = x' new ref create_ref(x': U32) =\u003e x = x' But, that’s probably not what you’d really want to do. Better to use the capabilities recovery facilities of Pony that we’ll cover that later in the Recovering Capabilities section.\n","summary":"So if the object is the capability, what controls what we can do with the object? How do we express our access rights on that object?\nIn Pony, we do it with reference capabilities.\nRights are part of a capability If you open a file in UNIX and get a file descriptor back, that file descriptor is a token that designates an object - but it isn’t a capability. To be a capability, we need to open that file with some permission - some access right.","title":"引用权能（Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html"},{"content":"All Pony code that actually does something, rather than defining types etc, appears in named blocks which are referred to as methods. There are three kinds of methods: functions, constructors, and behaviours. All methods are attached to type definitions (e.g. classes) - there are no global functions.\nBehaviours are used for handling asynchronous messages sent to actors, which we’ve seen in the “Types” chapter when we talked about actors.\nCan I have some code outside of any methods like I do in Python? No. All Pony code must be within a method.\nFunctions Pony functions are quite like functions (or methods) in other languages. They can have 0 or more parameters and 0 or 1 return values. If the return type is omitted then the function will have a return value of None.\nclass C fun add(x: U32, y: U32): U32 =\u003e x + y fun nop() =\u003e add(1, 2) // Pointless, we ignore the result The function parameters (if any) are specified in parentheses after the function name. Functions that don’t take any parameters still need to have the parentheses.\nEach parameter is given a name and a type. In our example function add has 2 parameters, x and y, both of which are type U32. The values passed to a function call (the 1 and 2 in our example) are called arguments and when the call is made they are evaluated and assigned to the parameters. Parameters may not be assigned to within the function - they are effectively declared let.\nAfter the parameters comes the return type. If nothing will be returned this is simply omitted.\nAfter the return value, there’s a =\u003e and then finally the function body. The value returned is simply the value of the function body (remember that everything is an expression), which is simply the value of the last command in the function.\nIf you want to exit a function early then use the return command. If the function has a return type then you need to provide a value to return. If the function does not have a return type then return should appear on its own, without a value.\nCan I overload functions by argument type? No, you cannot have multiple methods with the same name in the same type.\nConstructors Pony constructors are used to initialise newly created objects, as in many languages. However, unlike many languages, Pony constructors are named so you can have as many as you like, taking whatever parameters you like. By convention, the main constructor of each type (if there is such a thing for any given type) is called create.\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x The purpose of a constructor is to set up the internal state of the object being created. To ensure this is done constructors must initialise all the fields in the object being constructed.\nCan I exit a constructor early? Yes. Just then use the return command without a value. The object must already be in a legal state to do this.\nCalling As in many other languages, methods in Pony are called by providing the arguments within parentheses after the method name. The parentheses are required even if there are no arguments being passed to the method.\nclass Foo fun hello(name: String): String =\u003e \"hello \" + name fun f() =\u003e let a = hello(\"Fred\") Constructors are usually called “on” a type, by specifying the type that is to be created. To do this just specify the type, followed by a dot, followed by the name of the constructor you want to call.\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = Foo.from_int(3) Functions are always called on an object. Again just specify the object, followed by a dot, followed by the name of the function to call. If the object to call on is omitted then the current object is used (i.e. this).\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x fun get(): U32 =\u003e _x class Bar fun f() =\u003e var a: Foo = Foo.from_int(3) var b: U32 = a.get() var c: U32 = g(b) fun g(x: U32): U32 =\u003e x + 1 Constructors can also be called on an expression. Here an object is created of the same type as the specified expression - this is equivalent to directly specifying the type.\nclass Foo var _x: U32 new create() =\u003e _x = 0 new from_int(x: U32) =\u003e _x = x class Bar fun f() =\u003e var a: Foo = Foo.create() var b: Foo = a.from_int(3) We can even reuse the variable name in the assignment expression to call the constructor.\nclass Bar fun f() =\u003e var a: Foo = a.create() Here we specify that var a is type Foo, then proceed to use a to call the constructor, create(), for objects of type Foo.\nDefault arguments When defining a method you can provide default values for any of the arguments. The caller then has the choice to use the values you have provided or to provide their own. Default argument values are specified with a = after the parameter name.\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create() // Contains (0, 0) var b: Coord = Coord.create(3) // Contains (3, 0) var c: Coord = Coord.create(3, 4) // Contains (3, 4) Do I have to provide default values for all of my arguments? No, you can provide defaults for as many, or as few, as you like.\nNamed arguments So far, when calling methods we have always given all the arguments in order. This is known as using positional arguments. However, we can also specify the arguments in any order by specifying their names. This is known as using named arguments.\nTo call a method using named arguments the where keyword is used, followed by the named arguments and their values.\nclass Coord var _x: U32 var _y: U32 new create(x: U32 = 0, y: U32 = 0) =\u003e _x = x _y = y class Bar fun f() =\u003e var a: Coord = Coord.create(3, 4) // Contains (3, 4) var b: Coord = Coord.create(where y = 4, x = 3) // Contains (3, 4) Note how in b above, the arguments were given out of order by using where followed using the name of the arguments.\nShould I specify where for each named argument? No. There must be only one where in a method call.\nNamed and positional arguments can be used together in a single call. Just start with the positional arguments you want to specify, then a where and finally the named arguments. But be careful, each argument must be specified only once.\nDefault arguments can also be used in combination with positional and named arguments - just miss out any for which you want to use the default.\nclass Foo fun f(a: U32 = 1, b: U32 = 2, c: U32 = 3, d: U32 = 4, e: U32 = 5): U32 =\u003e 0 fun g() =\u003e f(6, 7 where d = 8) // Equivalent to: f(6, 7, 3, 8, 5) Can I call using positional arguments but miss out the first one? No. If you use positional arguments they must be the first ones in the call.\nChaining Method chaining allows you to chain calls on an object without requiring the method to return its receiver. The syntax to call a method and chain the receiver is object.\u003emethod(), which is roughly equivalent to (object.method() ; object). Chaining a method discards its normal return value.\nprimitive Printer fun print_two_strings(out: StdStream, s1: String, s2: String) =\u003e out.\u003eprint(s1).\u003eprint(s2) // Equivalent to: out.print(s1) out.print(s2) out Note that the last .\u003e in a chain can be a . if the return value of the last call matters.\ninterface Factory fun add_option(o: Option) fun make_object(): Object primitive Foo fun object_wrong(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).\u003emake_object() // Error! The expression returns a Factory fun object_right(f: Factory, o1: Option, o2: Option): Object =\u003e f.\u003eadd_option(o1).\u003eadd_option(o2).make_object() // Works. The expression returns an Object Anonymous methods Pony has anonymous methods (or Lambdas). They look like this:\nuse \"collections\" actor Main new create(env: Env) =\u003e let list_of_numbers = List[U32].from([1; 2; 3; 4]) let is_odd = {(n: U32): Bool =\u003e (n % 2) == 1} for odd_number in list_of_numbers.filter(is_odd).values() do env.out.print(odd_number.string()) end They are presented more in-depth in the Object Literals section.\nPrivacy In Pony, method names start either with a lower case letter or with an underscore followed by a lowercase letter. Methods with a leading underscore are private. This means they can only be called by code within the same package. Methods without a leading underscore are public and can be called by anyone.\nCan I start my method name with 2 (or more) underscores? No. If the first character is an underscore then the second one MUST be a lower case letter.\nPrecedence We have talked about precedence of operators before, and in Pony, method calls and field accesses have higher precedence than any operators.\nTo sum up, in complex expressions,\n Method calls and field accesses have higher precedence than any operators. Unary operator have higher precedence than infix operators. When mixing infix operators in complex expressions, we must use parentheses to specify precedences explicitly.  ","summary":"All Pony code that actually does something, rather than defining types etc, appears in named blocks which are referred to as methods. There are three kinds of methods: functions, constructors, and behaviours. All methods are attached to type definitions (e.g. classes) - there are no global functions.\nBehaviours are used for handling asynchronous messages sent to actors, which we’ve seen in the “Types” chapter when we talked about actors.\nCan I have some code outside of any methods like I do in Python?","title":"方法（Methods）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/methods.html"},{"content":"A recover expression lets you “lift” the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.\nWhy is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:\n Creating a cyclic immutable data structure. That is, you can create a complex mutable data structure inside a recover expression, “lift” the resulting ref to a val. “Borrow” an iso as a ref, do a series of complex mutable operations on it, and return it as an iso again. “Extract” a mutable field from an iso and return it as an iso.  What does this look like? The recover expression wraps a list of expressions and is terminated by an end, like this:\nrecover Array[String].create() end This expression returns an Array[String] iso, instead of the usual Array[String] ref you would get. The reason it is iso and not any of the other mutable reference capabilities is because there is a default reference capability when you don’t specify one. The default for any mutable reference capability is iso and the default for any immutable reference capability is val.\nHere’s a more complicated example from the standard library:\nrecover var s = String((prec + 1).max(width.max(31))) var value = x try if value == 0 then s.push(table(0)?) else while value != 0 do let index = ((value = value / base) - (value * base)) s.push(table(index.usize())?) end end end _extend_digits(s, prec') s.append(typestring) s.append(prestring) _pad(s, width, align, fill) s end That’s from format/_FormatInt. It creates a String ref, does a bunch of stuff with it, and finally returns it as a String iso.\nYou can also give an explicit reference capability:\nlet key = recover val line.substring(0, i).\u003estrip() end That’s from net/http/_PayloadBuilder. We get a substring of line, which is a String iso^, then we call strip on it, which returns itself. But since strip is a ref function, it returns itself as a String ref^ - so we use a recover val to end up with a String val.\nHow does this work? Inside the recover expression, your code only has access to sendable values from the enclosing lexical scope. In other words, you can only use iso, val and tag things from outside the recover expression.\nThis means that when the recover expression finishes, any aliases to the result of the expression other than iso, val and tag ones won’t exist anymore. That makes it safe to “lift” the reference capability of the result of the expression.\nIf the recover expression could access non-sendable values from the enclosing lexical scope, “lifting” the reference capability of the result wouldn’t be safe. Some of those values could “leak” into an iso or val result, and result in data races.\nAutomatic receiver recovery When you have an iso or trn receiver, you normally can’t call ref methods on it. That’s because the receiver is also an argument to a method, which means both the method body and the caller have access to the receiver at the same time. And that means we have to alias the receiver when we call a method on it. The alias of an iso is a tag (which isn’t a subtype of ref) and the alias of a trn is a box (also not a subtype of ref).\nBut we can get around this! If all the arguments to the method (other than the receiver, which is the implicit argument being recovered) at the call-site are sendable, and the return type of the method is either sendable or isn’t used at the call-site, then we can “automatically recover” the receiver. That just means we don’t have to alias the receiver - and that means we can call ref methods on an iso or trn, since iso and trn are both subtypes of ref.\nNotice that this technique looks mostly at the call-site, rather than at the definition of the method being called. That makes it more flexible. For example, if the method being called wants a ref argument, and we pass it an iso argument, that’s sendable at the call-site, so we can still do automatic receiver recovery.\nThis may sound a little complicated, but in practice, it means you can write code that treats an iso mostly like a ref, and the compiler will complain when it’s wrong. For example:\nlet s = recover String end s.append(\"hi\") Here, we create a String iso and then append some text to it. The append method takes a ref receiver and a box parameter. We can automatically recover the iso receiver since we pass a val parameter, so everything is fine.\n","summary":"A recover expression lets you “lift” the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.\nWhy is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:","title":"权能借用（Recovering Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html"},{"content":"Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.\nSimple substitution First, let’s cover substitution without worrying about ephemeral types (^) or alias types (!). The \u003c: symbol means “is a subtype of” or alternatively “can be substituted for”.\n iso \u003c: trn. An iso is read and write unique, and a trn is just write unique, so it’s safe to substitute an iso for a trn. trn \u003c: ref. A trn is mutable and also write unique. A ref is mutable but makes no uniqueness guarantees. It’s safe to substitute a trn for a ref. trn \u003c: val. This one is interesting. A trn is write unique and a val is globally immutable, so why is it safe to substitute a trn for a val? The key is that, in order to do so, you have to give up the trn you have. If you give up the only variable that can write to an object, you know that no variable can write to it. That means it’s safe to consider it globally immutable. ref \u003c: box. A ref guarantees no other actor can read from or write to the object. A box just guarantees no other actor can write to the object, so it’s safe to substitute a ref for a box. val \u003c: box. A val guarantees no actor, not even this one, can write to the object. A box just guarantees no other actor can write to the object, so it’s safe to substitute a val for a box. box \u003c: tag. A box guarantees no other actor can write to the object, and a tag makes no guarantees at all, so it’s safe to substitute a box for a tag.  Subtyping is transitive. That means that since iso \u003c: trn and trn \u003c: ref and ref \u003c: box, we also get iso \u003c: box.\nAliased substitution Now let’s consider what happens when we have an alias of a reference capability. For example, if we have some iso and we alias it (without doing a consume or a destructive read), the type we get is iso!, not iso.\n iso! \u003c: tag. This is a pretty big change. Instead of being a subtype of everything like iso, the only thing an iso! is a subtype of is tag. This is because the iso still exists, and is still read and write unique. Any alias can neither read from nor write to the object. That means an iso! can only be a subtype of tag. trn! \u003c: box. This is a change too, but not as big a change. Since trn is only write unique, it’s ok for aliases to read from the object, but it’s not ok for aliases to write to the object. That means we could have box or val aliases - except val guarantees that no alias can write to the object! Since our trn still exists and can write to the object, a val alias would break the guarantees that val makes. So a trn! can only be a subtype of box (and, transitively, tag as well). ref! \u003c: ref. Since a ref only guarantees that other actors can neither read from nor write to the object, it’s ok to make more ref aliases within the same actor. val! \u003c: val. Since a val only guarantees that no actor can write to the object, its ok to make more val aliases since they can’t write to the object either. box! \u003c: box. A box only guarantees that other actors can’t write to the object. Both val and ref make that guarantee too, so why can box only alias as box? It’s because we can’t make more guarantees when we alias something. That means box can only alias as box. tag! \u003c: tag. A tag doesn’t make any guarantees at all. Just like with a box, we can’t make more guarantees when we make a new alias, so a tag can only alias as a tag.  Ephemeral substitution The last case to consider is when we have an ephemeral reference capability. For example, if we have some iso and we consume it or do a destructive read, the type we get is iso^, not iso.\n iso^ \u003c: iso. This is pretty simple. When we give an iso^ a name, by assigning it to something or passing it as an argument to a method, it loses the ^ and becomes a plain old iso. We know we gave up our previous iso, so it’s safe to have a new one. trn^ \u003c: trn. This works exactly like iso^. The guarantee is weaker (write uniqueness instead of read and write uniqueness), but it works the same way. ref^ \u003c: ref^ and ref^ \u003c: ref and ref \u003c: ref^. Here, we have another case. Not only is a ref^ a subtype of a ref, it’s also a subtype of a ref^. What’s going on here? The reason is that an ephemeral reference capability is a way of saying “a reference capability that, when aliased, results in the base reference capability”. Since a ref can be aliased as a ref, that means ref and ref^ are completely interchangeable. val^, box^, tag^. These all work the same way as ref, that is, they are interchangeable with the base reference capability. It’s for the same reason: all of these reference capabilities can be aliased as themselves.  Why do ref^, val^, box^, and tag^ exist if they are interchangeable with their base reference capabilities? It’s for two reasons: reference capability recovery and generics. We’ll cover both of those later.\n","summary":"Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.\nSimple substitution First, let’s cover substitution without worrying about ephemeral types (^) or alias types (!). The \u003c: symbol means “is a subtype of” or alternatively “can be substituted for”.\n iso \u003c: trn. An iso is read and write unique, and a trn is just write unique, so it’s safe to substitute an iso for a trn.","title":"权能包含关系（Capability Subtyping）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html"},{"content":"When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.\nThis is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.\nViewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation. That is, the origin has a viewpoint, and can “see” its fields only from that viewpoint.\nLet’s start with a table. This shows how fields of each capability “look” to origins of each capability.\n    ▷ iso field trn field ref field val field box field tag field     iso origin iso tag tag val tag tag   trn origin iso trn box val box tag   ref origin iso trn ref val box tag   val origin val val val val val tag   box origin tag box box val box tag   tag origin n/a n/a n/a n/a n/a n/a     For example, if you have a trn origin and you read a ref field, you get a box result:\nclass Foo var x: String ref class Bar fun f() =\u003e var y: Foo trn = get_foo_trn() var z: String box = y.x Explaining why That table will seem totally natural to you, eventually. But probably not yet. To help it seem natural, let’s walk through each cell in the table and explain why it is the way it is.\nReading from an iso variable Anything read through an iso origin has to maintain the isolation guarantee that the origin has. The key thing to remember is that the iso can be sent to another actor and it can also become any other reference capability. So when we read a field, we need to get a result that won’t ever break the isolation guarantees that the origin makes, that is, read and write uniqueness.\nAn iso field makes the same guarantees as an iso origin, so that’s fine to read. A val field is globally immutable, which means it’s always ok to read it, no matter what the origin is (well, other than tag).\nEverything else, though, can break our isolation guarantees. That’s why other reference capabilities are seen as tag: it’s the only type that is neither readable nor writable.\nReading from a trn variable This is like iso, but with a weaker guarantee (write uniqueness as opposed to read and write uniqueness). That makes a big difference since now we can return something readable when we enforce our guarantees.\nAn iso field makes stronger guarantees than a trn origin, and a trn field makes the same guarantees, so they’re fine to read. A val field is globally immutable, so that’s fine too. A box field is readable, and we only guarantee write uniqueness, so that’s fine too.\nA ref field, though, would allow writing. So instead we return a box.\nReading from a ref variable A ref origin doesn’t modify its fields at all. This is because a ref origin doesn’t make any guarantees that are incompatible with its fields.\nReading from a val variable A val origin is deeply and globally immutable, so all of its fields are also val. The only exception is a tag field. Since we can’t read from it, we also can’t guarantee that nobody can write to it, so it stays tag.\nReading from a box variable A box variable is locally immutable. This means it’s possible that it may be mutated through some other variable (a trn or a ref), but it’s also possible that our box variable is an alias of some val variable.\nWhen we read a field, we need to return a reference capability that is compatible with the field but is also locally immutable.\nAn iso field is returned as a tag because no locally immutable reference capability can maintain its isolation guarantees. A val field is returned as a val because global immutability is a stronger guarantee than local immutability. A box field makes the same local immutability guarantee as its origin, so that’s also fine.\nFor trn and ref we need to return a locally immutable reference capability that doesn’t violate any guarantees the field makes. In both cases, we can return box.\nReading from a tag variable This one is easy: tag variables are opaque! They can’t be read from.\nWriting to the field of an object Like reading the field of an object, writing to a field depends on the reference capability of the object reference being stored and the reference capability of the origin object containing the field. The reference capability of the object being stored must not violate the guarantees made by the origin object’s reference capability. For example, a val object reference can be stored in an iso origin. This is because the val reference capability guarantees that no alias to that object exists which could violate the guarantees that the iso capability makes.\nHere’s a simplified version of the table above that shows which reference capabilities can be stored in the field of an origin object.\n    ◁ iso object trn object ref object val object box object tag object     iso origin ✔   ✔  ✔   trn origin ✔ ✔  ✔  ✔   ref origin ✔ ✔ ✔ ✔ ✔ ✔   val origin         box origin         tag origin           The bottom half of this chart is empty, since only origins with a mutable capability can have their fields modified.\n","summary":"When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.\nThis is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.\nViewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation.","title":"权能合并（Combining Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html"},{"content":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them. All Pony source files have an implicit use \"builtin\" command. This means all the types defined in the package builtin are automatically available in the type namespace of all Pony source files.\nDocumentation for the standard library is available online\n","summary":"The Pony standard library is a collection of packages that can each be used as needed to provide a variety of functionality. For example, the files package provides file access and the collections package provides generic lists, maps, sets and so on.\nThere is also a special package in the standard library called builtin. This contains various types that the compiler has to treat specially and are so common that all Pony code needs to know about them.","title":"标准库（Standard Library）","uri":"https://damon-kwok.github.io/pony-tutorial/packages/standard-library.html"},{"content":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, ! and much more.\n","summary":"Welcome to the appendix; the land of misshapen and forgotten documentation. Ok, not really forgotten just… ‘lesser’ sounds wrong. Some of this material could get some loving and be promoted to a full chapter, some are always going to be an appendix, some might be worthy of a short book unto itself. Right now though it lives here, have a look through. You’ll find a lexicon of standard Pony terminology, a symbol lookup cheat sheet that can help you locate documentation on all our funny symbols like ^, !","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/appendices.html"},{"content":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features. Calling well written, bug-free, C code will have no ill effects on your program. However, calling buggy or malicious C code or calling C incorrectly can cause your Pony program to go wrong, including corrupting data and crashing. Consequently, all of the Pony guarantees regarding not crashing, memory safety and concurrent correctness can be voided by calling FFI functions.\n","summary":"Pony supports integration with other native languages through the Foreign Function Interface (FFI). The FFI library provides a stable and portable API and high-level programming interface allowing Pony to integrate with native libraries easily.\nNote that calling C (or other low-level languages) is inherently dangerous. C code fundamentally has access to all memory in the process and can change any of it, either deliberately or due to bugs. This is one of the language’s most useful, but also most dangerous, features.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/c-ffi.html"},{"content":"This chapter covers the various expressions that make up Pony. From variables to control structures and more.\n","summary":"This chapter covers the various expressions that make up Pony. From variables to control structures and more.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions.html"},{"content":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters. The parameters for a generic class are types. Parameters are introduced to a class using square brackets.\nTake the following example of a non-generic class:\nclass Foo var _c: U32 new create(c: U32) =\u003e _c = c fun get(): U32 =\u003e _c fun ref set(c: U32) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) This class only works for the type U32, a 32 bit unsigned integer. We can make this work over other types by making the type a parameter to the class. For this example it looks like:\nclass Foo[A: Any val] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) let b = Foo[F32](1.5) env.out.print(b.get().string()) let c = Foo[String](\"Hello\") env.out.print(c.get().string()) The first thing to note here is that the Foo class now takes a type parameter in square brackets, [A: Any val]. That syntax for the type parameter is:\nName: Constraint ReferenceCapability  In this case, the name is A, the constraint is Any and the reference capability is val. Any is used to mean that the type can be any type - it is not constrained. The remainder of the class definition replaces U32 with the type name A.\nThe user of the class must provide a type when referencing the class name. This is done when creating it:\nlet a = Foo[U32](42) let b = Foo[F32](1.5) let c = Foo[String](\"Hello\") That tells the compiler what specific class to create, replacing A with the type provided. For example, a Foo[String] usage becomes equivalent to:\nclass FooString var _c: String val new create(c: String val) =\u003e _c = c fun get(): String val =\u003e _c fun ref set(c: String val) =\u003e _c = c Generic Methods Methods can be generic too. They are defined in the same way as normal methods but have type parameters inside square brackets after the method name:\nprimitive Foo fun bar[A: Stringable val](a: A): String =\u003e a.string() actor Main new create(env:Env) =\u003e let a = Foo.bar[U32](10) env.out.print(a.string()) let b = Foo.bar[String](\"Hello\") env.out.print(b.string()) This example shows a constraint other than Any. The Stringable type is any type with a string() method to convert to a String.\nThese examples show the basic idea behind generics and how to use them. Real world usage gets quite a bit more complex and the following sections will dive deeper into how to use them.\n","summary":"Often when writing code you want to create similar classes or functions that differ only in the type that they operate on. The classic example of this is collection classes. You want to be able to create an Array that can hold objects of a particular type without creating an IntArray, StringArray, etc. This is where generics step in.\nGeneric Classes A generic class is a class that can have parameters, much like a method has parameters.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/generics.html"},{"content":"本章将带您开始使用Pony，安装编译器运行第一个程序。\n在学习本教程的过程中，您可能会遇到许多您曾经使用过的编程语言所熟悉的概念。您可能会想跳过这些章节，这完全没问题。\n不过，如果您以前从未使用过Pony，您肯定会遇到一些陌生的概念，如果想学习和应用Pony，你需要特别！特别！！的注意：[引用权能](/reference- abilities.html)章节。引用权能 是Pony的核心，它让Pony独步天下。\n在本教程中，我们先从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其进行详细介绍。阅读过程中，强烈建议你将教程中的代码示例，在自己的文本编辑器中敲一遍。请注意，当您冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全教程，必须得先彻底理解这个基础概念。学习过程中配合编译器一起使用，可以帮助你验证教程中代码示例可用性。\n或许你正急着阅读后面的章节，还请花点时间读完入门章节。你需要了解下社区为你提供了帮助，帮你学习新概念时少走弯路，这将改变你对并发问题的看法。\n","summary":"本章将带您开始使用Pony，安装编译器运行第一个程序。\n在学习本教程的过程中，您可能会遇到许多您曾经使用过的编程语言所熟悉的概念。您可能会想跳过这些章节，这完全没问题。\n不过，如果您以前从未使用过Pony，您肯定会遇到一些陌生的概念，如果想学习和应用Pony，你需要特别！特别！！的注意：[引用权能](/reference- abilities.html)章节。引用权能 是Pony的核心，它让Pony独步天下。\n在本教程中，我们先从熟悉的基础知识入手，会尽力避免在代码示例中使用 引用权能 ，然后循序渐进的对其进行详细介绍。阅读过程中，强烈建议你将教程中的代码示例，在自己的文本编辑器中敲一遍。请注意，当您冒然跳跃式阅读本教程时，可能会遇到 引用权能 ，想要流畅的通读全教程，必须得先彻底理解这个基础概念。学习过程中配合编译器一起使用，可以帮助你验证教程中代码示例可用性。\n或许你正急着阅读后面的章节，还请花点时间读完入门章节。你需要了解下社区为你提供了帮助，帮你学习新概念时少走弯路，这将改变你对并发问题的看法。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/getting-started.html"},{"content":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results. Probably the best way to approach this chapter is to imagine each section has a giant flashing “DO NOT DO THIS” sign.\n","summary":"Every programming language has gotchas. Those “wat” moments that make us all laugh when someone does a presentation on them. They often shoot to the top of sites like Hacker News and Reddit. It’s all in good fun, except, it isn’t. Each of those gotchas and the laughs we get from them, hide someone’s pain. This chapter covers some common Pony gotchas that new Pony programmers often stumble across with painful results.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/gotchas.html"},{"content":"If you are reading this tutorial in order, you’ve just finished the reference capabilities chapter and your brain probably hurts. We’re sorry about that. Hopefully object capabilities, while a new concept, are less mind bending.\nWe touched on object capabilities previously in the tutorial, this chapter will dig in more. So, what is an object capability?\nA capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network. This is called an object capability. Object capabilities have appeared in a number of programming languages including E.\n","summary":"If you are reading this tutorial in order, you’ve just finished the reference capabilities chapter and your brain probably hurts. We’re sorry about that. Hopefully object capabilities, while a new concept, are less mind bending.\nWe touched on object capabilities previously in the tutorial, this chapter will dig in more. So, what is an object capability?\nA capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/object-capabilities.html"},{"content":"","summary":"","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/packages.html"},{"content":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.\n","summary":"In this chapter, you’ll learn how to Pony’s two types of matching work: The Match Expression and the As Operator.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/pattern-matching.html"},{"content":"We’ve covered the basics of Pony’s type system and then expressions, this chapter about reference capabilities will cover another feature of Pony’s type system. There aren’t currently any mainstream programming languages that feature reference capabilities. What is a reference capability?\nWell, a reference capability is built on the idea of “a capability”. A capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network. This usage of capability is called an object capability and is discussed in the next chapter.\nPony also features a different kind of capability, called a “reference capability”. Where object capabilities are about being granted the ability to do things with objects, reference capabilities are about denying you the ability to do things with memory references. For example, “you can have access to this memory BUT ONLY for reading it. You can not write to it”. That’s a reference capability and it’s denying you access to do things.\nReference capabilities are core to what makes Pony special. You might remember in the introduction to this tutorial what we said about Pony:\n It’s type safe. Really type safe. There’s a mathematical proof and everything. It’s memory safe. Ok, this comes with type safe, but it’s still interesting. There are no dangling pointers, no buffer overruns, heck, the language doesn’t even have the concept of null! It’s exception safe. There are no runtime exceptions. All exceptions have defined semantics, and they are always handled. It’s data-race-free. Pony doesn’t have locks or atomic operations or anything like that. Instead, the type system ensures at compile time that your concurrent program can never have data races. So you can write highly concurrent code and never get it wrong. It’s deadlock free. This one is easy because Pony has no locks at all! So they definitely don’t deadlock, because they don’t exist.  Reference capabilities are what make all that awesome possible.\nCode examples in this chapter might be kind of sparse, because we’re largely dealing with higher-level concepts. Try to read through the chapter at least once before starting to put the ideas into practice. By the time you finish this chapter, you should start to have a handle on what reference capabilities are and how you can use them. Don’t worry if you struggle with them at first. For most people, it’s a new way of thinking about your code and takes a while to grasp. If you get stuck trying to get your capabilities right, definitely reach out for help. Once you’ve used them for a couple weeks, problems with capabilities start to melt away, but before that can be a real struggle. Don’t worry, we all went through that struggle. In fact, there’s a section of the Pony website dedicated to resources that can help in learning reference capabilities. And by all means, reach out to the Pony community for help. We are here to help you get over the reference capabilities learning curve. It’s not easy. We know that. It’s a new way of thinking for folks, so do please reach out. We’re waiting to hear from you.\nScared? Don’t be. Ready? Good. Let’s get started.\n","summary":"We’ve covered the basics of Pony’s type system and then expressions, this chapter about reference capabilities will cover another feature of Pony’s type system. There aren’t currently any mainstream programming languages that feature reference capabilities. What is a reference capability?\nWell, a reference capability is built on the idea of “a capability”. A capability is the ability to do “something”. Usually that “something” involves an external resource that you might want access to; like the filesystem or the network.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities.html"},{"content":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.\n","summary":"Unto all code, good or bad, comes the needs to test it. Verification that our code does what we expect is very important. Over the last 20 years, there has been an explosion in different testing techniques and tools. This chapter will get you going with PonyTest, the current Pony testing tool.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/testing.html"},{"content":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。\n","summary":"Pony的类型系统非常与众不同。Pony有很多值得关注的特性，大多数特性都包含在类型系统之中。在本章中，我们将学习类型系统的基础知识。如果你以前使用过静态类型语言会很容易理解。在本章结束时，你就能掌握Pony的类型系统。","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/types.html"},{"content":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony. In particular, materials to help you grapple with reference capabilities.\n“Learn” on Ponylang.io\nPlanet Pony We don’t have an automatic blog aggregator but wish we did. In the meantime, we have a hand-curated list of videos, blog posts etc that would be of interest to members of the Pony community. Just beware when you are checking out older posts, it’s quite possible that their examples no longer compile as Pony development is currently moving very quickly.\nPlanet Pony\nPony Patterns Pony Patterns\n标准库文档 标准库文档\nPonylang Zulip Pony Zulip\nPony Virtual Users’ Group The Pony Virtual Users’ Group has occassional presentations that you can attend “in person” or catch later via the recorded video. Join our Zulip community to stay up to date on upcoming meetings. All the previous videos are available via Sean T Allen’s Vimeo account.\nA final word We’re immensely happy that you have taken the time to start learning Pony. It’s still a new and immature language with plenty of sharp pointy edges. You are going to get frustrated at times. Don’t worry, it has happened to all of us. Drop by one of our support channels and someone will try to lend a hand. We want you to succeed. The more people who succeed with Pony, the more the community grows and the better it is for all of us.\nWelcome to the community! Have fun!\n","summary":"Hey, congratulations! You’ve made it to the end of the Pony tutorial. So, what do you do next? Well, there’s actually a bit more here. Check out the appendices as they have some useful information that doesn’t fit else. After that, here are a few resources that you can look into.\n“Learn” section of Ponylang.io If you haven’t already visited it, the learn section of the Pony website has a lot of good content to help you get started with Pony.","title":"概述（Overview）","uri":"https://damon-kwok.github.io/pony-tutorial/where-next.html"},{"content":"Pony features two forms of equality: by structure and by identity.\nIdentity equality Identity equality checks in Pony are done via the is keyword. is verifies that the two items are the same.\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP! TRUE! end Structural equality Structural equality checking in Pony is done via the infix operator ==. It verifies that two items have the same value. If the identity of the items being compared is the same, then by definition they have the same value.\nYou can define how structural equality is checked on your object by implementing fun eq(that: box-\u003eFoo): Bool. Remember, since == is an infix operator, eq must be defined on the left operand, and the right operand must be of type Foo.\nclass Foo let _a: String new create(a: String) =\u003e _a = a fun eq(that: box-\u003eFoo): Bool =\u003e this._a == that._a actor Main new create(e: Env) =\u003e let a = Foo(\"hi\") let b = Foo(\"bye\") let c = Foo(\"hi\") if a == b then // won't print e.out.print(\"1\") end if a == c then // will print e.out.print(\"2\") end if a is c then // won't print e.out.print(\"3\") end If you don’t define your own eq, you will inherit the default implementation that defines equal by value as being the same as by identity.\ninterface Equatable[A: Equatable[A] #read] fun eq(that: box-\u003eA): Bool =\u003e this is that fun ne(that: box-\u003eA): Bool =\u003e not eq(that) Primitives and equality As you might remember from Chapter 2, primitives are the same as classes except for two important differences:\n A primitive has no fields. There is only one instance of a user-defined primitive.  This means, that every primitive of a given type, is always structurally equal and equal based on identity. So, for example, None is always None.\nif None is None then // this is always true end if None == None then // this is also always true end ","summary":"Pony features two forms of equality: by structure and by identity.\nIdentity equality Identity equality checks in Pony are done via the is keyword. is verifies that the two items are the same.\nif None is None then // TRUE! // There is only 1 None so the identity is the same end let a = Foo(\"hi\") let b = Foo(\"hi\") if a is b then // NOPE. THIS IS FALSE end let c = a if a is c then // YUP!","title":"比较运算（Equality in Pony）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/equality.html"},{"content":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:\n// Note - this won't compile class Foo[A] var _c: A new create(c: A) =\u003e _c = c fun get(): A =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[U32](42) env.out.print(a.get().string()) a.set(21) env.out.print(a.get().string()) Unfortunately, this doesn’t compile. For a generic class to compile it must be compilable for all possible types and reference capabilities that satisfy the constraints in the type parameter. In this case, that’s any type with any reference capability. The class works for the specific reference capability of val as we saw earlier, but how well does it work for ref? Let’s expand it and see:\n// Note - this also won't compile class Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): String ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) This does not compile. The compiler complains that get() doesn’t actually return a String ref, but this-\u003eString ref. We obviously need to simply change the type signature to fix this, but what is going on here? this-\u003eString ref is an arrow type. An arrow type with “this-\u003e” states to use the capability of the actual receiver (ref in our case), not the capability of the method (which defaults to box here). According to viewpoint adaption this will be ref-\u003eref which is ref. Without this arrow type we would only see the field _c as box because we are in a box method.\nSo let’s apply what we just learned:\nclass Foo var _c: String ref new create(c: String ref) =\u003e _c = c fun get(): this-\u003eString ref =\u003e _c fun ref set(c: String ref) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover ref String end) env.out.print(a.get().string()) a.set(recover ref String end) env.out.print(a.get().string()) That compiles and runs, so ref is valid now. The real test though is iso. Let’s convert the class to iso and walk through what is needed to get it to compile. We’ll then revisit our generic class to get it working:\nAn iso specific class // Note - this won't compile class Foo var _c: String iso new create(c: String iso) =\u003e _c = c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) This fails to compile. The first error is:\nmain.pony:5:8: right side must be a subtype of left side _c = c ^ Info: main.pony:4:17: String iso! is not a subtype of String iso: iso! is not a subtype of iso new create(c: String iso) =\u003e ^ The error is telling us that we are aliasing the String iso - The ! in iso! means it is an alias of an existing iso. Looking at the code shows the problem:\nnew create(c: String iso) =\u003e _c = c We have c as an iso and are trying to assign it to _c. This creates two aliases to the same object, something that iso does not allow. To fix it for the iso case we have to consume the parameter. The correct constructor should be:\nnew create(c: String iso) =\u003e _c = consume c A similar issue exists with the set method. Here we also need to consume the variable c that is passed in:\nfun set(c: String iso) =\u003e _c = consume c Now we have a version of Foo that is working correctly for iso. Note how applying the arrow type to the get method also works for iso. But here the result is a different one, by applying viewpoint adaptation we get from ref-\u003eiso (with ref being the capability of the receiver, the Foo object referenced by a) to iso. Through the magic of automatic receiver recovery we can call the string method on it:\nclass Foo var _c: String iso new create(c: String iso) =\u003e _c = consume c fun get(): this-\u003eString iso =\u003e _c fun ref set(c: String iso) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo(recover iso String end) env.out.print(a.get().string()) a.set(recover iso String end) env.out.print(a.get().string()) A capability generic class Now that we have iso working we know how to write a generic class that works for iso and it will work for other capabilities too:\nclass Foo[A] var _c: A new create(c: A) =\u003e _c = consume c fun get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = consume c actor Main new create(env:Env) =\u003e let a = Foo[String iso](\"Hello\".clone()) env.out.print(a.get().string()) let b = Foo[String ref](recover ref \"World\".clone() end) env.out.print(b.get().string()) let c = Foo[U8](42) env.out.print(c.get().string()) It’s quite a bit of work to get a generic class or method to work across all capability types, in particular for iso. There are ways of restricting the generic to subsets of capabilities and that’s the topic of the next section.\n","summary":"In the examples presented previously we’ve explicitly set the reference capability to val:\nclass Foo[A: Any val] If the capability is left out of the type parameter then the generic class or function can accept any reference capability. This would look like:\nclass Foo[A: Any] It can be made shorter because Any is the default constraint, leaving us with:\nclass Foo[A] This is what the example shown before looks like but with any reference capability accepted:","title":"泛型和引用权能（Generics and Reference Capabilities）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generics-and-reference-capabilities.html"},{"content":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic. The valid qualifiers are:\n   ▷ Capabilities allowed Description     #read ref, val, box Anything you can read from   #send iso, val, tag Anything you can send to an actor   #share val, tag Anything you can send to more than one actor   #any iso, trn, ref, val, box, tag Default of a constraint   #alias ref, val, box, tag Set of capabilities that alias as themselves (used by compiler)    In the previous section, we went through extra work to support iso. If there’s no requirement for iso support we can use #read and support ref, val, and box:\nclass Foo[A: Any #read] var _c: A new create(c: A) =\u003e _c = c fun ref get(): this-\u003eA =\u003e _c fun ref set(c: A) =\u003e _c = c actor Main new create(env:Env) =\u003e let a = Foo[String ref](recover ref \"hello\".clone() end) env.out.print(a.get().string()) let b = Foo[String val](\"World\") env.out.print(b.get().string()) ","summary":"Capability Constraints The type parameter constraint for a generic class or method can constrain to a particular capability as seen previously:\nclass Foo[A: Any val] Without the constraint, the generic must work for all possible capabilities. Sometimes you don’t want to be limited to a specific capability and you can’t support all capabilities. The solution for this is generic constraint qualifiers. These represent classes of capabilities that are accepted in the generic.","title":"泛型约束（Constraints）","uri":"https://damon-kwok.github.io/pony-tutorial/generics/generic-constraints.html"},{"content":"To do real work in a program you have to be able to make decisions, iterate through collections of items and perform actions repeatedly. For this, you need control structures. Pony has control structures that will be familiar to programmers who have used most languages, such as if, while and for, but in Pony, they work slightly differently.\nConditionals The simplest control structure is the good old if. It allows you to perform some action only when a condition is true. In Pony it looks like this:\nif a \u003e b then env.out.print(\"a is bigger\") end Can I use integers and pointers for the condition like I can in C? No. In Pony if conditions must have type Bool, i.e. they are always true or false. If you want to test whether a number a is not 0, then you need to explicitly say a != 0. This restriction removes a whole category of potential bugs from Pony programs.\nIf you want some alternative code for when the condition fails just add an else:\nif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"a is not bigger\") end Often you want to test more than one condition in one go, giving you more than two possible outcomes. You can nest if statements, but this quickly gets ugly:\nif a == b then env.out.print(\"they are the same\") else if a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end end As an alternative Pony provides the elseif keyword that combines an else and an if. This works the same as saying else if in other languages and you can have as many elseifs as you like for each if.\nif a == b then env.out.print(\"they are the same\") elseif a \u003e b then env.out.print(\"a is bigger\") else env.out.print(\"b bigger\") end Why can’t I just say “else if” like I do in C? Why the extra keyword? The relationship between if and else in C, and other similar languages, is ambiguous. For example:\n// C code if(a) if(b) printf(\"a and b\\n\"); else printf(\"not a\\n\"); Here it is not obvious whether the else is an alternative to the first or the second if. In fact here the else relates to the if(b) so our example contains a bug. Pony avoids this type of bug by handling if and else differently and the need for elseif comes out of that.\nEverything is an expression The big difference for control structures between Pony and other languages is that in Pony everything is an expression. In languages like C++ and Java if is a statement, not an expression. This means that you can’t have an if inside an expression, there has to be a separate conditional operator ‘?'.\nIn Pony there are no statements there are only expressions, everything hands back a value. Your if statement hands you back a value. Your for loop (which we’ll get to a bit later) hands you back a value.\nThis means you can use if directly in a calculation:\nx = 1 + if lots then 100 else 2 end This will give x a value of either 3 or 101, depending on the variable lots.\nIf the then and else branches of an if produce different types then the if produces a union of the two.\nvar x: (String | Bool) = if friendly then \"Hello\" else false end But what if my if doesn’t have an else? Any else branch that doesn’t exist gives an implicit None.\nvar x: (String | None) = if friendly then \"Hello\" end The same rules that apply to the value of an if expression applies to loops as well. Let’s take a look at what a loop value would look like:\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end This will give x the value “Sarah” as it is the last name in our list. If our loop has 0 iterations, then the value of it’s else block will be the value of x. Or if there is no else block, the value will be None.\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name else \"no names!\" end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end Here the value of x is “no names!”\nactor Main new create(env: Env) =\u003e var x: (String | None) = for name in Array[String].values() do name end match x | let s: String =\u003e env.out.print(\"x is \" + s) | None =\u003e env.out.print(\"x is None\") end And lastly, here x would be None.\nLoops if allows you to choose what to do, but to do something more than once you want a loop.\nWhile Pony while loops are very similar to those in other languages. A condition expression is evaluated and if it’s true we execute the code inside the loop. When we’re done we evaluate the condition again and keep going until it’s false.\nHere’s an example that prints out the numbers 1 to 10:\nvar count: U32 = 1 while count \u003c= 10 do env.out.print(count.string()) count = count + 1 end Just like if expressions while is also an expression. The value returned is just the value of the expression inside the loop the last time we go round it. For this example that will be the value given by count = count + 1 when count is incremented to 11. Since Pony assignments hand back the old value our while loop will return 10.\nBut what if the condition evaluates to false the first time we try, then we don’t go round the loop at all? In Pony while expressions can also have an else block. In general, Pony else blocks provide a value when the expression they are attached to doesn’t. A while doesn’t have a value to give if the condition evaluates to false the first time, so the else provides it instead.\nSo is this like an else block on a while loop in Python? No, this is very different. In Python, the else is run when the while completes. In Pony the else is only run when the expression in the while isn’t.\nBreak Sometimes you want to stop part-way through a loop and give up altogether. Pony has the break keyword for this and it is very similar to its counterpart in languages like C++, C#, and Python.\nbreak immediately exits from the innermost loop it’s in. Since the loop has to return a value break can take an expression. This is optional and if it’s missed out the value from the else block is returned.\nLet’s have an example. Suppose you want to go through a list of names you’re getting from somewhere, looking for either “Jack” or “Jill”. If neither of those appear you’ll just take the last name you’re given and if you’re not given any names at all you’ll use “Herbert”.\nvar name = while moreNames() do var name' = getName() if name' == \"Jack\" or name' == \"Jill\" then break name' end name' else \"Herbert\" end So first we ask if there are any more names to get. If there are then we get a name and see if it’s “Jack” or “Jill”. If it is we’re done and we break out of the loop, handing back the name we’ve found. If not we try again.\nThe line name' appears at the end of the loop so that will be our value returned from the last iteration if neither “Jack” nor “Jill” is found.\nThe else block provides our value of “Herbert” if there are no names available at all.\nCan I break out of multiple, nested loops like the Java labeled break? No, Pony does not support that. If you need to break out of multiple loops you should probably refactor your code or use a worker function.\nContinue Sometimes you want to stop part-way through one loop iteration and move onto the next. Like other languages, Pony uses the continue keyword for this.\ncontinue stops executing the current iteration of the innermost loop it’s in and evaluates the condition ready for the next iteration.\nIf continue is executed during the last iteration of the loop then we have no value to return from the loop. In this case, we use the loop’s else expression to get a value. As with the if expression if no else expression is provided None is returned.\nCan I continue an outer, nested loop like the Java labeled continue? No, Pony does not support that. If you need to continue an outer loop you should probably refactor your code.\nFor For iterating over a collection of items Pony uses the for keyword. This is very similar to foreach in C#, for..in in Python and for in Java when used with a collection. It is very different to for in C and C++.\nThe Pony for loop iterates over a collection of items using an iterator. On each iteration, round the loop, we ask the iterator if there are any more elements to process and if there are we ask it for the next one.\nFor example to print out all the strings in an array:\nfor name in [\"Bob\"; \"Fred\"; \"Sarah\"].values() do env.out.print(name) end Note the call to values() on the array, this is because the loop needs an iterator, not an array.\nThe iterator does not have to be of any particular type, but needs to provide the following methods:\nfun has_next(): Bool fun next(): T? where T is the type of the objects in the collection. You don’t need to worry about this unless you’re writing your own iterators. To use existing collections, such as those provided in the standard library, you can just use for and it will all work. If you do write your own iterators note that we use structural typing, so your iterator doesn’t need to declare that it provides any particular type.\nYou can think of the above example as being equivalent to:\nlet iterator = [\"Bob\"; \"Fred\"; \"Sarah\"].values() while iterator.has_next() do let name = iterator.next()? env.out.print(name) end Note that the variable name is declared let, you cannot assign to the control variable within the loop.\nCan I use break and continue with for loops? Yes, for loops can have else expressions attached and can use break and continue just as for while.\nRepeat The final loop construct that Pony provides is repeat until. Here we evaluate the expression in the loop and then evaluate a condition expression to see if we’re done or we should go round again.\nThis is similar to do while in C++, C# and Java except that the termination condition is reversed, i.e. those languages terminate the loop when the condition expression is false, Pony terminates the loop when the condition expression is true.\nThe differences between while and repeat in Pony are:\n We always go around the loop at least once with repeat, whereas with while we may not go round at all. The termination condition is reversed.  Suppose we’re trying to create something and we want to keep trying until it’s good enough:\nactor Main new create(env: Env) =\u003e var counter = U64(1) repeat env.out.print(\"hello!\") counter = counter + 1 until counter \u003e 7 end Just like while loops the value given by a repeat loop is the value of the expression within the loop on the last iteration and break and continue can be used.\nSince you always go round a repeat loop at least once do you ever need to give it an else expression? Yes, you may need to. A continue in the last iteration of a repeat loop needs to get a value from somewhere and an else expression is used for that.\n","summary":"To do real work in a program you have to be able to make decisions, iterate through collections of items and perform actions repeatedly. For this, you need control structures. Pony has control structures that will be familiar to programmers who have used most languages, such as if, while and for, but in Pony, they work slightly differently.\nConditionals The simplest control structure is the good old if. It allows you to perform some action only when a condition is true.","title":"流程控制（Control Structures）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/control-structures.html"},{"content":"Like other object-oriented languages, Pony has subtyping. That is, some types serve as categories that other types can be members of.\nThere are two kinds of subtyping in programming languages: nominal and structural. They’re subtly different, and most programming languages only have one or the other. Pony has both!\nNominal subtyping This kind of subtyping is called nominal because it is all about names.\nIf you’ve done object-oriented programming before, you may have seen a lot of discussion about single inheritance, multiple inheritance, mixins, traits, and similar concepts. These are all examples of nominal subtyping.\nThe core idea is that you have a type that declares it has a relationship to some category type. In Java, for example, a class (a concrete type) can implement an interface (a category type). In Java, this means the class is now in the category that the interface represents. The compiler will check that the class actually provides everything it needs to.\nTraits: nominal subtyping Pony has nominal subtyping, using traits. A trait looks a bit like a class, but it uses the keyword trait and it can’t have any fields.\ntrait Named fun name(): String =\u003e \"Bob\" class Bob is Named Here, we have a trait Named that has a single function name that returns a String. It also provides a default implementation of name that returns the string literal “Bob”.\nWe also have a class Bob that says it is Named. This means Bob is in the Named category. In Pony, we say Bob provides Named, or sometimes simply Bob is Named.\nSince Bob doesn’t have its own name function, it uses the one from the trait. If the trait’s function didn’t have a default implementation, the compiler would complain that Bob had no implementation of name.\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald fun hair(): Bool =\u003e false class Bob is (Named \u0026 Bald) It is possible for a class to have relationships with multiple categories. In the above example, the class Bob provides both Named and Bald.\ntrait Named fun name(): String =\u003e \"Bob\" trait Bald is Named fun hair(): Bool =\u003e false class Bob is Bald It is also possible to combine categories together. In the example above, all Bald classes are automatically Named. Consequently, the Bob class has access to both hair() and name() default implementation of their respective trait. One can think of the Bald category to be more specific than the Named one.\nclass Larry fun name(): String =\u003e \"Larry\" Here, we have a class Larry that has a name function with the same signature. But Larry does not provide Named!\nWait, why not? Because Larry doesn’t say it is Named. Remember, traits are nominal: a type that wants to provide a trait has to explicitly declare that it does. And Larry doesn’t.\nStructural subtyping There’s another kind of subtyping, where the name doesn’t matter. It’s called structural subtyping, which means that it’s all about how a type is built, and nothing to do with names.\nA concrete type is a member of a structural category if it happens to have all the needed elements, no matter what it happens to be called.\nIf you’ve used Go, you’ll recognise that Go interfaces are structural types.\nInterfaces: structural subtyping Pony has structural subtyping too, using interfaces. Interfaces look like traits, but they use the keyword interface.\ninterface HasName fun name(): String Here, HasName looks a lot like Named, except it’s an interface instead of a trait. This means both Bob and Larry provide HasName! The programmers that wrote Bob and Larry don’t even have to be aware that HasName exists.\nPony interfaces can have functions with default implementations as well. A type will only pick those up if it explicitly declares that it is that interface.\nShould I use traits or interfaces in my own code? Both! Interfaces are more flexible, so if you’re not sure what you want, use an interface. But traits are a powerful tool as well: they stop accidental subtyping.\n","summary":"Like other object-oriented languages, Pony has subtyping. That is, some types serve as categories that other types can be members of.\nThere are two kinds of subtyping in programming languages: nominal and structural. They’re subtly different, and most programming languages only have one or the other. Pony has both!\nNominal subtyping This kind of subtyping is called nominal because it is all about names.\nIf you’ve done object-oriented programming before, you may have seen a lot of discussion about single inheritance, multiple inheritance, mixins, traits, and similar concepts.","title":"特征和接口（Traits and Interfaces）","uri":"https://damon-kwok.github.io/pony-tutorial/types/traits-and-interfaces.html"},{"content":"Arithmetic is about the stuff you learn to do with numbers in primary school: Addition, Subtraction, Multiplication, Division and so on. Piece of cake. We all know that stuff. We nonetheless want to spend a whole section on this topic, because when it comes to computers the devil is in the details.\nAs introduced in Primitives numeric types in Pony are represented as a special kind of primitive that maps to machine words. Both integer types and floating point types support a rich set of arithmetic and bit-level operations. These are expressed as Infix Operators that are implemented as plain functions on the numeric primitive types.\nPony focuses on two goals, performance and safety. From time to time, these two goals collide. This is true especially for arithmetic on integers and floating point numbers. Safe code should check for overflow, division by zero and other error conditions on each operation where it can happen. Pony tries to enforce as many safety invariants at compile time as it possibly can, but checks on arithmetic operations can only happen at runtime. Performant code should execute integer arithmetic as fast and with as few CPU cycles as possible. Checking for overflow is expensive, doing plain dangerous arithmetic that is possibly subject to overflow is cheap.\nPony provides different ways of doing arithmetic to give programmers the freedom to chose which operation suits best for them, the safe but slower operation or the fast one, because performance is crucial for the use case.\nIntegers Ponys default Arithmetic Doing arithmetic on integer types in Pony with the well known operators like +, -, *, / etc. tries to balance the needs for performance and correctness. All default arithmetic operations do not expose any undefined behaviour or error conditions. That means it handles both the cases for overflow/underflow and division by zero. Overflow/Underflow are handled with proper wrap around semantics, using one’s completement on signed integers. In that respect we get behaviour like:\n// unsigned wrap-around on overflow U32.max_value() + 1 == 0 // signed wrap-around on overflow/underflow I32.min_value() - 1 == I32.max_value() Division by zero is a special case, which affects the division / and remainder % operators. In Mathematics, division by zero is undefined. In order to avoid either defining division as partial, throwing an error on division by zero or introducing undefined behaviour for that case, the normal division is defined to be 0 when the divisor is 0. This might lead to silent errors, when used without care. Choose Partial and checked Arithmetic to detect division by zero.\nIn contrast to Unsafe Arithmetic default arithmetic comes with a small runtime overhead because unlike the unsafe variants, it does detect and handle overflow and division by zero.\n    Operator Method Description     + add() wrap around on over-/underflow   - sub() wrap around on over-/underflow   * mul() wrap around on over-/underflow   / div() x / 0 = 0   % rem() x % 0 = 0   %% mod() x %% 0 = 0   - neg() wrap around on over-/underflow   \u003e\u003e shr() filled with zeros, so x \u003e\u003e 1 == x/2 is true   \u003c\u003c shl() filled with zeros, so x \u003c\u003c 1 == x*2 is true     Unsafe Arithmetic Unsafe integer arithmetic comes close to what you can expect from integer arithmetic in C. No checks, raw speed, possibilities of overflow, underflow or division by zero. Like in C, overflow, underflow and division by zero scenarios are undefined. Don’t rely on the results in these cases. It could be anything and is highly platform specific. Division by zero might even crash your program with a SIGFPE. Our suggestion is to use these operators only if you can make sure you can exclude these cases.\nHere is a list with all unsafe operations defined on Integers:\n    Operator Method Undefined in case of     +~ add_unsafe() Overflow E.g. I32.max_value() +~ I32(1)   -~ sub_unsafe() Overflow   *~ mul_unsafe() Overflow.   /~ div_unsafe() Division by zero and overflow. E.g. I32.min_value() / I32(-1)   %~ rem_unsafe() Division by zero and overflow.   %%~ mod_unsafe() Division by zero and overflow.   -~ neg_unsafe() Overflow. E.g. -~I32.max_value()   \u003e\u003e~ shr_unsafe() If non-zero bits are shifted out. E.g. I32(1) \u003e\u003e~ U32(2)   \u003c\u003c~ shl_unsafe() If bits differing from the final sign bit are shifted out.     Unsafe Conversion Converting between integer types in Pony needs to happen explicitly. Each numeric type can be converted explicitly into every other type.\n// converting an I32 to a 32 bit floating point I32(12).f32() For each conversion operation there exists an unsafe counterpart, that is much faster when converting from and to floating point numbers. All these unsafe conversion between numeric types are undefined if the target type is smaller than the source type, e.g. if we convert from I64 to F32.\n// converting an I32 to a 32 bit floating point, the unsafe way I32(12).f32_unsafe() // an example for an undefined unsafe conversion I64.max_value().f32_unsafe() // an example for an undefined unsafe conversion, that is actually safe I64(1).u8_unsafe() Here is a full list of all available conversions for numeric types:\n    Safe conversion Unsafe conversion     u8() u8_unsafe()   u16() u16_unsafe()   u32() u32_unsafe()   u64() u64_unsafe()   u128() u128_unsafe()   ulong() ulong_unsafe()   usize() usize_unsafe()   i8() i8_unsafe()   i16() i16_unsafe()   i32() i32_unsafe()   i64() i64_unsafe()   i128() i128_unsafe()   ilong() ilong_unsafe()   isize() isize_unsafe()   f32() f32_unsafe()   f64() f64_unsafe()     Partial and Checked Arithmetic If overflow or division by zero are cases that need to be avoided and performance is no critical priority, partial or checked arithmetic offer great safety during runtime. Partial arithmetic operators error on overflow/underflow and division by zero. Checked arithmetic methods return a tuple of the result of the operation and a Boolean indicating overflow or other exceptional behaviour.\n// partial arithmetic let result = try USize.max_value() +? env.args.size() else env.out.print(\"overflow detected\") end // checked arithmetic let result = match USize.max_value().addc(env.args.size()) | (let result: USize, false) =\u003e // use result ... | (_, true) =\u003e env.out.print(\"overflow detected\") end Partial as well as checked arithmetic comes with the burden of handling exceptions on every case and incurs some performance overhead, be warned.\n   Partial Operator Method Description     +? add_partial() errors on overflow/underflow   -? sub_partial() errors on overflow/underflow   *? mul_partial() errors on overflow/underflow   /? div_partial() errors on overflow/underflow and division by zero   %? rem_partial() errors on overflow/underflow and division by zero   %%? mod_partial() errors on overflow/underflow and division by zero     Checked arithmetic functions all return the result of the operation and a Boolean flag indicating overflow/underflow or division by zero in a tuple.\n   Checked Method Description     addc() Checked addition, second tuple element is true on overflow/underflow.   subc() Checked subtraction, second tuple element is true on overflow/underflow.   mulc() Checked multiplication, second tuple element is true on overflow.   divc() Checked division, second tuple element is true on overflow or division by zero.   remc() Checked remainder, second tuple element is true on overflow or division by zero.   modc() Checked modulo, second tuple element is true on overflow or division by zero.   fldc() Checked floored division, second typle element is true on overflow or division by zero.     Floating Point Pony default arithmetic on floating point numbers (F32, F64) behave as defined in the floating point standard IEEE 754.\nThat means e.g. that division by +0 returns Inf and by -0 returns -Inf.\nUnsafe Arithmetic Unsafe Floating Point operations do not necessarily comply with IEEE 754 for every input or every result. If any argument to an unsafe operation or its result are +/-Inf or NaN, the result is actually undefined.\nThis allows more aggressive optimizations and for faster execution, but only yields valid results for values different that the exceptional values +/-Inf and NaN. We suggest to only use unsafe arithmetic on floats if you can exclude those cases.\n    Operator Method     +~ add_unsafe()   -~ sub_unsafe()   *~ mul_unsafe()   /~ div_unsafe()   %~ rem_unsafe()   %%~ mod_unsafe()   -~ neg_unsafe()   \u003c~ lt_unsafe()   \u003e~ gt_unsafe()   \u003c=~ le_unsafe()   \u003e=~ ge_unsafe()   =~ eq_unsafe()   !=~ ne_unsafe()     Additionally sqrt_unsafe() is undefined for negative values.\n","summary":"Arithmetic is about the stuff you learn to do with numbers in primary school: Addition, Subtraction, Multiplication, Division and so on. Piece of cake. We all know that stuff. We nonetheless want to spend a whole section on this topic, because when it comes to computers the devil is in the details.\nAs introduced in Primitives numeric types in Pony are represented as a special kind of primitive that maps to machine words.","title":"算术运算符（Arithmetic）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/arithmetic.html"},{"content":"A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.\nWe’ll give a couple examples of using type aliases, just to get the feel of them.\nEnumerations One way to use type aliases is to express an enumeration. For example, imagine we want to say something must either be Red, Blue or Green. We could write something like this:\nprimitive Red primitive Blue primitive Green type Colour is (Red | Blue | Green) There are two new concepts in there. The first is the type alias, introduced with the keyword type. It just means that the name that comes after type will be translated by the compiler to the type that comes after is.\nThe second new concept is the type that comes after is. It’s not a single type! Instead, it’s a union type. You can read the | symbol as or in this context, so the type is “Red or Blue or Green”.\nA union type is a form of closed world type. That is, it says every type that can possibly be a member of it. In contrast, object-oriented subtyping is usually open world, e.g. in Java, an interface can be implemented by any number of classes.\nYou can also declare constants like in C or Go like this,\nprimitive Red fun apply(): U32 =\u003e 0xFF0000FF primitive Green fun apply(): U32 =\u003e 0x00FF00FF primitive Blue fun apply(): U32 =\u003e 0x0000FFFF type Colour is (Red | Blue | Green) or namespace them like this\nprimitive Colours fun red(): U32 =\u003e 0xFF0000FF fun green(): U32 =\u003e 0x00FF00FF You might also want to iterate over the enum like this to print its name for debugging purposes\nprimitive ColourList fun apply(): Array[Colour] =\u003e [Red; Green; Blue] for colour in ColourList().values() do end Complex types If a type is complicated, it can be nice to give it a mnemonic name. For example, if we want to say that a type must implement more than one interface, we could say:\ninterface HasName fun name(): String interface HasAge fun age(): U32 interface HasAddress fun address(): String type Person is (HasName \u0026 HasAge \u0026 HasAddress) This use of complex types applies to traits, not just interfaces:\ntrait HasName fun name(): String =\u003e \"Bob\" trait HasAge fun age(): U32 =\u003e 42 trait HasAddress fun address(): String =\u003e \"3 Abbey Road\" type Person is (HasName \u0026 HasAge \u0026 HasAddress) There’s another new concept here: the type has a \u0026 in it. This is similar to the | of a union type: it means this is an intersection type. That is, it’s something that must be all of HasName, HasAge and HasAddress.\nBut the use of type here is exactly the same as the enumeration example above, it’s just providing a name for a type that is otherwise a bit tedious to type out over and over.\nAnother example, this time from the standard library, is SetIs. Here’s the actual definition:\ntype SetIs[A] is HashSet[A, HashIs[A!]] Again there’s something new here. After the name SetIs comes the name A in square brackets. That’s because SetIs is a generic type. That is, you can give a SetIs another type as a parameter, to make specific kinds of set. If you’ve used Java or C#, this will be pretty familiar. If you’ve used C++, the equivalent concept is templates, but they work quite differently.\nAnd again the use of type just provides a more convenient way to refer to the type we’re aliasing:\nHashSet[A, HashIs[A!]] That’s another generic type. It means a SetIs is really a kind of HashSet. Another concept has snuck in, which is ! types. This is a type that is the alias of another type. That’s tricky stuff that you only need when writing complex generic types, so we’ll leave it for later.\nOne more example, again from the standard library, is the Map type that gets used a lot. It’s actually a type alias. Here’s the real definition of Map:\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] Unlike our previous example, the first type parameter, K, has a type associated with it. This is a constraint, which means when you parameterise a Map, the type you pass for K must be a subtype of the constraint.\nAlso, notice that box appears in the type. This is a reference capability. It means there is a certain class of operations we need to be able to do with a K. We’ll cover this in more detail later.\nJust like our other examples, all this really means is that Map is really a kind of HashMap.\nOther stuff Type aliases get used for a lot of things, but this gives you the general idea. Just remember that a type alias is always a convenience: you could replace every use of the type alias with the full type after the is.\nIn fact, that’s exactly what the compiler does.\n","summary":"A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.\nWe’ll give a couple examples of using type aliases, just to get the feel of them.\nEnumerations One way to use type aliases is to express an enumeration.","title":"类型别名（Type Aliases）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-aliases.html"},{"content":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 所有消息传递为 causal （不可以！）  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。\n","summary":"Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。\n静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？\n在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。\n动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。\n当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。\n类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。\n类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。\n动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。\nPony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。\n 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 所有消息传递为 causal （不可以！）  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。\n用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。","title":"类型系统概览","uri":"https://damon-kwok.github.io/pony-tutorial/types/at-a-glance.html"},{"content":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。\n类型集合的特性可以让我们很容易的将特征和接口组合在一起。例如，标准库中的Map的定义方式：\ntype Map[K: (Hashable box \u0026 Comparable[K] box), V] is HashMap[K, V, HashEq[K]] 这是一个相当复杂的类型别名。让我们看一下K的定义：(Hashable box \u0026 Comparable[K] box)，这表示K是一个Hashable 同时 它也具有Comparable[K]的特征。\n类型表达式组合（Combining type expressions） 类型表达式可以组合出更复杂的类型。这是标准库中的另一个示例：\nvar _array: Array[((K, V) | _MapEmpty | _MapDeleted)] 在这里，我们定义了一个数组类型的变量，数组的元素可以是(K, V)类型的元组，也可以是_MapEmpty 或 _MapDeleted。\n每个类型表达式都有括号，所以了解了这一点，实际上还是很容易阅读的。如果遇到需要高频率使用复杂的类型表达式，最好为它提供一个类型别名。\ntype Number is (Signed | Unsigned | Float) type Signed is (I8 | I16 | I32 | I64 | I128) type Unsigned is (U8 | U16 | U32 | U64 | U128) type Float is (F32 | F64) 上面的类型别名定义都来自于标准库。\nNumber是一个类型别名，它定义中中还可以包含其他类型别名？ 没错，这是个非常有趣和方便的特性。\n","summary":"到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。\n有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。\n元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：\nvar x: (String, U64) x = (\"hi\", 3) x = (\"bye\", 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：\n(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：\nvar y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：\nx = (\"wombat\", x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。\nUnions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。\n在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。\nvar x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。\nIntersections（类型集合） 类型集合 使用\u0026作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。","title":"类型表达式（Type Expressions）","uri":"https://damon-kwok.github.io/pony-tutorial/types/type-expressions.html"},{"content":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\nWhat goes in a class? 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.就可以选择构造函数：\nlet defaultWombat = Wombat(\"Fantastibat\") // 使用默认构造函数 let hungryWombat = Wombat.hungry(\"Nomsbat\", 12) // 使用`hunger`构造函数 构造函数中name'参数的单引号时啥意思？ 你可以在 参数 和 内部变量 命名中使用单引号，用来区分时 外部传入 和 内部定义 的字段（就像Python的self.name=name Java的this.nama=name C++的：this-\u003ename=name)。\n每一个构造函数都要为所有字段做出初始化，否则编译器会给你一个error。Pony中是不存在null的，我们不能像Java，C#等语言中一样将字段赋值为null，也没有数字不初始化默认为0的规则。Pony不希望在你运行时因为字段undefined导致崩溃（不像C和C++）。\n有时我们希望可以为所有构造函数快速的设置字段初始值：\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面的例子中，通过为字段赋初值，默认将口渴等级字段设置为1，需要不同的值，可以在构造函数中做修改。\n无参数的构造函数\nclass Hawk var _hunger_level: U64 = 0 class Owl var _hunger_level: U64 new create() =\u003e _hunger_level = 42 上面例子中我们定义了两个类，Hawk类没有构造函数，编译器会生成一个默认的create构造函数。Owl定义了一个构造函数设置_hunger_level字段。\n创建实例时如果类拥有一个无参数构造函数，直接省略掉括号：\nclass Forest let _owl: Owl = Owl let _hawk: Hawk = Hawk 稍后我们会在语法糖章节中做出详细解释。\n成员函数 Pony中的成员函数类似于Java，C#，C++，Ruby，Python等面向对象语言中的方法（类成员函数）。和构造函数一样它们也可以有参数和返回值类型（注意是_可以有_，不是必须。如果没有明确给出返回值类型，默认为None，表示没有返回值）。\nclass Wombat let name: String var _hunger_level: U64 var _thirst_level: U64 = 1 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' fun hunger(): U64 =\u003e _hunger_level fun ref set_hunger(to: U64 = 0): U64 =\u003e _hunger_level = to 我们从hunger函数说起：它有一个U64返回类型，返回树袋熊当前的口渴等级。这里我们没有使用return关键字，因为我们要返回的_hunger_level是函数的最后一个表达式。\nPony中有return关键字吗？ 当然有，当你需要在函数中\"提前\"返回时，也就是说你不希望函数运行到最后一个表达式的时候，就需要用到return关键字。\n再来看第二个函数set_hunger，这里出现了 一堆 新概念，让我们来逐步了解一下这些概念。\n fun后面的ref关键字  这是一个 引用权能 。在这里，因为我们需要修改_hunger_level字段。\nhunger方法的接收者参考能力是什么？ 如果未指定，默认的接收者引用权能是box，这意味着“我只需要能读取，不需要修改”。\n如果我们将set_hunger方法中的ref关键字保留下来会怎样？ 编译器会给您一个错误。它会显示您正在尝试修改字段并抱怨它。\n 参数to后面的= 0  这是一个 默认参数 。当你调用这个函数时没有传入参数，就会默认为这个值，在这里它的默认值被设置为0。\n 函数实际返回了什么？  它返回修改前的 旧值 。\n等等，开什么玩笑？旧值？ 没错，在Pony中赋值操作是一个表达式，这意味着它有一个返回值，在很多数语言里赋值语句会返回_新值_，换句话说a=b在大多数语言里都会返回b，但是在Pony中返回a。\n…为什么？ 这被称为\"破坏性读取”，它使您可以使用功能安全类型系统来完成出色的工作，我们稍后再讨论。现在，我们只只需要知道可以使用它来实现_swap_操作。在其他语言里要交换a和b的值你通常需要这么做：\nvar temp = a a = b b = temp 用Pony这样就可以了：\na = b = a 销毁函数 销毁函数是一个特殊函数，函数名为_final，box。函数必须被定义为fun _final()。\n在GC收集对象之前，将调用对象的销毁函数。对象在销毁后成员函数依然可以被调用，但只能从另一个销毁函数内调用。另外需要注意一点：无法从销毁函数中发送消息。\n销毁函数通常用于清理以C代码分配的资源，例如文件句柄，网络套接字等。\n关于继承？ 在很多面向对象的语言中，一种类型可以继承另一种类型，例如在Java中某种东西可以“扩展”其他某种东西。Pony不这样做。相反，Pony的做法是 组合 而不是 继承 。换句话说，在Pony中你的逻辑需要去表达 has ，而不是 is 。\n另一方面，Pony具有强大的 trait（特征） 系统（类似于具有默认实现的Java 8 接口）和强大的 interface（接口） 系统（类似于Go语言的接口，也就是结构化类型）。\n稍后我们将详细讨论这些内容。\n命名规则 Pony中的所有命名，包括类型名，方法名和变量名等，都只能包含 ASCII字符。\n实际上，Pony代码的所有的元素都必须为ASCII，字符串文内容除外，字符串可以愉快地直接从源文件中接受任何类型的字节（无论是UTF-8编码还是ISO-8859-2并以其编码形式表示）。\nPony的类型，无论是class，actor，trait，interface，primitive还是类型别名，都必须以大写字母开头。在私有或特殊 methods （行为，构造函数和普通函数）的下划线之后，任何方法或变量（包括参数和字段）都必须以小写字母开头。在所有情况下，都不允许在一行中或名称末尾加下划线，但否则，字母和数字的任何组合都是合法的。\n实际上，数字也可以使用单个下划线作为分隔符！但是，只有有效的变量名才能以质数结尾。\n","summary":"和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：\nclass Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。\nWhat goes in a class? 一个类的组成：\n 字段  构造函数  成员函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。\nclass Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。\n下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 成员函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。\n构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。\n声明一个构造函数需要用 new 关键字。\nclass Wombat let name: String var _hunger_level: U64 new create(name': String) =\u003e name = name' _hunger_level = 0 new hungry(name': String, hunger': U64) =\u003e name = name' _hunger_level = hunger' 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.","title":"类（Classes）","uri":"https://damon-kwok.github.io/pony-tutorial/types/classes.html"},{"content":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface. Most functions on a Pointer[A] are private to maintain memory safety. \"\"\" new create() =\u003e \"\"\" A null pointer. \"\"\" compile_intrinsic new _alloc(len: USize) =\u003e \"\"\" Space for len instances of A. \"\"\" compile_intrinsic 这里有两个构造函数。第一个创建一个新的空Pointer，第二个创建分配了内存空间的Pointer。\n成员函数 和类一样，结构体也可以有函数。对Pony类成员函数的所有内容也适用于结构。\nWe’ll see structs again 在Pony与C代码的交互中，结构体扮演着重要的角色。我们将在教程的C-FFI部分中详细讲解结构体。现在，我们不需要过多关注结构体。\n","summary":"结构体和类有几个非常重要的区别。平时的Pony程序开发中一般都使用类，很少会使用结构。我们将在本教程的C-FFI章中更深入地讨论结构。这里只做简短介绍。\n结构体是用来做外部交互的 struct和类的机制一样，但是它可以通过Pony的FFI接口与C代码交互来传递数据。\nPony结构体和类一样也可以包含字段和方法。与类不同的是：Pony的结构体与C结构体具有相同的内存布局，并且可以在C函数互相调用。结构体没有类型描述符，所以它们不能被用于算数类型，也不能用来实现特征和接口。\nWhat goes in a struct? 结构的构成和类一样：\n1.字段 2.构造函数 3.函数\n字段 Pony struct字段的定义方式与Pony类的定义方式相同，可以使用embed，let和 var。embed字段嵌入在其父对象中，就像C结构内部的C结构一样。 var和let字段是指向单独分配的对象的指针。\n例如：\nstruct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。之前讲过的有关Pony类构造函数的所有知识都适用于结构构造函数。\nstruct Pointer[A] \"\"\" A Pointer[A] is a raw memory pointer. It has no descriptor and thus can't be included in a union or intersection, or be a subtype of any interface.","title":"结构体（Structs）","uri":"https://damon-kwok.github.io/pony-tutorial/types/structs.html"},{"content":"Pony allows you to omit certain small details from your code and will put them back in for you. This is done to help make your code less cluttered and more readable. Using sugar is entirely optional, you can always write out the full version if you prefer.\nApply Many Pony classes have a function called apply which performs whatever action is most common for that type. Pony allows you to omit the word apply and just attempt to do a call directly on the object. So:\nvar foo = Foo.create() foo() becomes:\nvar foo = Foo.create() foo.apply() Any required arguments can be added just like normal method calls.\nvar foo = Foo.create() foo(x, 37 where crash = false) becomes:\nvar foo = Foo.create() foo.apply(x, 37 where crash = false) Do I still need to provide the arguments to apply? Yes, only the apply will be added for you, the correct number and type of arguments must be supplied. Default and named arguments can be used as normal.\nHow do I call a function foo if apply is added? The apply sugar is only added when calling an object, not when calling a method. The compiler can tell the difference and only adds the apply when appropriate.\nCreate To create an object you need to specify the type and call a constructor. Pony allows you to miss out the constructor and will insert a call to create() for you. So:\nvar foo = Foo becomes:\nvar foo = Foo.create() Normally types are not valid things to appear in expressions, so omitting the constructor call is not ambiguous. Remember that you can easily spot that a name is a type because it will start with a capital letter.\nIf arguments are needed for create these can be provided as if calling the type. Default and named arguments can be used as normal.\nvar foo = Foo(x, 37 where crash = false) becomes:\nvar foo = Foo.create(x, 37 where crash = false) What if I want to use a constructor that isn’t named create? Then the sugar can’t help you and you have to write it out yourself.\nIf the create I want to call takes no arguments can I still put in the parentheses? No. Calls of the form Type() use the combined create-apply sugar (see below). To get Type.create() just use Type.\nCombined create-apply If a type has a create constructor that takes no arguments then the create and apply sugar can be used together. Just call on the type and calls to create and apply will be added. The call to create will take no arguments and the call to apply will take whatever arguments are supplied.\nvar foo = Foo() var bar = Bar(x, 37 where crash = false) becomes:\nvar foo = Foo.create().apply() var bar = Bar.create().apply(x, 37 where crash = false) What if the create has default arguments? Do I get the combined create-apply sugar if I want to use the defaults? The combined create-apply sugar can only be used when the create constructor has no arguments. If there are default arguments then this sugar cannot be used.\nUpdate The update sugar allows any class to use an assignment to accept data. Many languages allow this for assigning into collections, for example, a simple C array, a[3] = x;.\nIn any assignment where the left-hand side is a function call, Pony will translate this to a call to update, with the value from the right-hand side as an extra argument. So:\nfoo(37) = x becomes:\nfoo.update(37 where value = x) The value from the right-hand side of the assignment is always passed to a parameter named value. Any object can allow this syntax simply by providing an appropriate function update with an argument value.\nDoes my update function have to have a single parameter that takes an integer? No, you can define update to take whatever parameters you like, as long as there is one called value. The following are all fine:\nfoo1(2, 3) = x foo2() = x foo3(37, \"Hello\", 3.5 where a = 2, b = 3) = x Does it matter where value appears in my parameter list? Whilst it doesn’t strictly matter it is good practice to put value as the last parameter. That way all of the others can be specified by position.\n","summary":"Pony allows you to omit certain small details from your code and will put them back in for you. This is done to help make your code less cluttered and more readable. Using sugar is entirely optional, you can always write out the full version if you prefer.\nApply Many Pony classes have a function called apply which performs whatever action is most common for that type. Pony allows you to omit the word apply and just attempt to do a call directly on the object.","title":"语法糖（Sugar）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/sugar.html"},{"content":"An important part of Pony’s capabilities is being able to say “I’m done with this thing.” We’ll cover two means of handling this situation: consuming a variable and destructive reads.\nConsuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don’t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.\nYou can do this by using consume. When you consume a variable you take the value out of it, effectively leaving the variable empty. No code can read from that variable again until a new value is written to it. Consuming a local variable or a parameter allows you to make an alias with the same type, even if it’s an iso or trn. For example:\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! The compiler is happy with that because by consuming a, you’ve said the value can’t be used again and the compiler will complain if you try to.\nfun test(a: Wombat iso) =\u003e var b: Wombat iso = consume a // Allowed! var c: Wombat tag = a // Not allowed! Here’s an example of that. When you try to assign a to c, the compiler will complain.\nCan I consume a field? Definitely not! Consuming something means it is empty, that is, it has no value. There’s no way to be sure no other alias to the object will access that field. If we tried to access a field that was empty, we would crash. But there’s a way to do what you want to do: destructive read.\nDestructive read There’s another way to move a value from one name to another. Earlier, we talked about how assignment in Pony returns the old value of the left-hand side, rather than the new value. This is called destructive read, and we can use it to do what we want to do, even with fields.\nclass Aardvark var buddy: Wombat iso new create() =\u003e buddy = recover Wombat end fun ref test(a: Wombat iso) =\u003e var b: Wombat iso = buddy = consume a // Allowed! Here, we consume a, assign it to the field buddy, and assign the old value of buddy to b.\nWhy is it ok to destructively read fields when we can’t consume them? Because when we do a destructive read, we assign to the field so it always has a value. Unlike consume, there’s no time when the field is empty. That means it’s safe and the compiler doesn’t complain.\n","summary":"An important part of Pony’s capabilities is being able to say “I’m done with this thing.” We’ll cover two means of handling this situation: consuming a variable and destructive reads.\nConsuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don’t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.","title":"转让和破坏性读取（Consume and Destructive Read）","uri":"https://damon-kwok.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html"},{"content":"中缀运算符 Infix operators take two operands and are written between those operands. Arithmetic and comparison operators are the most common:\n1 + 2 a \u003c b Pony has pretty much the same set of infix operators as other languages.\nOperator aliasing Most infix operators in Pony are actually aliases for functions. The left operand is the receiver the function is called on and the right operand is passed as an argument. For example, the following expressions are equivalent:\nx + y x.add(y) This means that + is not a special symbol that can only be applied to magic types. Any type can provide its own add function and the programmer can then use + with that type if they want to.\nWhen defining your own add function there is no restriction on the types of the parameter or the return type. The right side of the + will have to match the parameter type and the whole + expression will have the type that add returns.\nHere’s a full example for defining a type which allows the use of +. This is all you need:\n// Define a suitable type class Pair var _x: U32 = 0 var _y: U32 = 0 new create(x: U32, y: U32) =\u003e _x = x _y = y // Define a + function fun add(other: Pair): Pair =\u003e Pair(_x + other._x, _y + other._y) // Now let's use it class Foo fun foo() =\u003e var x = Pair(1, 2) var y = Pair(3, 4) var z = x + y It is possible to overload infix operators to some degree using union types or f-bounded polymorphism, but this is beyond the scope of this tutorial. See the Pony standard library for further information.\nYou do not have to worry about any of this if you don’t want to. You can simply use the existing infix operators for numbers just like any other language and not provide them for your own types.\nThe full list of infix operators that are aliases for functions is:\n    Operator Method Description Note     + add() Addition    - sub() Subtraction    * mul() Multiplication    / div() Division    % rem() Remainder    %% mod() Modulo Starting with version 0.26.1   \u003c\u003c shl() Left bit shift    \u003e\u003e shr() Right bit shift    and op_and() And, both bitwise and logical    or op_or() Or, both bitwise and logical    xor op_xor() Xor, both bitwise and logical    == eq() Equality    != ne() Non-equality    \u003c lt() Less than    \u003c= le() Less than or equal    \u003e= ge() Greater than or equal    \u003e gt() Greater than    \u003e~ gt_unsafe() Unsafe greater than    +~ add_unsafe() Unsafe Addition    -~ sub_unsafe() Unsafe Subtraction    *~ mul_unsafe() Unsafe Multiplication    /~ div_unsafe() Unsafe Division    %~ rem_unsafe() Unsafe Remainder    %%~ mod_unsafe() Unsafe Modulo Starting with version 0.26.1   \u003c\u003c~ shl_unsafe() Unsafe left bit shift    \u003e\u003e~ shr_unsafe() Unsafe right bit shift    ==~ eq_unsafe() Unsafe equality    !=~ ne_unsafe() Unsafe non-equality    \u003c~ lt_unsafe() Unsafe less than    \u003c=~ le_unsafe() Unsafe less than or equal    \u003e=~ ge_unsafe() Unsafe greater than or equal    +? add_partial()? Partial Addition    -? sub_partial()? Partial Subtraction    *? mul_partial()? Partial Multiplication    /? div_partial()? Partial Division    %? rem_partial()? Partial Remainder    %%? mod_partial()? Partial Modulo Starting with version 0.26.1     Short circuiting The and and or operators use short circuiting when used with Bool variables. This means that the first operand is always evaluated, but the second is only evaluated if it can affect the result.\nFor and, if the first operand is false then the second operand is not evaluated since it cannot affect the result.\nFor or, if the first operand is true then the second operand is not evaluated since it cannot affect the result.\nThis is a special feature built into the compiler, it cannot be used with operator aliasing for any other type.\nUnary operators The unary operators are handled in the same manner, but with only one operand. For example, the following expressions are equivalent:\n-x x.neg() The full list of unary operators that are aliases for functions is:\n    Operator Method Description       | neg() | Arithmetic negation    not | op_not() | Not, both bitwise and logical -~ | neg_unsafe() | Unsafe arithmetic negation\n Precedence In Pony, unary operators always bind stronger than any infix operators: not a == b will be interpreted as (not a) == b instead of not (a == b).\nWhen using infix operators in complex expressions a key question is the precedence, i.e. which operator is evaluated first. Given this expression:\n1 + 2 * 3 // Compilation failed. We will get a value of 9 if we evaluate the addition first and 7 if we evaluate the multiplication first. In mathematics, there are rules about the order in which to evaluate operators and most programming languages follow this approach.\nThe problem with this is that the programmer has to remember the order and people aren’t very good at things like that. Most people will remember to do multiplication before addition, but what about left bit shifting versus bitwise and? Sometimes people misremember (or guess wrong) and that leads to bugs. Worse, those bugs are often very hard to spot.\nPony takes a different approach and outlaws infix precedence. Any expression where more than one infix operator is used must use parentheses to remove the ambiguity. If you fail to do this the compiler will complain.\nThis means that the example above is illegal in Pony and should be rewritten as:\n1 + (2 * 3) // 7 Repeated use of a single operator, however, is fine:\n1 + 2 + 3 // 6 Meanwhile, mixing unary and infix operators do not need additional parentheses as unary operators always bind more closely, so if our example above used a negative three:\n1 + 2 * -3 // Compilation failed. We would still need parentheses to remove the ambiguity for our infix operators like we did above, but not for the unary arithmetic negative (-):\n1 + (2 * -3) // -5 We can see that it makes more sense for the unary operator to be applied before either infix as it only acts on a single number in the expression so it is never ambiguous.\nUnary operators can also be applied to parentheses and act on the result of all operations in those parentheses prior to applying any infix operators outside the parentheses:\n1 + -(2 * -3) // 7 ","summary":"中缀运算符 Infix operators take two operands and are written between those operands. Arithmetic and comparison operators are the most common:\n1 + 2 a \u003c b Pony has pretty much the same set of infix operators as other languages.\nOperator aliasing Most infix operators in Pony are actually aliases for functions. The left operand is the receiver the function is called on and the right operand is passed as an argument.","title":"运算符（Operators）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/ops.html"},{"content":"Pony doesn’t feature exceptions as you might be familiar with them from languages like Python, Java, C++ et al. It does, however, provide a simple partial function mechanism to aid in error handling. Partial functions and the error keyword used to raise them look similar to exceptions in other languages but have some important semantic differences. Let’s take a look at how you work with Pony’s error and then how it differs from the exceptions you might be used to.\nRaising and handling errors An error is raised with the command error. At any point, the code may decide to declare an error has occurred. Code execution halts at that point, and the call chain is unwound until the nearest enclosing error handler is found. This is all checked at compile time so errors cannot cause the whole program to crash.\nError handlers are declared using the try-else syntax.\ntry callA() if not callB() then error end callC() else callD() end In the above code callA() will always be executed and so will callB(). If the result of callB() is true then we will proceed to callC() in the normal fashion and callD() will not then be executed.\nHowever, if callB() returns false, then an error will be raised. At this point, execution will stop and the nearest enclosing error handler will be found and executed. In this example that is, our else block and so callD() will be executed.\nIn either case, execution will then carry on with whatever code comes after the try end.\nDo I have to provide an error handler? No. The try block will handle any errors regardless. If you don’t provide an error handler then no error handling action will be taken - execution will simply continue after the try expression.\nIf you want to do something that might raise an error, but you don’t care if it does you can just put in it a try block without an else.\ntry // Do something that may raise an error end Is there anything my error handler has to do? No. If you provide an error handler then it must contain some code, but it is entirely up to you what it does.\nWhat’s the resulting value of a try block? The result of a try block is the value of the last statement in the try block, or the value of the last statement in the else clause if an error was raised. If an error was raised and there was no else clause provided, the result value will be None.\nPartial functions Pony does not require that all errors are handled immediately as in our previous examples. Instead, functions can raise errors that are handled by whatever code calls them. These are called partial functions (this is a mathematical term meaning a function that does not have a defined result for all possible inputs, i.e. arguments). Partial functions must be marked as such in Pony with a ?, both in the function signature (after the return type) and at the call site (after the closing parentheses).\nFor example, a somewhat contrived version of the factorial function that accepts a signed integer will error if given a negative input. It’s only partially defined over its valid input type.\nfun factorial(x: I32): I32 ? =\u003e if x \u003c 0 then error end if x == 0 then 1 else x * factorial(x - 1)? end Everywhere that an error can be generated in Pony (an error command, a call to a partial function, or certain built-in language constructs) must appear within a try block or a function that is marked as partial. This is checked at compile time, ensuring that an error cannot escape handling and crash the program.\nPrior to Pony 0.16.0, call sites of partial functions were not required to be marked with a ?. This often led to confusion about the possibilities for control flow when reading code. Having every partial function call site clearly marked makes it very easy for the reader to immediately understand everywhere that a block of code may jump away to the nearest error handler, making the possible control flow paths more obvious and explicit.\nPartial constructors and behaviours Class constructors may also be marked as partial. If a class constructor raises an error then the construction is considered to have failed and the object under construction is discarded without ever being returned to the caller.\nWhen an actor constructor is called the actor is created and a reference to it is returned immediately. However, the constructor code is executed asynchronously at some later time. If an actor constructor were to raise an error it would already be too late to report this to the caller. For this reason, constructors for actors may not be partial.\nBehaviours are also executed asynchronously and so cannot be partial for the same reason.\nTry-then blocks In addition to an else error handler, a try command can have a then block. This is executed after the rest of the try, whether or not an error is raised or handled. Expanding our example from earlier:\ntry callA() if not callB() then error end callC() else callD() then callE() end The callE() will always be executed. If callB() returns true then the sequence executed is callA(), callB(), callC(), callE(). If callB() returns false then the sequence executed is callA(), callB(), callD(), callE().\nDo I have to have an else error handler to have a then block? No. You can have a try-then block without an else if you like.\nWill my then block really always be executed, even if I return inside the try? Yes, your then expression will always be executed when the try block is complete. The only way it won’t be is if the try never completes (due to an infinite loop), the machine is powered off, or the process is killed (and then, maybe).\nWith blocks A with expression can be used to ensure disposal of an object when it is no longer needed. A common case is a database connection which needs to be closed after use to avoid resource leaks on the server. For example:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj end obj.dispose() will be called whether the code inside the with block completes successfully or raises an error. To take part in a with expression, the object that needs resource clean-up must, therefore, provide a dispose() method:\nclass SomeObjectThatNeedsDisposing // constructor, other functions fun dispose() =\u003e // release resources It is possible to provide an else clause, which is called only in error cases:\nwith obj = SomeObjectThatNeedsDisposing() do // use obj else // only run if an error has occurred end Multiple objects can be set up for disposal:\nwith obj = SomeObjectThatNeedsDisposing(), other = SomeOtherDisposableObject() do // use obj end The value of a with expression is the value of the last expression in the block, or of the last expression in the else block if there is one and an error occurred.\nLanguage constructs that can raise errors The only language construct that can raise an error, other than the error command or calling a partial method, is the as command. This converts the given value to the specified type if it can be. If it can’t then an error is raised. This means that the as command can only be used inside a try block or a partial method.\nComparison to exceptions in other languages Pony errors behave very much the same as those in C++, Java, C#, Python, and Ruby. The key difference is that Pony errors do not have a type or instance associated with them. This makes them the same as C++ exceptions would be if a fixed literal was always thrown, e.g. throw 3;. This difference simplifies error handling for the programmer and allows for much better runtime error handling performance.\nThe else handler in a try expression is just like a catch(...) in C++, catch(Exception e) in Java or C#, except: in Python, or rescue in Ruby. Since exceptions do not have types there is no need for handlers to specify types or to have multiple handlers in a single try block.\nThe then block in a try expression is just like a finally in Java, C#, or Python and ensure in Ruby.\nIf required, error handlers can “reraise” by using the error command within the handler.\n","summary":"Pony doesn’t feature exceptions as you might be familiar with them from languages like Python, Java, C++ et al. It does, however, provide a simple partial function mechanism to aid in error handling. Partial functions and the error keyword used to raise them look similar to exceptions in other languages but have some important semantic differences. Let’s take a look at how you work with Pony’s error and then how it differs from the exceptions you might be used to.","title":"错误（Errors）","uri":"https://damon-kwok.github.io/pony-tutorial/expressions/errors.html"}]