<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>概述（Overview） on Pony 教程</title>
    <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities.html</link>
    <description>Recent content in 概述（Overview） on Pony 教程</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://damon-kwok.github.io/pony-tutorial/reference-capabilities/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Arrow Types aka Viewpoints</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/arrow-types.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/arrow-types.html</guid>
      <description>When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don&amp;rsquo;t know the precise reference capability of the origin.
When that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -&amp;gt;.
Using this-&amp;gt; as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box.</description>
    </item>
    
    <item>
      <title>Passing and Sharing References</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/passing-and-sharing.html</guid>
      <description>Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.
Passing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.</description>
    </item>
    
    <item>
      <title>Reference Capability Matrix</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-matrix.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-matrix.html</guid>
      <description>At this point, it&amp;rsquo;s quite possible that you read the previous sections in this chapter and are still pretty confused about the relation between reference capabilities. It&amp;rsquo;s okay! We have all struggled when learning this part of Pony, too. Once you start working on Pony code, you&amp;rsquo;ll get a better intuition with them.
In the meantime, if you still feel like all these tidbits in the chapter are still scrambled in your head, there is one resource often presented with Pony that can give you a more visual representation: the reference capability matrix.</description>
    </item>
    
    <item>
      <title>别名（Aliasing）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/aliasing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/aliasing.html</guid>
      <description>Aliasing means having more than one reference to the same object, within the same actor. This can be the case for a variable or a field.
In most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what&amp;rsquo;s being assigned to it, and everything is fine.</description>
    </item>
    
    <item>
      <title>引用权能保证（Reference Capability Guarantees）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/guarantees.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/guarantees.html</guid>
      <description>Since types are guarantees, it&amp;rsquo;s useful to talk about what guarantees a reference capability makes.
What is denied We&amp;rsquo;re going to talk about reference capability guarantees in terms of what&amp;rsquo;s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?
We need to distinguish between the actor that contains the variable in question and other actors.
This is important because data reads and writes from other actors may occur concurrently.</description>
    </item>
    
    <item>
      <title>引用权能（Reference Capabilities）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/reference-capabilities.html</guid>
      <description>如果对象具有权能，我们该怎么来控制？比如如何表示该对象的 访问权限（access rights） ？
Pony中，可以用引用权能（reference capabilities）来处理。
权限只是权能的一部分 如果在UNIX系统中打开一个文件，会返回一个文件描述符，该文件描述符只是一个文件指向标识——并不是一个权能（描述符只体现了能没有体现权,描述符使可以访问文件，但是访问权呢？）。完整的权能：需要获得权限，然后指定文件路径和打开模式。例如:
chmod u+w /etc/passwd int fd = open(&amp;#34;/etc/passwd&amp;#34;, O_RDWR); 现在我们拥有了/etc/passwd文件的读写权，然后使用O_RDWR模式打开们见得到了一个文件描述符。访问授权、打开模式、文件描述符共同构成了一个权能。
在Pony中，所有被引用的数据都有一个类型和一个引用权能（reference capabilities）。实际上，引用权能（reference capabilities）是其类型的一部分。这允许你指定哪些对象可以与其他actor共享，并允许编译器检查你的逻辑是并发安全的。
基本概念（Basic concepts） 在引用权能（reference capabilities）变得有意义之前，您需要理解一些简单的概念。我们已经讨论过其中的一些，有些可能对你来说已经很明显了，但是在这里值得回顾一下。
共享可变数据非常困难
并发性的问题根源来自于共享可变数据。如果两个线程可以同时访问同一个数据，那么它们可能会同时修改它。这最多可能导致两个线程拥有不同版本的数据。在最坏的情况下，更新可能会交互不良，导致数据被垃圾覆盖。避免这些问题的常规做法是使用锁来防止同时发生数据更新。这会导致巨大的性能开销（上下文切换），并且一不小心就会导致bug。
不可变数据可以安全地共享
任何不可变的数据(即不会被修改数据)都可以安全地并发使用。因为它们永远不会更新，正是更新导致了并发性问题。
被隔离的数据是安全的
如果一个数据块只有一个对它的引用，那么我们称它为 被隔离的数据(isolated) 。因为只有一个对它的引用，所以不会被被多个线程共享，也就不存在并发问题。被隔离的数据可以在多个线程之间传递。只要同一时间只存在一个对它的引用，那么数据就是安全的，不会出现并发问题。
被隔离的数据有可以是复合类型
一个被隔离的数据（isolated）可以是一个字节，也可以是一个大型数据结构，并且在该结构中的各个对象之间有多个引用。对于隔离的数据来说，重要的是整个程序中只有一个单一的引用。我们讨论了数据结构的隔离边界。对结构进行隔离:
 外部必须只能有一个指向内部对象的引用。 外部可以有任意数量的引用，但它们都不能指向外部的对象。  每个actor都只会在一个线程中运行
actor内部的代码永远不会并发运行。在actor中，数据更新不会导致并发问题。只有当我们希望在actor之间共享数据时，才会遇到问题。
好吧，看来同时安全地共享数据确实很棘手，来看看引用权能（reference capabilities）是怎么做到的。
通过只共享不可变的数据和只交换被隔离的数据，我们可以拥有没有锁的安全并发程序。问题是要正确地做到这一点是非常困难的。如果您不小心挂起了对某些已提交的独立数据的引用，或者将已共享的内容更改为不可变的，那么一切都会出错。你需要的是编译器强迫你去实现你的承诺。小马引用权能（reference capabilities）允许编译器这样做。
类型限定符（Type qualifiers） 如果你使用过C/C++，您可能熟悉const，它是一个 类型限定符（type qualifier） ，告诉编译器不允许程序员修改某些东西。
A reference capability is a form of type qualifier and provides a lot more guarantees than const does! 引用权能（reference capabilities）是 type qualifier 的一种形式，它提供了比const多得多的保证!</description>
    </item>
    
    <item>
      <title>权能借用（Recovering Capabilities）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/recovering-capabilities.html</guid>
      <description>A recover expression lets you &amp;ldquo;lift&amp;rdquo; the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.
Why is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:</description>
    </item>
    
    <item>
      <title>权能包含关系（Capability Subtyping）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/capability-subtyping.html</guid>
      <description>Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.
Simple substitution First, let&amp;rsquo;s cover substitution without worrying about ephemeral types (^) or alias types (!). The &amp;lt;: symbol means &amp;ldquo;is a subtype of&amp;rdquo; or alternatively &amp;ldquo;can be substituted for&amp;rdquo;.
 iso &amp;lt;: trn. An iso is read and write unique, and a trn is just write unique, so it&amp;rsquo;s safe to substitute an iso for a trn.</description>
    </item>
    
    <item>
      <title>权能合并（Combining Capabilities）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/combining-capabilities.html</guid>
      <description>When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.
This is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.
Viewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation.</description>
    </item>
    
    <item>
      <title>转让和破坏性读取（Consume and Destructive Read）</title>
      <link>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/pony-tutorial/reference-capabilities/consume-and-destructive-read.html</guid>
      <description>An important part of Pony&amp;rsquo;s capabilities is being able to say &amp;ldquo;I&amp;rsquo;m done with this thing.&amp;rdquo; We&amp;rsquo;ll cover two means of handling this situation: consuming a variable and destructive reads.
Consuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don&amp;rsquo;t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.</description>
    </item>
    
  </channel>
</rss>