<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>概述（Overview） on Pony 教程</title>
    <link>https://damon-kwok.github.io/types.html</link>
    <description>Recent content in 概述（Overview） on Pony 教程</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://damon-kwok.github.io/types/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基元类（Primitives）</title>
      <link>https://damon-kwok.github.io/types/primitives.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/primitives.html</guid>
      <description>primitive（基元类） 和 class（类） 有两点主要区别：
 基元类 没有字段。  一个 基元类 只会产生一个实例。  没有字段意味着primitive不会产生副作用。只有一个实例意味着，如果您的代码以 primitive 的构造函数总是会返回相同的实例对象（下面介绍的内置内省&amp;quot;machine word&amp;rdquo; primitives除外）。
primitive 有什么用途？ 基元类有三种主要用途（如果算上内置的&amp;quot;machine word&amp;rdquo; primitives则有四种）。
1.作为&amp;quot;标记值&amp;rdquo;。例如，Pony经常使用 primitive None来表示某事物没有值。当然，它确实具有一个值，以便您可以检查它是什么，并且该值是“无”的单个实例。 2.作为&amp;quot;枚举&amp;quot;类型。通过具有 primitive 类型的 union ，您可以具有类型安全的枚举。稍后我们将介绍 union 类型。 3.作为&amp;quot;函数集合&amp;rdquo;。由于基元可以具有函数，因此可以将函数分组为基元类型。您可以在标准库中看到这一点，例如，路径处理功能在 primitive Path中分组。
// 2 &amp;quot;marker values&amp;quot; primitive OpenedDoor primitive ClosedDoor // An &amp;quot;enumeration&amp;quot; type type DoorState is (OpenedDoor | ClosedDoor) // A collection of functions primitive BasicMath fun add(a: U64, b: U64): U64 =&amp;gt; a + b fun multiply(a: U64, b: U64): U64 =&amp;gt; a * b actor Main new create(env: Env) =&amp;gt; let doorState : DoorState = ClosedDoor let isDoorOpen : Bool = match doorState | OpenedDoor =&amp;gt; true | ClosedDoor =&amp;gt; false end env.</description>
    </item>
    
    <item>
      <title>并发单元（Actors）</title>
      <link>https://damon-kwok.github.io/types/actors.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/actors.html</guid>
      <description>actor 和 类 类似，但是有一个关键区别：actor可以有 行为 。
Behaviours 行为 行为 类似于 函数，不过函数是 同步执行 的，但是行为是 异步执行 的。换句话说，当您调用一个函数时，该函数将立即执行，并且立即就可以得到函数的返回值。函数就像其他面向对象语言中的方法调用一样。
但是调用行为，__不会__立即执行。相反，该行为的将在将来某个不确定的时间执行。
行为看起来像一个函数，但是它不是由关键字fun定义的，而是使用be关键字。
和函数一样，行为也可以具有参数。与函数不同，它没有接收器功能（可以在任何功能的接收器上调用行为），您不能为行为指定返回类型。
那么行为会返回什么呢？ 行为总是返回None，就像没有显式的返回类型的函数一样，它们无法返回所计算的内容（因为调用时它们尚未运行）。
actor Aardvark let name: String var _hunger_level: U64 = 0 new create(name&#39;: String) =&amp;gt; name = name&#39; be eat(amount: U64) =&amp;gt; _hunger_level = _hunger_level - amount.min(_hunger_level) Here we have an Aardvark that can eat asynchronously. Clever Aardvark. 在这里，我们有一个可以异步进餐的“土豚”。聪明的土豚。
消息处理 如果您熟悉基于语言的语言（例如Erlang），那么您将熟悉“消息传递”的概念。演员之间就是这样交流的。行为等同于小马。当您调用演员的行为时，您正在向其发送消息。
如果您不熟悉消息传递，则不必担心。我们已经覆盖了您。所有内容将在下面说明。
并发 由于行为是异步的，因此可以同时运行一系列行为的主体。这正是Pony所做的。 Pony运行时具有自己的协作调度程序，默认情况下，该调度程序的线程数等于您计算机上的CPU内核数。每个调度程序线程可以在任何给定时间执行参与者行为，因此Pony程序自然是并发的。
执行次序 Actor本身是有序的。也就是说，每个actor一次只能执行一个行为。这意味着可以在不考虑并发性的情况下编写actor中的所有代码：不需要锁，信号量或类似的东西。
在编写Pony代码时，最好不要将actor看作是并行性的单元，而是序列性的单元。也就是说，演员应该只执行顺序要执行的操作。其他任何东西都可以分解为另一个actor，使其自动并行。
在下面的示例中，Main actor调用了一个行为call_me_later，正如我们所知，该行为是_asynchronous_，因此我们无需等待它运行就可以继续。然后，我们运行方法“ env.out.print”，它也是_asynchronous_，并将提供的文本打印到终端。现在，我们已经完成了在Main角色中执行代码的工作，我们先前调用的行为最终将运行，并且将打印最后的文本。</description>
    </item>
    
    <item>
      <title>特征和接口（Traits and Interfaces）</title>
      <link>https://damon-kwok.github.io/types/traits-and-interfaces.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/traits-and-interfaces.html</guid>
      <description>Like other object-oriented languages, Pony has subtyping. That is, some types serve as categories that other types can be members of.
There are two kinds of subtyping in programming languages: nominal and structural. They&amp;rsquo;re subtly different, and most programming languages only have one or the other. Pony has both!
Nominal subtyping This kind of subtyping is called nominal because it is all about names.
If you&amp;rsquo;ve done object-oriented programming before, you may have seen a lot of discussion about single inheritance, multiple inheritance, mixins, traits, and similar concepts.</description>
    </item>
    
    <item>
      <title>类型别名（Type Aliases）</title>
      <link>https://damon-kwok.github.io/types/type-aliases.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/type-aliases.html</guid>
      <description>A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.
We&amp;rsquo;ll give a couple examples of using type aliases, just to get the feel of them.
Enumerations One way to use type aliases is to express an enumeration.</description>
    </item>
    
    <item>
      <title>类型系统概览</title>
      <link>https://damon-kwok.github.io/types/at-a-glance.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/at-a-glance.html</guid>
      <description>Pony是一种静态类型的语言，和Java，C＃，C++等语言类似。编译器知道你的程序中所有的数据类型。有别于动态类型的语言（例如Python，Lua，JavaScript和Ruby）。
静态语言与动态语言究竟有何不同？ 在两种语言中，数据都具有数据类型。那有什么区别呢？
在 动态类型 语言中，变量可以在不同的时间指向不同类型的对象。这很灵活，比如一个变量x，你可以为其分配一个整数，然后为其赋值一个字符串，编译器或解释器不会报错。
动态语言中给x赋了整数值后在对其执行字符串操作会发生什么？ 多数情况下，您的程序会报错。你需要以某种方式处理该错误（处理方式取决于你用的语言），如果不处理，程序将会崩溃。
当你使用 静态类型 语言时，变量具有类型。一个变量只能指向某一种类型（在Pony中，类型实际上可以是类型的集合，我们将在后面看到）。如果有一个整数型变量x，那就不能再赋值字符串。否则编译器会报错，程序会无法运行。
类型带来的保证 当编译器知道数据类型时，它可以确保程序中的数据符合预期可以运行，而无需在运行时再对数据进行类型检测。这就是静态语言的类型系统提供的 保证 。
类型系统越强大，在编译时就可以从程序获得越多有用的信息（用来分析）。
动态类型是否也可以保证？ 可以是可以，但需要是在运行时间才能处理。例如，如果您调用一个不存在的方法，会触发到某种异常。但是，只有在运行到这行代码时，才会触发。
Pony的类型系统可以为我们带来什么保证？ Pony类型的系统提供了很多保证，甚至比其他静态类型的语言还要多。
 能通过编译，就不会崩溃。 永远不会有未处理的异常。 没有null类型，不需要判断null。 无数据竞争。 不会出现死锁。 代码权能安全性。 所有消息传递为 causal （不可以！）  上述的概念中有一些你现在可以理解。还有一些不能理解的概念暂时可以无需关心（例如权能安全性和因果消息传递），但稍后我们将介绍这些概念。
用Pony的FFI调用其他种语言编写的代码，Pony是否能调用的代码做出类型保证？ 很不幸，并不能。 Pony的类型系统保证性仅适用于Pony编写的代码。用其他语言编写的代码，需要其他语言来提供保证。</description>
    </item>
    
    <item>
      <title>类型表达式（Type Expressions）</title>
      <link>https://damon-kwok.github.io/types/type-expressions.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/type-expressions.html</guid>
      <description>到目前为止，我们已经学习过的类型都可以应用在在 类型表达式（type expressions） 中。如果您熟悉面向对象的编程，那你可能会觉得这个叫法很奇怪，但是它们在函数式编程中很常见。 类型表达式 也称为 代数数据类型 。
有三种类型表达式：（元组）tuples ， （类型联合体）unions 和 （集合）intersections 。
元组（Tuples） 一个 元组 是一个类型序列。列入，如果想要一个字符串后面跟着一个U64整数，可以这样写：
var x: (String, U64) x = (&amp;quot;hi&amp;quot;, 3) x = (&amp;quot;bye&amp;quot;, 7) 所有的类型表达式都包裹在一对小括号中，元组的元素分隔符是逗号。我们这样对一个元组进行解析：
(var y, var z) = x 或这样用这样的方式访问元组中的某个元素：
var y = x._1 var z = x._2 需要注意的是，不能对元组的某一个元素进行单独赋值。正确的做法是重新赋值整个元组，就像这样：
x = (&amp;quot;wombat&amp;quot;, x._2) 为什么要用元组而不是类？ 元组是一种集合表达式，集合中包含了具有预期行为的值，不含任何方法或行为。如果您只需要快速收集事物，例如从一个函数返回多个值，则可以使用一个元组。
Unions（类型联合体） 类型联合体 的定义方式类似 元组 ，元组的元素使用,分隔符，类型联合体使用|分隔符。元组表示一堆值的集合，类型联合体表示一个值，该值的类型可以是元素列表中定义的其中一个类型。
在与其他语言交互时，类型联合体可以用于描述很多其他语言中的概念。例如，可选值，枚举，标记值等。
var x: (String | None) 上面的例子中，我们顶一个了一个变量x，它的值可以是String类型，也可以为None。
Intersections（类型集合） 类型集合 使用&amp;amp;作为元素分隔符。它与类型联合体正好相反：该值的类型是元素列表中定义的 所有 类型的组合。</description>
    </item>
    
    <item>
      <title>类（Classes）</title>
      <link>https://damon-kwok.github.io/types/classes.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/classes.html</guid>
      <description>和其他面向对象语言一样，Pony也有 类 。声明一个类的关键字是class，类名首字母必须大写，就像这样：
class Wombat 所有的类型都必须以大写字母开头吗？ 没错！当你阅读Pony代码时，你可以通过命名轻松判断是否是一个类型。
What goes in a class? 一个类的组成：
 字段  构造函数  函数  字段 和C++、C#、Java、Python、Ruby等语言中的字段（类数据成员，类成员变量）类似。字段有三种声明方式：var,let和embed。var字段可以初始化和反复赋值，但是let字段初始化后无法再次赋值,embed字段比较复杂，详情参考变量章节。
class Wombat let name: String var _hunger_level: U64 上面例子中，类Wombat有一个String类型的name字段，和一个U64（64位无符号长整形）类型的_hunger_level字段。
下划线开头是啥意思？ 它表示 私有 ，一个 私有 字段只能在类内部使用，外部无法访问。下划线同样可以作用于 构造函数 ， 函数 和 行为 ，标识只能在 包 内部访问。稍后会讲解到 包 的概念。
构造函数 Pony的构造函数可以起 别名 。和其他语言里一样，构造函数返回一个新的类型实例，但Pony 别名 可以有更多的构造方式。
声明一个构造函数需要用 new 关键字。
class Wombat let name: String var _hunger_level: U64 new create(name&#39;: String) =&amp;gt; name = name&#39; _hunger_level = 0 new hungry(name&#39;: String, hunger&#39;: U64) =&amp;gt; name = name&#39; _hunger_level = hunger&#39; 上面例子中，我们创建了两个构造函数，第一个用来创建正常状态的树袋熊（Wombat）,第二个用来构造具有饥饿等级的树袋熊。Pony的构造函数__别名__机制为创建实例，提供了多样性。构造对象时使用.</description>
    </item>
    
    <item>
      <title>结构体（Structs）</title>
      <link>https://damon-kwok.github.io/types/structs.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://damon-kwok.github.io/types/structs.html</guid>
      <description>一个“结构”类似于一个“类”。有几个非常重要的区别。您将在整个Pony代码中使用类。您将很少使用结构。我们将在本教程的[C-FFI章]（/ c-ffi.html）中更深入地讨论结构。同时，这是对结构基础的简短介绍。
Structs are &amp;ldquo;classes for FFI&amp;rdquo; A struct is a class like mechanism used to pass data back and forth with C code via Pony&amp;rsquo;s Foreign Function Interface.
struct是类似于类的机制，用于通过Pony的外函数接口与C代码来回传递数据。 像类一样，Pony结构可以包含字段和方法。与类不同，Pony结构与C结构具有相同的二进制布局，并且可以在C函数中透明使用。结构没有类型描述符，这意味着它们不能用于代数类型或实现特征/接口。
What goes in a struct? 和上课一样！结构由以下几种组合组成：
1.字段 2.构造函数 3.函数
字段 Pony struct字段的定义方式与Pony类的定义方式相同，分别使用“ embed”，“ let”和“ var”。嵌入字段嵌入在其父对象中，就像C结构内部的C结构一样。 var / let字段是指向单独分配的对象的指针。
例如：
struct Inner var x: I32 = 0 struct Outer embed inner_embed: Inner = Inner var inner_var: Inner = Inner 构造函数 与类的构造函数一样，结构体的构造函数也可以设置名称。您先前了解的有关Pony类构造函数的所有知识都适用于结构构造函数。</description>
    </item>
    
  </channel>
</rss>